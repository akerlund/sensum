
build/sensor2.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <Reset_Handler>:
 80001c0:	b672      	cpsid	i
 80001c2:	4837      	ldr	r0, [pc, #220]	; (80002a0 <endfiniloop+0x6>)
 80001c4:	f380 8809 	msr	PSP, r0
 80001c8:	4836      	ldr	r0, [pc, #216]	; (80002a4 <endfiniloop+0xa>)
 80001ca:	f64e 5108 	movw	r1, #60680	; 0xed08
 80001ce:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001d2:	6008      	str	r0, [r1, #0]
 80001d4:	f240 0000 	movw	r0, #0
 80001d8:	f2cc 0000 	movt	r0, #49152	; 0xc000
 80001dc:	f64e 7134 	movw	r1, #61236	; 0xef34
 80001e0:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001e4:	6008      	str	r0, [r1, #0]
 80001e6:	f3bf 8f4f 	dsb	sy
 80001ea:	f3bf 8f6f 	isb	sy
 80001ee:	f240 0000 	movw	r0, #0
 80001f2:	f2c0 00f0 	movt	r0, #240	; 0xf0
 80001f6:	f64e 5188 	movw	r1, #60808	; 0xed88
 80001fa:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001fe:	6008      	str	r0, [r1, #0]
 8000200:	f3bf 8f4f 	dsb	sy
 8000204:	f3bf 8f6f 	isb	sy
 8000208:	f04f 0000 	mov.w	r0, #0
 800020c:	eee1 0a10 	vmsr	fpscr, r0
 8000210:	f64e 713c 	movw	r1, #61244	; 0xef3c
 8000214:	f2ce 0100 	movt	r1, #57344	; 0xe000
 8000218:	6008      	str	r0, [r1, #0]
 800021a:	2006      	movs	r0, #6
 800021c:	f380 8814 	msr	CONTROL, r0
 8000220:	f3bf 8f6f 	isb	sy
 8000224:	f003 fabc 	bl	80037a0 <__core_init>
 8000228:	f003 feaa 	bl	8003f80 <__early_init>
 800022c:	481e      	ldr	r0, [pc, #120]	; (80002a8 <endfiniloop+0xe>)
 800022e:	491f      	ldr	r1, [pc, #124]	; (80002ac <endfiniloop+0x12>)
 8000230:	4a1f      	ldr	r2, [pc, #124]	; (80002b0 <endfiniloop+0x16>)

08000232 <msloop>:
 8000232:	4291      	cmp	r1, r2
 8000234:	bf3c      	itt	cc
 8000236:	f841 0b04 	strcc.w	r0, [r1], #4
 800023a:	e7fa      	bcc.n	8000232 <msloop>
 800023c:	491d      	ldr	r1, [pc, #116]	; (80002b4 <endfiniloop+0x1a>)
 800023e:	4a18      	ldr	r2, [pc, #96]	; (80002a0 <endfiniloop+0x6>)

08000240 <psloop>:
 8000240:	4291      	cmp	r1, r2
 8000242:	bf3c      	itt	cc
 8000244:	f841 0b04 	strcc.w	r0, [r1], #4
 8000248:	e7fa      	bcc.n	8000240 <psloop>
 800024a:	491b      	ldr	r1, [pc, #108]	; (80002b8 <endfiniloop+0x1e>)
 800024c:	4a1b      	ldr	r2, [pc, #108]	; (80002bc <endfiniloop+0x22>)
 800024e:	4b1c      	ldr	r3, [pc, #112]	; (80002c0 <endfiniloop+0x26>)

08000250 <dloop>:
 8000250:	429a      	cmp	r2, r3
 8000252:	bf3e      	ittt	cc
 8000254:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000258:	f842 0b04 	strcc.w	r0, [r2], #4
 800025c:	e7f8      	bcc.n	8000250 <dloop>
 800025e:	2000      	movs	r0, #0
 8000260:	4918      	ldr	r1, [pc, #96]	; (80002c4 <endfiniloop+0x2a>)
 8000262:	4a19      	ldr	r2, [pc, #100]	; (80002c8 <endfiniloop+0x2e>)

08000264 <bloop>:
 8000264:	4291      	cmp	r1, r2
 8000266:	bf3c      	itt	cc
 8000268:	f841 0b04 	strcc.w	r0, [r1], #4
 800026c:	e7fa      	bcc.n	8000264 <bloop>
 800026e:	f003 fa5f 	bl	8003730 <__init_ram_areas>
 8000272:	f003 fa8d 	bl	8003790 <__late_init>
 8000276:	4c15      	ldr	r4, [pc, #84]	; (80002cc <endfiniloop+0x32>)
 8000278:	4d15      	ldr	r5, [pc, #84]	; (80002d0 <endfiniloop+0x36>)

0800027a <initloop>:
 800027a:	42ac      	cmp	r4, r5
 800027c:	da03      	bge.n	8000286 <endinitloop>
 800027e:	f854 1b04 	ldr.w	r1, [r4], #4
 8000282:	4788      	blx	r1
 8000284:	e7f9      	b.n	800027a <initloop>

08000286 <endinitloop>:
 8000286:	f000 f8e3 	bl	8000450 <main>
 800028a:	4c12      	ldr	r4, [pc, #72]	; (80002d4 <endfiniloop+0x3a>)
 800028c:	4d12      	ldr	r5, [pc, #72]	; (80002d8 <endfiniloop+0x3e>)

0800028e <finiloop>:
 800028e:	42ac      	cmp	r4, r5
 8000290:	da03      	bge.n	800029a <endfiniloop>
 8000292:	f854 1b04 	ldr.w	r1, [r4], #4
 8000296:	4788      	blx	r1
 8000298:	e7f9      	b.n	800028e <finiloop>

0800029a <endfiniloop>:
 800029a:	f003 ba71 	b.w	8003780 <__default_exit>
 800029e:	0000      	.short	0x0000
 80002a0:	20000800 	.word	0x20000800
 80002a4:	08000000 	.word	0x08000000
 80002a8:	55555555 	.word	0x55555555
 80002ac:	20000000 	.word	0x20000000
 80002b0:	20000400 	.word	0x20000400
 80002b4:	20000400 	.word	0x20000400
 80002b8:	080053f4 	.word	0x080053f4
 80002bc:	20000800 	.word	0x20000800
 80002c0:	20000808 	.word	0x20000808
 80002c4:	20000808 	.word	0x20000808
 80002c8:	20001c64 	.word	0x20001c64
 80002cc:	080001c0 	.word	0x080001c0
 80002d0:	080001c0 	.word	0x080001c0
 80002d4:	080001c0 	.word	0x080001c0
 80002d8:	080001c0 	.word	0x080001c0

080002dc <_port_switch>:
 80002dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002e0:	ed2d 8a10 	vpush	{s16-s31}
 80002e4:	f8c1 d00c 	str.w	sp, [r1, #12]
 80002e8:	68c3      	ldr	r3, [r0, #12]
 80002ea:	469d      	mov	sp, r3
 80002ec:	ecbd 8a10 	vpop	{s16-s31}
 80002f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002f4 <_port_thread_start>:
 80002f4:	f002 ff64 	bl	80031c0 <_dbg_check_unlock>
 80002f8:	2300      	movs	r3, #0
 80002fa:	f383 8811 	msr	BASEPRI, r3
 80002fe:	4628      	mov	r0, r5
 8000300:	47a0      	blx	r4
 8000302:	2000      	movs	r0, #0
 8000304:	f003 f9dc 	bl	80036c0 <chThdExit>

08000308 <_port_switch_from_isr>:
 8000308:	f002 ff82 	bl	8003210 <_dbg_check_lock>
 800030c:	f002 fe28 	bl	8002f60 <chSchDoReschedule>
 8000310:	f002 ff56 	bl	80031c0 <_dbg_check_unlock>

08000314 <_port_exit_from_isr>:
 8000314:	df00      	svc	0
 8000316:	e7fe      	b.n	8000316 <_port_exit_from_isr+0x2>

08000318 <memcpy>:
 8000318:	4684      	mov	ip, r0
 800031a:	ea41 0300 	orr.w	r3, r1, r0
 800031e:	f013 0303 	ands.w	r3, r3, #3
 8000322:	d16d      	bne.n	8000400 <memcpy+0xe8>
 8000324:	3a40      	subs	r2, #64	; 0x40
 8000326:	d341      	bcc.n	80003ac <memcpy+0x94>
 8000328:	f851 3b04 	ldr.w	r3, [r1], #4
 800032c:	f840 3b04 	str.w	r3, [r0], #4
 8000330:	f851 3b04 	ldr.w	r3, [r1], #4
 8000334:	f840 3b04 	str.w	r3, [r0], #4
 8000338:	f851 3b04 	ldr.w	r3, [r1], #4
 800033c:	f840 3b04 	str.w	r3, [r0], #4
 8000340:	f851 3b04 	ldr.w	r3, [r1], #4
 8000344:	f840 3b04 	str.w	r3, [r0], #4
 8000348:	f851 3b04 	ldr.w	r3, [r1], #4
 800034c:	f840 3b04 	str.w	r3, [r0], #4
 8000350:	f851 3b04 	ldr.w	r3, [r1], #4
 8000354:	f840 3b04 	str.w	r3, [r0], #4
 8000358:	f851 3b04 	ldr.w	r3, [r1], #4
 800035c:	f840 3b04 	str.w	r3, [r0], #4
 8000360:	f851 3b04 	ldr.w	r3, [r1], #4
 8000364:	f840 3b04 	str.w	r3, [r0], #4
 8000368:	f851 3b04 	ldr.w	r3, [r1], #4
 800036c:	f840 3b04 	str.w	r3, [r0], #4
 8000370:	f851 3b04 	ldr.w	r3, [r1], #4
 8000374:	f840 3b04 	str.w	r3, [r0], #4
 8000378:	f851 3b04 	ldr.w	r3, [r1], #4
 800037c:	f840 3b04 	str.w	r3, [r0], #4
 8000380:	f851 3b04 	ldr.w	r3, [r1], #4
 8000384:	f840 3b04 	str.w	r3, [r0], #4
 8000388:	f851 3b04 	ldr.w	r3, [r1], #4
 800038c:	f840 3b04 	str.w	r3, [r0], #4
 8000390:	f851 3b04 	ldr.w	r3, [r1], #4
 8000394:	f840 3b04 	str.w	r3, [r0], #4
 8000398:	f851 3b04 	ldr.w	r3, [r1], #4
 800039c:	f840 3b04 	str.w	r3, [r0], #4
 80003a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003a4:	f840 3b04 	str.w	r3, [r0], #4
 80003a8:	3a40      	subs	r2, #64	; 0x40
 80003aa:	d2bd      	bcs.n	8000328 <memcpy+0x10>
 80003ac:	3230      	adds	r2, #48	; 0x30
 80003ae:	d311      	bcc.n	80003d4 <memcpy+0xbc>
 80003b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003b4:	f840 3b04 	str.w	r3, [r0], #4
 80003b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003bc:	f840 3b04 	str.w	r3, [r0], #4
 80003c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80003c4:	f840 3b04 	str.w	r3, [r0], #4
 80003c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003cc:	f840 3b04 	str.w	r3, [r0], #4
 80003d0:	3a10      	subs	r2, #16
 80003d2:	d2ed      	bcs.n	80003b0 <memcpy+0x98>
 80003d4:	320c      	adds	r2, #12
 80003d6:	d305      	bcc.n	80003e4 <memcpy+0xcc>
 80003d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80003dc:	f840 3b04 	str.w	r3, [r0], #4
 80003e0:	3a04      	subs	r2, #4
 80003e2:	d2f9      	bcs.n	80003d8 <memcpy+0xc0>
 80003e4:	3204      	adds	r2, #4
 80003e6:	d008      	beq.n	80003fa <memcpy+0xe2>
 80003e8:	07d2      	lsls	r2, r2, #31
 80003ea:	bf1c      	itt	ne
 80003ec:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80003f0:	f800 3b01 	strbne.w	r3, [r0], #1
 80003f4:	d301      	bcc.n	80003fa <memcpy+0xe2>
 80003f6:	880b      	ldrh	r3, [r1, #0]
 80003f8:	8003      	strh	r3, [r0, #0]
 80003fa:	4660      	mov	r0, ip
 80003fc:	4770      	bx	lr
 80003fe:	bf00      	nop
 8000400:	2a08      	cmp	r2, #8
 8000402:	d313      	bcc.n	800042c <memcpy+0x114>
 8000404:	078b      	lsls	r3, r1, #30
 8000406:	d08d      	beq.n	8000324 <memcpy+0xc>
 8000408:	f010 0303 	ands.w	r3, r0, #3
 800040c:	d08a      	beq.n	8000324 <memcpy+0xc>
 800040e:	f1c3 0304 	rsb	r3, r3, #4
 8000412:	1ad2      	subs	r2, r2, r3
 8000414:	07db      	lsls	r3, r3, #31
 8000416:	bf1c      	itt	ne
 8000418:	f811 3b01 	ldrbne.w	r3, [r1], #1
 800041c:	f800 3b01 	strbne.w	r3, [r0], #1
 8000420:	d380      	bcc.n	8000324 <memcpy+0xc>
 8000422:	f831 3b02 	ldrh.w	r3, [r1], #2
 8000426:	f820 3b02 	strh.w	r3, [r0], #2
 800042a:	e77b      	b.n	8000324 <memcpy+0xc>
 800042c:	3a04      	subs	r2, #4
 800042e:	d3d9      	bcc.n	80003e4 <memcpy+0xcc>
 8000430:	3a01      	subs	r2, #1
 8000432:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000436:	f800 3b01 	strb.w	r3, [r0], #1
 800043a:	d2f9      	bcs.n	8000430 <memcpy+0x118>
 800043c:	780b      	ldrb	r3, [r1, #0]
 800043e:	7003      	strb	r3, [r0, #0]
 8000440:	784b      	ldrb	r3, [r1, #1]
 8000442:	7043      	strb	r3, [r0, #1]
 8000444:	788b      	ldrb	r3, [r1, #2]
 8000446:	7083      	strb	r3, [r0, #2]
 8000448:	4660      	mov	r0, ip
 800044a:	4770      	bx	lr
 800044c:	0000      	movs	r0, r0
	...

08000450 <main>:
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c) and AHB2 is not
     present in STM32F410. */
  rccResetAHB1(~0);
 8000450:	4bcd      	ldr	r3, [pc, #820]	; (8000788 <main+0x338>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000452:	4cce      	ldr	r4, [pc, #824]	; (800078c <main+0x33c>)
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c) and AHB2 is not
     present in STM32F410. */
  rccResetAHB1(~0);
 8000454:	691a      	ldr	r2, [r3, #16]
 8000456:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800045a:	2200      	movs	r2, #0
}

/*
 * Application entry point.
 */
int main(void) {
 800045c:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8000460:	6119      	str	r1, [r3, #16]
 8000462:	611a      	str	r2, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 8000464:	6958      	ldr	r0, [r3, #20]
 8000466:	6159      	str	r1, [r3, #20]
 8000468:	615a      	str	r2, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800046a:	6a18      	ldr	r0, [r3, #32]
 800046c:	f060 5080 	orn	r0, r0, #268435456	; 0x10000000
 8000470:	6218      	str	r0, [r3, #32]
 8000472:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8000474:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8000476:	6259      	str	r1, [r3, #36]	; 0x24
 8000478:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800047a:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800047c:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8000480:	6419      	str	r1, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000482:	6821      	ldr	r1, [r4, #0]
 8000484:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8000488:	6021      	str	r1, [r4, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800048a:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800048c:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8000490:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8000494:	b097      	sub	sp, #92	; 0x5c
 8000496:	d003      	beq.n	80004a0 <main+0x50>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8000498:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 800049c:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 800049e:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 80004a0:	49ba      	ldr	r1, [pc, #744]	; (800078c <main+0x33c>)
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
 80004a2:	4cbb      	ldr	r4, [pc, #748]	; (8000790 <main+0x340>)
 80004a4:	684b      	ldr	r3, [r1, #4]
 80004a6:	4ebb      	ldr	r6, [pc, #748]	; (8000794 <main+0x344>)
 80004a8:	4dbb      	ldr	r5, [pc, #748]	; (8000798 <main+0x348>)
 80004aa:	2200      	movs	r2, #0
 80004ac:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80004b0:	604b      	str	r3, [r1, #4]
 80004b2:	4610      	mov	r0, r2
 80004b4:	6022      	str	r2, [r4, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80004b6:	4611      	mov	r1, r2
    _stm32_dma_streams[i].stream->CR = 0U;
 80004b8:	4614      	mov	r4, r2
 80004ba:	5833      	ldr	r3, [r6, r0]
 80004bc:	601c      	str	r4, [r3, #0]
    dma_isr_redir[i].dma_func = NULL;
 80004be:	f845 4031 	str.w	r4, [r5, r1, lsl #3]
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80004c2:	3101      	adds	r1, #1
 80004c4:	2910      	cmp	r1, #16
 80004c6:	f100 000c 	add.w	r0, r0, #12
    _stm32_dma_streams[i].stream->CR = 0U;
 80004ca:	f04f 0300 	mov.w	r3, #0
 */
void dmaInit(void) {
  unsigned i;

  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 80004ce:	d1f4      	bne.n	80004ba <main+0x6a>
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 80004d0:	f8df 82f0 	ldr.w	r8, [pc, #752]	; 80007c4 <main+0x374>
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
 80004d4:	4eb1      	ldr	r6, [pc, #708]	; (800079c <main+0x34c>)
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 80004d6:	f8df a2b0 	ldr.w	sl, [pc, #688]	; 8000788 <main+0x338>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80004da:	f8df c2ec 	ldr.w	ip, [pc, #748]	; 80007c8 <main+0x378>
 80004de:	f8df e2ec 	ldr.w	lr, [pc, #748]	; 80007cc <main+0x37c>
 80004e2:	48af      	ldr	r0, [pc, #700]	; (80007a0 <main+0x350>)
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
 80004e4:	f8df b2e8 	ldr.w	fp, [pc, #744]	; 80007d0 <main+0x380>
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 80004e8:	4dae      	ldr	r5, [pc, #696]	; (80007a4 <main+0x354>)
 80004ea:	4faf      	ldr	r7, [pc, #700]	; (80007a8 <main+0x358>)
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 80004ec:	4caf      	ldr	r4, [pc, #700]	; (80007ac <main+0x35c>)
 80004ee:	49b0      	ldr	r1, [pc, #704]	; (80007b0 <main+0x360>)
  dma_streams_mask = 0U;
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = 0U;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 80004f0:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
 80004f4:	f8c8 9008 	str.w	r9, [r8, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 80004f8:	f8c8 900c 	str.w	r9, [r8, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 80004fc:	f8c6 9008 	str.w	r9, [r6, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 8000500:	f8c6 900c 	str.w	r9, [r6, #12]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8000504:	f8da 8030 	ldr.w	r8, [sl, #48]	; 0x30
 8000508:	ea6f 2858 	mvn.w	r8, r8, lsr #9
 800050c:	ea6f 2848 	mvn.w	r8, r8, lsl #9
 8000510:	f8ca 8030 	str.w	r8, [sl, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 8000514:	f8da 8050 	ldr.w	r8, [sl, #80]	; 0x50
 8000518:	ea6f 2858 	mvn.w	r8, r8, lsr #9
 800051c:	ea6f 2848 	mvn.w	r8, r8, lsl #9
 8000520:	f8ca 8050 	str.w	r8, [sl, #80]	; 0x50

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000524:	f5aa 3a9b 	sub.w	sl, sl, #79360	; 0x13600
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000528:	f46f 48a8 	mvn.w	r8, #21504	; 0x5400
  gpiop->PUPDR   = config->pupdr;
 800052c:	f5aa 7ad6 	sub.w	sl, sl, #428	; 0x1ac
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000530:	f8cc 3004 	str.w	r3, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000534:	f8cc 8008 	str.w	r8, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
 8000538:	f8cc a00c 	str.w	sl, [ip, #12]
  gpiop->ODR     = config->odr;
 800053c:	f64f 78ff 	movw	r8, #65535	; 0xffff
  gpiop->AFRL    = config->afrl;
 8000540:	f8df a290 	ldr.w	sl, [pc, #656]	; 80007d4 <main+0x384>
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8000544:	f8cc 8014 	str.w	r8, [ip, #20]
  gpiop->AFRL    = config->afrl;
 8000548:	f8cc a020 	str.w	sl, [ip, #32]
  gpiop->AFRH    = config->afrh;
 800054c:	f8df a288 	ldr.w	sl, [pc, #648]	; 80007d8 <main+0x388>
 8000550:	f8cc a024 	str.w	sl, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000554:	f10a 5a2a 	add.w	sl, sl, #713031680	; 0x2a800000
 8000558:	f50a 1ab0 	add.w	sl, sl, #1441792	; 0x160000
 800055c:	f8cc a000 	str.w	sl, [ip]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000560:	f44f 7c10 	mov.w	ip, #576	; 0x240
 8000564:	f8ce c004 	str.w	ip, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000568:	f8df a270 	ldr.w	sl, [pc, #624]	; 80007dc <main+0x38c>
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 800056c:	f8ce 9008 	str.w	r9, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8000570:	f04f 6c80 	mov.w	ip, #67108864	; 0x4000000

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000574:	f8ce a00c 	str.w	sl, [lr, #12]
  gpiop->ODR     = config->odr;
 8000578:	f8ce 8014 	str.w	r8, [lr, #20]
  gpiop->AFRL    = config->afrl;
 800057c:	f8ce c020 	str.w	ip, [lr, #32]
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000580:	f8df c25c 	ldr.w	ip, [pc, #604]	; 80007e0 <main+0x390>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000584:	f8df a25c 	ldr.w	sl, [pc, #604]	; 80007e4 <main+0x394>
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8000588:	2240      	movs	r2, #64	; 0x40
 800058a:	f8ce 2024 	str.w	r2, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800058e:	f8ce c000 	str.w	ip, [lr]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000592:	f10c 4caa 	add.w	ip, ip, #1426063360	; 0x55000000
 8000596:	f5ac 0c43 	sub.w	ip, ip, #12779520	; 0xc30000
 800059a:	f6ac 3c2c 	subw	ip, ip, #2860	; 0xb2c
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800059e:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80005a0:	f8c0 9008 	str.w	r9, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 80005a4:	f8c0 c00c 	str.w	ip, [r0, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 80005a8:	f04f 4cc0 	mov.w	ip, #1610612736	; 0x60000000
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 80005ac:	f8c0 8014 	str.w	r8, [r0, #20]
  gpiop->AFRL    = config->afrl;
 80005b0:	f8c0 c020 	str.w	ip, [r0, #32]
  gpiop->AFRH    = config->afrh;
 80005b4:	f8df c230 	ldr.w	ip, [pc, #560]	; 80007e8 <main+0x398>
 80005b8:	f8c0 c024 	str.w	ip, [r0, #36]	; 0x24
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80005bc:	f5a6 46b0 	sub.w	r6, r6, #22528	; 0x5800
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80005c0:	f8df c228 	ldr.w	ip, [pc, #552]	; 80007ec <main+0x39c>
 80005c4:	f8c0 c000 	str.w	ip, [r0]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80005c8:	f8df c224 	ldr.w	ip, [pc, #548]	; 80007f0 <main+0x3a0>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80005cc:	4a79      	ldr	r2, [pc, #484]	; (80007b4 <main+0x364>)
 80005ce:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80005d0:	f8c6 9008 	str.w	r9, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 80005d4:	f8c6 c00c 	str.w	ip, [r6, #12]
  gpiop->ODR     = config->odr;
 80005d8:	f640 7cff 	movw	ip, #4095	; 0xfff
 80005dc:	f8c6 c014 	str.w	ip, [r6, #20]
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80005e0:	2040      	movs	r0, #64	; 0x40
 80005e2:	f8df c210 	ldr.w	ip, [pc, #528]	; 80007f4 <main+0x3a4>

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 80005e6:	6233      	str	r3, [r6, #32]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80005e8:	f50e 5e80 	add.w	lr, lr, #4096	; 0x1000
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 80005ec:	6273      	str	r3, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80005ee:	f8c6 c000 	str.w	ip, [r6]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80005f2:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80005f4:	f8c2 9008 	str.w	r9, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 80005f8:	60d3      	str	r3, [r2, #12]
  gpiop->ODR     = config->odr;
 80005fa:	f8c2 8014 	str.w	r8, [r2, #20]
  gpiop->AFRL    = config->afrl;
 80005fe:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8000600:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000602:	6010      	str	r0, [r2, #0]
#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 8000604:	4a63      	ldr	r2, [pc, #396]	; (8000794 <main+0x344>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000606:	f8ce 3004 	str.w	r3, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800060a:	f8ce 9008 	str.w	r9, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
 800060e:	f8ce 300c 	str.w	r3, [lr, #12]
  gpiop->ODR     = config->odr;
 8000612:	f8ce 8014 	str.w	r8, [lr, #20]
  gpiop->AFRL    = config->afrl;
 8000616:	f8ce 3020 	str.w	r3, [lr, #32]
  gpiop->AFRH    = config->afrh;
 800061a:	f8ce 3024 	str.w	r3, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800061e:	f8ce 3000 	str.w	r3, [lr]
 8000622:	f102 0e48 	add.w	lr, r2, #72	; 0x48
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000626:	4a64      	ldr	r2, [pc, #400]	; (80007b8 <main+0x368>)
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
 8000628:	f8df c1cc 	ldr.w	ip, [pc, #460]	; 80007f8 <main+0x3a8>
 800062c:	6053      	str	r3, [r2, #4]
 800062e:	f506 56a0 	add.w	r6, r6, #5120	; 0x1400
  gpiop->OSPEEDR = config->ospeedr;
 8000632:	f8c2 9008 	str.w	r9, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8000636:	60d3      	str	r3, [r2, #12]
  gpiop->ODR     = config->odr;
 8000638:	f8c2 8014 	str.w	r8, [r2, #20]
  gpiop->AFRL    = config->afrl;
 800063c:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 800063e:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000640:	6013      	str	r3, [r2, #0]
void spi_lld_init(void) {

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 8000642:	f1ae 0248 	sub.w	r2, lr, #72	; 0x48
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000646:	f8ca 3004 	str.w	r3, [sl, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800064a:	f105 000c 	add.w	r0, r5, #12
  gpiop->OSPEEDR = config->ospeedr;
 800064e:	f8ca 9008 	str.w	r9, [sl, #8]
  gpiop->PUPDR   = config->pupdr;
 8000652:	f8ca 300c 	str.w	r3, [sl, #12]
  gpiop->ODR     = config->odr;
 8000656:	f8ca 8014 	str.w	r8, [sl, #20]
  gpiop->AFRL    = config->afrl;
 800065a:	f8ca 3020 	str.w	r3, [sl, #32]
  gpiop->AFRH    = config->afrh;
 800065e:	f8ca 3024 	str.w	r3, [sl, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000662:	f8ca 3000 	str.w	r3, [sl]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000666:	6073      	str	r3, [r6, #4]
 */
void spi_lld_init(void) {

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
 8000668:	f5aa 4a6c 	sub.w	sl, sl, #60416	; 0xec00
  gpiop->OSPEEDR = config->ospeedr;
 800066c:	f8c6 9008 	str.w	r9, [r6, #8]
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 8000670:	f10e 0918 	add.w	r9, lr, #24
  gpiop->PUPDR   = config->pupdr;
 8000674:	60f3      	str	r3, [r6, #12]
  gpiop->ODR     = config->odr;
 8000676:	f8c6 8014 	str.w	r8, [r6, #20]
  gpiop->AFRL    = config->afrl;
 800067a:	6233      	str	r3, [r6, #32]
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 800067c:	f102 0884 	add.w	r8, r2, #132	; 0x84
  i2cp->config = NULL;
 8000680:	606b      	str	r3, [r5, #4]
  gpiop->AFRH    = config->afrh;
 8000682:	6273      	str	r3, [r6, #36]	; 0x24
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8000684:	616b      	str	r3, [r5, #20]
  gpiop->MODER   = config->moder;
 8000686:	6033      	str	r3, [r6, #0]
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 8000688:	4e4c      	ldr	r6, [pc, #304]	; (80007bc <main+0x36c>)
 800068a:	f8c5 c034 	str.w	ip, [r5, #52]	; 0x34
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 800068e:	f8c5 e030 	str.w	lr, [r5, #48]	; 0x30
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 8000692:	f8df c168 	ldr.w	ip, [pc, #360]	; 80007fc <main+0x3ac>
 */
void spi_lld_init(void) {

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
 8000696:	f8cb a01c 	str.w	sl, [fp, #28]
 800069a:	f10b 0e0c 	add.w	lr, fp, #12
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
 800069e:	f8cb 9020 	str.w	r9, [fp, #32]
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
 80006a2:	f8cb 8024 	str.w	r8, [fp, #36]	; 0x24
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 80006a6:	f102 0924 	add.w	r9, r2, #36	; 0x24
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 80006aa:	f102 0830 	add.w	r8, r2, #48	; 0x30
#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
  SPID1.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI1_RX_DMA_STREAM);
  SPID1.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI1_TX_DMA_STREAM);
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_CHANNEL) |
 80006ae:	f8cb 6028 	str.w	r6, [fp, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_CHANNEL) |
 80006b2:	f8cb c02c 	str.w	ip, [fp, #44]	; 0x2c
 80006b6:	f107 060c 	add.w	r6, r7, #12
 80006ba:	f8cb e00c 	str.w	lr, [fp, #12]
  tqp->prev = (thread_t *)tqp;
 80006be:	f8cb e010 	str.w	lr, [fp, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80006c2:	60e8      	str	r0, [r5, #12]
  tqp->prev = (thread_t *)tqp;
 80006c4:	6128      	str	r0, [r5, #16]
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
 80006c6:	f5aa 4a78 	sub.w	sl, sl, #63488	; 0xf800
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 80006ca:	2001      	movs	r0, #1
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 80006cc:	f8df c130 	ldr.w	ip, [pc, #304]	; 8000800 <main+0x3b0>
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 80006d0:	f8df e130 	ldr.w	lr, [pc, #304]	; 8000804 <main+0x3b4>
  spip->config = NULL;
 80006d4:	f8cb 3004 	str.w	r3, [fp, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 80006d8:	f8cb 3008 	str.w	r3, [fp, #8]
 80006dc:	f8cb 3014 	str.w	r3, [fp, #20]
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
  spip->config = NULL;
 80006e0:	607b      	str	r3, [r7, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 80006e2:	60bb      	str	r3, [r7, #8]
 80006e4:	617b      	str	r3, [r7, #20]
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
 80006e6:	f8c7 a01c 	str.w	sl, [r7, #28]
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 80006ea:	f8c7 9020 	str.w	r9, [r7, #32]
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 80006ee:	f8c7 8024 	str.w	r8, [r7, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80006f2:	60fe      	str	r6, [r7, #12]
  tqp->prev = (thread_t *)tqp;
 80006f4:	613e      	str	r6, [r7, #16]
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
 80006f6:	61eb      	str	r3, [r5, #28]
  I2CD1.i2c    = I2C1;
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 80006f8:	62ea      	str	r2, [r5, #44]	; 0x2c
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
 80006fa:	f88b 0000 	strb.w	r0, [fp]
 80006fe:	7038      	strb	r0, [r7, #0]

#if STM32_SPI_USE_SPI3
  spiObjectInit(&SPID3);
  SPID3.spi       = SPI3;
  SPID3.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI3_RX_DMA_STREAM);
  SPID3.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI3_TX_DMA_STREAM);
 8000700:	f102 0b54 	add.w	fp, r2, #84	; 0x54
  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;
 8000704:	f8df 8100 	ldr.w	r8, [pc, #256]	; 8000808 <main+0x3b8>
#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 8000708:	f8c7 c028 	str.w	ip, [r7, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800070c:	f101 060c 	add.w	r6, r1, #12
 8000710:	7028      	strb	r0, [r5, #0]
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI3
  spiObjectInit(&SPID3);
  SPID3.spi       = SPI3;
 8000712:	f50a 6a80 	add.w	sl, sl, #1024	; 0x400
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 8000716:	f8c7 e02c 	str.w	lr, [r7, #44]	; 0x2c

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
 800071a:	f04f 49a0 	mov.w	r9, #1342177280	; 0x50000000
  USBD1.otgparams = &fsparams;

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 800071e:	f104 0770 	add.w	r7, r4, #112	; 0x70
  spip->config = NULL;
 8000722:	604b      	str	r3, [r1, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 8000724:	608b      	str	r3, [r1, #8]
 8000726:	614b      	str	r3, [r1, #20]
#endif

#if STM32_SPI_USE_SPI3
  spiObjectInit(&SPID3);
  SPID3.spi       = SPI3;
  SPID3.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI3_RX_DMA_STREAM);
 8000728:	620a      	str	r2, [r1, #32]
  usbp->config       = NULL;
 800072a:	6063      	str	r3, [r4, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 800072c:	61e3      	str	r3, [r4, #28]
    usbp->out_params[i] = NULL;
 800072e:	62a3      	str	r3, [r4, #40]	; 0x28
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8000730:	6223      	str	r3, [r4, #32]
    usbp->out_params[i] = NULL;
 8000732:	62e3      	str	r3, [r4, #44]	; 0x2c
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 8000734:	6263      	str	r3, [r4, #36]	; 0x24
    usbp->out_params[i] = NULL;
 8000736:	6323      	str	r3, [r4, #48]	; 0x30
  }
  usbp->transmitting = 0;
 8000738:	8123      	strh	r3, [r4, #8]
  usbp->receiving    = 0;
 800073a:	8163      	strh	r3, [r4, #10]
void usb_lld_init(void) {

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
 800073c:	6663      	str	r3, [r4, #100]	; 0x64
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 800073e:	66a3      	str	r3, [r4, #104]	; 0x68
  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;
 8000740:	f8c4 8058 	str.w	r8, [r4, #88]	; 0x58
  SPID3.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI3_TX_DMA_STREAM);
  SPID3.rxdmamode = STM32_DMA_CR_CHSEL(SPI3_RX_DMA_CHANNEL) |
 8000744:	f8c1 c028 	str.w	ip, [r1, #40]	; 0x28
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
 8000748:	7008      	strb	r0, [r1, #0]
                    STM32_DMA_CR_PL(STM32_SPI_SPI3_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID3.txdmamode = STM32_DMA_CR_CHSEL(SPI3_TX_DMA_CHANNEL) |
 800074a:	f8c1 e02c 	str.w	lr, [r1, #44]	; 0x2c

#if STM32_SPI_USE_SPI3
  spiObjectInit(&SPID3);
  SPID3.spi       = SPI3;
  SPID3.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI3_RX_DMA_STREAM);
  SPID3.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI3_TX_DMA_STREAM);
 800074e:	f8c1 b024 	str.w	fp, [r1, #36]	; 0x24
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI3
  spiObjectInit(&SPID3);
  SPID3.spi       = SPI3;
 8000752:	f8c1 a01c 	str.w	sl, [r1, #28]
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 8000756:	7020      	strb	r0, [r4, #0]

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
 8000758:	f8c4 9054 	str.w	r9, [r4, #84]	; 0x54
 800075c:	60ce      	str	r6, [r1, #12]
  tqp->prev = (thread_t *)tqp;
 800075e:	610e      	str	r6, [r1, #16]
  USBD1.otgparams = &fsparams;

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 8000760:	463b      	mov	r3, r7
 8000762:	f504 7810 	add.w	r8, r4, #576	; 0x240
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 8000766:	2255      	movs	r2, #85	; 0x55
 8000768:	f803 2b01 	strb.w	r2, [r3], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 800076c:	4543      	cmp	r3, r8
 800076e:	d3fb      	bcc.n	8000768 <main+0x318>

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8000770:	4a05      	ldr	r2, [pc, #20]	; (8000788 <main+0x338>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000772:	4e13      	ldr	r6, [pc, #76]	; (80007c0 <main+0x370>)
 8000774:	6c13      	ldr	r3, [r2, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8000776:	f8df a094 	ldr.w	sl, [pc, #148]	; 800080c <main+0x3bc>
  tqp->prev = (thread_t *)tqp;
 800077a:	6076      	str	r6, [r6, #4]

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 800077c:	f043 0301 	orr.w	r3, r3, #1
 8000780:	6413      	str	r3, [r2, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8000782:	f8da 2008 	ldr.w	r2, [sl, #8]
 8000786:	e043      	b.n	8000810 <main+0x3c0>
 8000788:	40023800 	.word	0x40023800
 800078c:	40007000 	.word	0x40007000
 8000790:	20001c28 	.word	0x20001c28
 8000794:	08004be8 	.word	0x08004be8
 8000798:	20001ba8 	.word	0x20001ba8
 800079c:	40026400 	.word	0x40026400
 80007a0:	40020800 	.word	0x40020800
 80007a4:	20001c2c 	.word	0x20001c2c
 80007a8:	20000858 	.word	0x20000858
 80007ac:	200010e0 	.word	0x200010e0
 80007b0:	20000888 	.word	0x20000888
 80007b4:	40021000 	.word	0x40021000
 80007b8:	40021800 	.word	0x40021800
 80007bc:	06010016 	.word	0x06010016
 80007c0:	20001320 	.word	0x20001320
 80007c4:	40026000 	.word	0x40026000
 80007c8:	40020000 	.word	0x40020000
 80007cc:	40020400 	.word	0x40020400
 80007d0:	20000828 	.word	0x20000828
 80007d4:	55560000 	.word	0x55560000
 80007d8:	000aaa00 	.word	0x000aaa00
 80007dc:	55514515 	.word	0x55514515
 80007e0:	00082080 	.word	0x00082080
 80007e4:	40021c00 	.word	0x40021c00
 80007e8:	00060600 	.word	0x00060600
 80007ec:	02208001 	.word	0x02208001
 80007f0:	00555055 	.word	0x00555055
 80007f4:	55000100 	.word	0x55000100
 80007f8:	40005400 	.word	0x40005400
 80007fc:	06010046 	.word	0x06010046
 8000800:	00010016 	.word	0x00010016
 8000804:	00010046 	.word	0x00010046
 8000808:	08004cf4 	.word	0x08004cf4
 800080c:	e0042000 	.word	0xe0042000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000810:	49ca      	ldr	r1, [pc, #808]	; (8000b3c <main+0x6ec>)
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8000812:	6136      	str	r6, [r6, #16]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8000814:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8000818:	f042 0e01 	orr.w	lr, r2, #1

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800081c:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8000820:	f242 00cf 	movw	r0, #8399	; 0x20cf

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8000824:	f8ca e008 	str.w	lr, [sl, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 8000828:	2200      	movs	r2, #0

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800082a:	6298      	str	r0, [r3, #40]	; 0x28
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 800082c:	f106 0940 	add.w	r9, r6, #64	; 0x40
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8000830:	f8c3 c02c 	str.w	ip, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8000834:	f04f 0a01 	mov.w	sl, #1
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
 8000838:	f8c6 c024 	str.w	ip, [r6, #36]	; 0x24
 800083c:	f04f 0e80 	mov.w	lr, #128	; 0x80
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000840:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8000844:	f106 0c1c 	add.w	ip, r6, #28
 * @note    Internal use only.
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
 8000848:	f04f 0b0f 	mov.w	fp, #15
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 800084c:	f8c6 903c 	str.w	r9, [r6, #60]	; 0x3c
  ch.rlist.older = (thread_t *)&ch.rlist;
 8000850:	6176      	str	r6, [r6, #20]
 * @note    Internal use only.
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
 8000852:	f8a6 b038 	strh.w	fp, [r6, #56]	; 0x38
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8000856:	4691      	mov	r9, r2
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 8000858:	619a      	str	r2, [r3, #24]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 800085a:	60b2      	str	r2, [r6, #8]
  STM32_ST_TIM->CCR[0] = 0;
 800085c:	635a      	str	r2, [r3, #52]	; 0x34
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 800085e:	62b2      	str	r2, [r6, #40]	; 0x28
  STM32_ST_TIM->DIER   = 0;
 8000860:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8000862:	605a      	str	r2, [r3, #4]
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 8000864:	f8a6 e03a 	strh.w	lr, [r6, #58]	; 0x3a
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8000868:	f8c3 a014 	str.w	sl, [r3, #20]
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 800086c:	f8c6 c01c 	str.w	ip, [r6, #28]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8000870:	f8c3 a000 	str.w	sl, [r3]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8000874:	f8c6 c020 	str.w	ip, [r6, #32]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000878:	f881 e31c 	strb.w	lr, [r1, #796]	; 0x31c
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800087c:	f8c1 0180 	str.w	r0, [r1, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000880:	6008      	str	r0, [r1, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000882:	6036      	str	r6, [r6, #0]
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8000884:	f109 0901 	add.w	r9, r9, #1
 8000888:	eb06 1309 	add.w	r3, r6, r9, lsl #4
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 800088c:	f1b9 0f80 	cmp.w	r9, #128	; 0x80
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8000890:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
 8000894:	49aa      	ldr	r1, [pc, #680]	; (8000b40 <main+0x6f0>)
 8000896:	f36f 0202 	bfc	r2, #0, #3
 800089a:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 800089e:	d1f1      	bne.n	8000884 <main+0x434>
  _scheduler_init();
  _vt_init();
  _trace_init();

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 80008a0:	f04f 0a00 	mov.w	sl, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 80008a4:	f04f 3eff 	mov.w	lr, #4294967295	; 0xffffffff
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 80008a8:	2200      	movs	r2, #0
 80008aa:	2300      	movs	r3, #0
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 80008ac:	a806      	add	r0, sp, #24
 80008ae:	f8c1 a030 	str.w	sl, [r1, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
 80008b2:	f8c1 a034 	str.w	sl, [r1, #52]	; 0x34
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 80008b6:	f8c1 a884 	str.w	sl, [r1, #2180]	; 0x884

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 80008ba:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 80008be:	9102      	str	r1, [sp, #8]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 80008c0:	f8cd e018 	str.w	lr, [sp, #24]
  tmp->worst      = (rtcnt_t)0;
 80008c4:	f8cd a01c 	str.w	sl, [sp, #28]
  tmp->last       = (rtcnt_t)0;
 80008c8:	f8cd a020 	str.w	sl, [sp, #32]
  tmp->n          = (ucnt_t)0;
 80008cc:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 80008d0:	f003 fdee 	bl	80044b0 <chTMStartMeasurementX.constprop.48>
  chTMStopMeasurementX(&tm);
 80008d4:	a806      	add	r0, sp, #24
 80008d6:	f002 f90b 	bl	8002af0 <chTMStopMeasurementX>
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 80008da:	4b9a      	ldr	r3, [pc, #616]	; (8000b44 <main+0x6f4>)
 80008dc:	489a      	ldr	r0, [pc, #616]	; (8000b48 <main+0x6f8>)
 80008de:	6018      	str	r0, [r3, #0]
  endmem  = __heap_end__;
 80008e0:	f8df e2a8 	ldr.w	lr, [pc, #680]	; 8000b8c <main+0x73c>
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80008e4:	4899      	ldr	r0, [pc, #612]	; (8000b4c <main+0x6fc>)
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
 80008e6:	4a9a      	ldr	r2, [pc, #616]	; (8000b50 <main+0x700>)
 80008e8:	f8df c2a4 	ldr.w	ip, [pc, #676]	; 8000b90 <main+0x740>
 80008ec:	f8ce c000 	str.w	ip, [lr]
 80008f0:	4b98      	ldr	r3, [pc, #608]	; (8000b54 <main+0x704>)
 80008f2:	f8d0 c00c 	ldr.w	ip, [r0, #12]
 80008f6:	6013      	str	r3, [r2, #0]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 80008f8:	f8df e298 	ldr.w	lr, [pc, #664]	; 8000b94 <main+0x744>
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80008fc:	9902      	ldr	r1, [sp, #8]
 80008fe:	f8c2 a018 	str.w	sl, [r2, #24]
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000902:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8000906:	ea0c 0303 	and.w	r3, ip, r3
  reg_value  =  (reg_value                                   |
 800090a:	ea43 0e0e 	orr.w	lr, r3, lr
 800090e:	f102 0310 	add.w	r3, r2, #16
 8000912:	f8d1 b014 	ldr.w	fp, [r1, #20]
 8000916:	6113      	str	r3, [r2, #16]
  tqp->prev = (thread_t *)tqp;
 8000918:	6153      	str	r3, [r2, #20]
  ch.tm.offset = tm.last;
 800091a:	9b08      	ldr	r3, [sp, #32]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 800091c:	f8c1 9848 	str.w	r9, [r1, #2120]	; 0x848
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000920:	f8c1 987c 	str.w	r9, [r1, #2172]	; 0x87c
 8000924:	f8c1 3884 	str.w	r3, [r1, #2180]	; 0x884
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000928:	f04f 0c01 	mov.w	ip, #1
  tp->name      = name;
  REG_INSERT(tp);
 800092c:	f501 6904 	add.w	r9, r1, #2112	; 0x840
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8000930:	4b89      	ldr	r3, [pc, #548]	; (8000b58 <main+0x708>)
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000932:	f881 a861 	strb.w	sl, [r1, #2145]	; 0x861
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000936:	f8c1 a874 	str.w	sl, [r1, #2164]	; 0x874
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800093a:	f881 c862 	strb.w	ip, [r1, #2146]	; 0x862
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 800093e:	f8c1 a878 	str.w	sl, [r1, #2168]	; 0x878
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000942:	f8c1 b854 	str.w	fp, [r1, #2132]	; 0x854
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8000946:	f8c1 3858 	str.w	r3, [r1, #2136]	; 0x858
  REG_INSERT(tp);
 800094a:	f8c1 1850 	str.w	r1, [r1, #2128]	; 0x850
 800094e:	f8cb 9010 	str.w	r9, [fp, #16]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8000952:	f8df b244 	ldr.w	fp, [pc, #580]	; 8000b98 <main+0x748>
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000956:	f8c0 e00c 	str.w	lr, [r0, #12]
 800095a:	f8db 300c 	ldr.w	r3, [fp, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800095e:	f8df e23c 	ldr.w	lr, [pc, #572]	; 8000b9c <main+0x74c>
  H_NEXT(&default_heap.header) = NULL;
 8000962:	f8c2 a008 	str.w	sl, [r2, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8000966:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800096a:	f8cb 300c 	str.w	r3, [fp, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800096e:	f8de 3000 	ldr.w	r3, [lr]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 8000972:	f8df b22c 	ldr.w	fp, [pc, #556]	; 8000ba0 <main+0x750>
  H_PAGES(&default_heap.header) = 0;
 8000976:	f8c2 a00c 	str.w	sl, [r2, #12]
 800097a:	ea43 030c 	orr.w	r3, r3, ip
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800097e:	f601 026c 	addw	r2, r1, #2156	; 0x86c
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000982:	f601 0a68 	addw	sl, r1, #2152	; 0x868
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000986:	f8c1 286c 	str.w	r2, [r1, #2156]	; 0x86c
  tqp->prev = (thread_t *)tqp;
 800098a:	f8c1 2870 	str.w	r2, [r1, #2160]	; 0x870
 800098e:	f8c1 9014 	str.w	r9, [r1, #20]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8000992:	f8c1 9018 	str.w	r9, [r1, #24]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8000996:	f881 c860 	strb.w	ip, [r1, #2144]	; 0x860
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 800099a:	f8c1 a868 	str.w	sl, [r1, #2152]	; 0x868
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 800099e:	f8c1 b85c 	str.w	fp, [r1, #2140]	; 0x85c
 80009a2:	f8ce 3000 	str.w	r3, [lr]
 *
 * @notapi
 */
void _dbg_check_enable(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80009a6:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80009a8:	f04f 0e10 	mov.w	lr, #16
 80009ac:	2220      	movs	r2, #32
 80009ae:	f880 e01f 	strb.w	lr, [r0, #31]
 80009b2:	f880 2022 	strb.w	r2, [r0, #34]	; 0x22
 80009b6:	b90b      	cbnz	r3, 80009bc <main+0x56c>
 80009b8:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 80009ba:	b113      	cbz	r3, 80009c2 <main+0x572>
    chSysHalt("SV#3");
 80009bc:	4867      	ldr	r0, [pc, #412]	; (8000b5c <main+0x70c>)
 80009be:	f002 f92f 	bl	8002c20 <chSysHalt>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80009c2:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80009c6:	b662      	cpsie	i
 */
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
  thread_t *tp;

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 80009c8:	4865      	ldr	r0, [pc, #404]	; (8000b60 <main+0x710>)
 80009ca:	f002 fd29 	bl	8003420 <chRegFindThreadByWorkingArea>
 80009ce:	b110      	cbz	r0, 80009d6 <main+0x586>
 80009d0:	4864      	ldr	r0, [pc, #400]	; (8000b64 <main+0x714>)
 80009d2:	f002 f925 	bl	8002c20 <chSysHalt>
 80009d6:	4962      	ldr	r1, [pc, #392]	; (8000b60 <main+0x710>)
 80009d8:	4603      	mov	r3, r0
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 80009da:	2255      	movs	r2, #85	; 0x55
 80009dc:	54ca      	strb	r2, [r1, r3]
 80009de:	3301      	adds	r3, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80009e0:	f5b3 7fb0 	cmp.w	r3, #352	; 0x160
 80009e4:	d1fa      	bne.n	80009dc <main+0x58c>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80009e6:	f04f 0b20 	mov.w	fp, #32
 80009ea:	f38b 8811 	msr	BASEPRI, fp
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80009ee:	f002 fc0f 	bl	8003210 <_dbg_check_lock>
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {

  sdup->vmt = &vmt;
 80009f2:	f8df 91b0 	ldr.w	r9, [pc, #432]	; 8000ba4 <main+0x754>
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
 80009f6:	485c      	ldr	r0, [pc, #368]	; (8000b68 <main+0x718>)
 80009f8:	f002 f97a 	bl	8002cf0 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 80009fc:	f003 fd18 	bl	8004430 <chSchWakeupS.constprop.51>
  chSysUnlock();
 8000a00:	f002 fbee 	bl	80031e0 <chSysUnlock.lto_priv.59>
 8000a04:	4649      	mov	r1, r9
	* - Kernel initialization, the main() function becomes a thread and the
	*   RTOS is active.
	*/
	halInit();
	chSysInit();
	palSetLine(LINE_LED3);
 8000a06:	f8df e1a0 	ldr.w	lr, [pc, #416]	; 8000ba8 <main+0x758>
 8000a0a:	4858      	ldr	r0, [pc, #352]	; (8000b6c <main+0x71c>)
  ibqp->bn        = n;
  ibqp->buffers   = bp;
  ibqp->ptr       = NULL;
  ibqp->top       = NULL;
  ibqp->notify    = infy;
  ibqp->link      = link;
 8000a0c:	f8c9 9040 	str.w	r9, [r9, #64]	; 0x40
 8000a10:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
 8000a14:	f8ae c018 	strh.w	ip, [lr, #24]
 8000a18:	f841 0b04 	str.w	r0, [r1], #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000a1c:	f109 0c0c 	add.w	ip, r9, #12
  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->suspended = suspended;
  obqp->bcounter  = n;
  obqp->brdptr    = bp;
  obqp->bwrptr    = bp;
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8000a20:	f209 4e8c 	addw	lr, r9, #1164	; 0x48c
  ibqp->bsize     = size + sizeof (size_t);
  ibqp->bn        = n;
  ibqp->buffers   = bp;
  ibqp->ptr       = NULL;
  ibqp->top       = NULL;
  ibqp->notify    = infy;
 8000a24:	4a52      	ldr	r2, [pc, #328]	; (8000b70 <main+0x720>)
  obqp->bsize     = size + sizeof (size_t);
  obqp->bn        = n;
  obqp->buffers   = bp;
  obqp->ptr       = NULL;
  obqp->top       = NULL;
  obqp->notify    = onfy;
 8000a26:	4b53      	ldr	r3, [pc, #332]	; (8000b74 <main+0x724>)
  ibqp->bsize     = size + sizeof (size_t);
  ibqp->bn        = n;
  ibqp->buffers   = bp;
  ibqp->ptr       = NULL;
  ibqp->top       = NULL;
  ibqp->notify    = infy;
 8000a28:	f8c9 203c 	str.w	r2, [r9, #60]	; 0x3c
  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->suspended = suspended;
  ibqp->bcounter  = 0;
  ibqp->brdptr    = bp;
 8000a2c:	f109 007c 	add.w	r0, r9, #124	; 0x7c
  ibqp->bwrptr    = bp;
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8000a30:	f509 7221 	add.w	r2, r9, #644	; 0x284
  ibqp->bsize     = size + sizeof (size_t);
  ibqp->bn        = n;
 8000a34:	f04f 0a02 	mov.w	sl, #2
  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->suspended = suspended;
  obqp->bcounter  = n;
  obqp->brdptr    = bp;
  obqp->bwrptr    = bp;
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8000a38:	f8c9 e05c 	str.w	lr, [r9, #92]	; 0x5c
  obqp->bsize     = size + sizeof (size_t);
  obqp->bn        = n;
  obqp->buffers   = bp;
  obqp->ptr       = NULL;
  obqp->top       = NULL;
  obqp->notify    = onfy;
 8000a3c:	f8c9 3074 	str.w	r3, [r9, #116]	; 0x74
 8000a40:	f109 0e44 	add.w	lr, r9, #68	; 0x44

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->suspended = suspended;
  ibqp->bcounter  = 0;
 8000a44:	2300      	movs	r3, #0
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8000a46:	f8c9 1004 	str.w	r1, [r9, #4]
 8000a4a:	f8c9 c00c 	str.w	ip, [r9, #12]
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
 8000a4e:	2101      	movs	r1, #1
  tqp->prev = (thread_t *)tqp;
 8000a50:	f8c9 c010 	str.w	ip, [r9, #16]
  ibqp->brdptr    = bp;
  ibqp->bwrptr    = bp;
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  ibqp->bsize     = size + sizeof (size_t);
 8000a54:	f44f 7c82 	mov.w	ip, #260	; 0x104

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->suspended = suspended;
  ibqp->bcounter  = 0;
 8000a58:	f8c9 3018 	str.w	r3, [r9, #24]
  obqp->bn        = n;
  obqp->buffers   = bp;
  obqp->ptr       = NULL;
  obqp->top       = NULL;
  obqp->notify    = onfy;
  obqp->link      = link;
 8000a5c:	f8c9 9078 	str.w	r9, [r9, #120]	; 0x78
  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->suspended = suspended;
  ibqp->bcounter  = 0;
  ibqp->brdptr    = bp;
 8000a60:	f8c9 0020 	str.w	r0, [r9, #32]
  ibqp->bwrptr    = bp;
 8000a64:	f8c9 001c 	str.w	r0, [r9, #28]
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  ibqp->bsize     = size + sizeof (size_t);
  ibqp->bn        = n;
  ibqp->buffers   = bp;
 8000a68:	f8c9 0030 	str.w	r0, [r9, #48]	; 0x30
  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->suspended = suspended;
  ibqp->bcounter  = 0;
  ibqp->brdptr    = bp;
  ibqp->bwrptr    = bp;
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
 8000a6c:	f8c9 2024 	str.w	r2, [r9, #36]	; 0x24
  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->suspended = suspended;
  obqp->bcounter  = n;
  obqp->brdptr    = bp;
 8000a70:	f8c9 2058 	str.w	r2, [r9, #88]	; 0x58
  obqp->bwrptr    = bp;
 8000a74:	f8c9 2054 	str.w	r2, [r9, #84]	; 0x54
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
  obqp->bsize     = size + sizeof (size_t);
  obqp->bn        = n;
  obqp->buffers   = bp;
 8000a78:	f8c9 2068 	str.w	r2, [r9, #104]	; 0x68
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000a7c:	f8c9 e044 	str.w	lr, [r9, #68]	; 0x44
  tqp->prev = (thread_t *)tqp;
 8000a80:	f8c9 e048 	str.w	lr, [r9, #72]	; 0x48
  ibqp->bwrptr    = bp;
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  ibqp->bsize     = size + sizeof (size_t);
  ibqp->bn        = n;
  ibqp->buffers   = bp;
  ibqp->ptr       = NULL;
 8000a84:	f8c9 3034 	str.w	r3, [r9, #52]	; 0x34
  ibqp->top       = NULL;
 8000a88:	f8c9 3038 	str.w	r3, [r9, #56]	; 0x38
  obqp->bwrptr    = bp;
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
  obqp->bsize     = size + sizeof (size_t);
  obqp->bn        = n;
  obqp->buffers   = bp;
  obqp->ptr       = NULL;
 8000a8c:	f8c9 306c 	str.w	r3, [r9, #108]	; 0x6c
  obqp->top       = NULL;
 8000a90:	f8c9 3070 	str.w	r3, [r9, #112]	; 0x70
 8000a94:	f889 1008 	strb.w	r1, [r9, #8]
                   size_t size, size_t n, bqnotify_t infy, void *link) {

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
  ibqp->suspended = suspended;
 8000a98:	f889 1014 	strb.w	r1, [r9, #20]
                   size_t size, size_t n, bqnotify_t onfy, void *link) {

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->suspended = suspended;
 8000a9c:	f889 104c 	strb.w	r1, [r9, #76]	; 0x4c
  ibqp->suspended = suspended;
  ibqp->bcounter  = 0;
  ibqp->brdptr    = bp;
  ibqp->bwrptr    = bp;
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  ibqp->bsize     = size + sizeof (size_t);
 8000aa0:	f8c9 c028 	str.w	ip, [r9, #40]	; 0x28
  obqp->suspended = suspended;
  obqp->bcounter  = n;
  obqp->brdptr    = bp;
  obqp->bwrptr    = bp;
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
  obqp->bsize     = size + sizeof (size_t);
 8000aa4:	f8c9 c060 	str.w	ip, [r9, #96]	; 0x60
  ibqp->bcounter  = 0;
  ibqp->brdptr    = bp;
  ibqp->bwrptr    = bp;
  ibqp->btop      = bp + ((size + sizeof (size_t)) * n);
  ibqp->bsize     = size + sizeof (size_t);
  ibqp->bn        = n;
 8000aa8:	f8c9 a02c 	str.w	sl, [r9, #44]	; 0x2c

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&obqp->waiting);
  obqp->suspended = suspended;
  obqp->bcounter  = n;
 8000aac:	f8c9 a050 	str.w	sl, [r9, #80]	; 0x50
  obqp->brdptr    = bp;
  obqp->bwrptr    = bp;
  obqp->btop      = bp + ((size + sizeof (size_t)) * n);
  obqp->bsize     = size + sizeof (size_t);
  obqp->bn        = n;
 8000ab0:	f8c9 a064 	str.w	sl, [r9, #100]	; 0x64
 8000ab4:	f38b 8811 	msr	BASEPRI, fp
 8000ab8:	f002 fbaa 	bl	8003210 <_dbg_check_lock>
  USBDriver *usbp = config->usbp;

  osalDbgCheck(sdup != NULL);

  osalSysLock();
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
 8000abc:	f899 3008 	ldrb.w	r3, [r9, #8]
 8000ac0:	3b01      	subs	r3, #1
 8000ac2:	2b01      	cmp	r3, #1
 8000ac4:	d902      	bls.n	8000acc <main+0x67c>
 8000ac6:	482c      	ldr	r0, [pc, #176]	; (8000b78 <main+0x728>)
 8000ac8:	f002 f8aa 	bl	8002c20 <chSysHalt>
  usbp->in_params[config->bulk_in - 1U]   = sdup;
  usbp->out_params[config->bulk_out - 1U] = sdup;
  if (config->int_in > 0U) {
    usbp->in_params[config->int_in - 1U]  = sdup;
  }
  sdup->config = config;
 8000acc:	4b2b      	ldr	r3, [pc, #172]	; (8000b7c <main+0x72c>)
 8000ace:	f8c9 348c 	str.w	r3, [r9, #1164]	; 0x48c
  osalDbgCheck(sdup != NULL);

  osalSysLock();
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 8000ad2:	f8c4 901c 	str.w	r9, [r4, #28]
  usbp->out_params[config->bulk_out - 1U] = sdup;
 8000ad6:	f8c4 9028 	str.w	r9, [r4, #40]	; 0x28
  if (config->int_in > 0U) {
    usbp->in_params[config->int_in - 1U]  = sdup;
 8000ada:	f8c4 9020 	str.w	r9, [r4, #32]
  }
  sdup->config = config;
  sdup->state = SDU_READY;
 8000ade:	f889 a008 	strb.w	sl, [r9, #8]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000ae2:	f002 fb6d 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000ae6:	6833      	ldr	r3, [r6, #0]
 8000ae8:	4a15      	ldr	r2, [pc, #84]	; (8000b40 <main+0x6f0>)
 8000aea:	42b3      	cmp	r3, r6
 8000aec:	d004      	beq.n	8000af8 <main+0x6a8>
 8000aee:	6992      	ldr	r2, [r2, #24]
 8000af0:	689b      	ldr	r3, [r3, #8]
 8000af2:	6892      	ldr	r2, [r2, #8]
 8000af4:	429a      	cmp	r2, r3
 8000af6:	d31d      	bcc.n	8000b34 <main+0x6e4>
 8000af8:	f04f 0b00 	mov.w	fp, #0
 8000afc:	f38b 8811 	msr	BASEPRI, fp
	/*
	* Activates the USB driver and then the USB bus pull-up on D+.
	* Note, a delay is inserted in order to not have to disconnect the cable
	* after a reset.
	*/
	usbDisconnectBus(serusbcfg.usbp);
 8000b00:	6d61      	ldr	r1, [r4, #84]	; 0x54
 8000b02:	4b1f      	ldr	r3, [pc, #124]	; (8000b80 <main+0x730>)
 8000b04:	6b8a      	ldr	r2, [r1, #56]	; 0x38
 8000b06:	9303      	str	r3, [sp, #12]
 8000b08:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 8000b0c:	638a      	str	r2, [r1, #56]	; 0x38
	chThdSleepMilliseconds(1500);
 8000b0e:	f643 2098 	movw	r0, #15000	; 0x3a98
 8000b12:	f002 fdad 	bl	8003670 <chThdSleep>
 8000b16:	2020      	movs	r0, #32
 8000b18:	f380 8811 	msr	BASEPRI, r0
 8000b1c:	9002      	str	r0, [sp, #8]
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000b1e:	f002 fb77 	bl	8003210 <_dbg_check_lock>
  unsigned i;

  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
 8000b22:	7821      	ldrb	r1, [r4, #0]
 8000b24:	9802      	ldr	r0, [sp, #8]
 8000b26:	9b03      	ldr	r3, [sp, #12]
 8000b28:	1e4a      	subs	r2, r1, #1
 8000b2a:	2a01      	cmp	r2, #1
 8000b2c:	d93e      	bls.n	8000bac <main+0x75c>
 8000b2e:	4815      	ldr	r0, [pc, #84]	; (8000b84 <main+0x734>)
 8000b30:	f002 f876 	bl	8002c20 <chSysHalt>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000b34:	4814      	ldr	r0, [pc, #80]	; (8000b88 <main+0x738>)
 8000b36:	f002 f873 	bl	8002c20 <chSysHalt>
 8000b3a:	bf00      	nop
 8000b3c:	e000e100 	.word	0xe000e100
 8000b40:	20001320 	.word	0x20001320
 8000b44:	20000d5c 	.word	0x20000d5c
 8000b48:	20001c68 	.word	0x20001c68
 8000b4c:	e000ed00 	.word	0xe000ed00
 8000b50:	20000808 	.word	0x20000808
 8000b54:	08001d81 	.word	0x08001d81
 8000b58:	08004cb8 	.word	0x08004cb8
 8000b5c:	08004cd0 	.word	0x08004cd0
 8000b60:	20000f38 	.word	0x20000f38
 8000b64:	08004d00 	.word	0x08004d00
 8000b68:	08004b90 	.word	0x08004b90
 8000b6c:	08004ba8 	.word	0x08004ba8
 8000b70:	080015e1 	.word	0x080015e1
 8000b74:	08001621 	.word	0x08001621
 8000b78:	08004d4c 	.word	0x08004d4c
 8000b7c:	08004be0 	.word	0x08004be0
 8000b80:	200010e0 	.word	0x200010e0
 8000b84:	08004bc8 	.word	0x08004bc8
 8000b88:	08004d2c 	.word	0x08004d2c
 8000b8c:	200008b8 	.word	0x200008b8
 8000b90:	20020000 	.word	0x20020000
 8000b94:	05fa0300 	.word	0x05fa0300
 8000b98:	e000edf0 	.word	0xe000edf0
 8000b9c:	e0001000 	.word	0xe0001000
 8000ba0:	20000400 	.word	0x20000400
 8000ba4:	200008cc 	.word	0x200008cc
 8000ba8:	40020c00 	.word	0x40020c00
                "invalid state");
  usbp->config = config;
 8000bac:	4abc      	ldr	r2, [pc, #752]	; (8000ea0 <main+0xa50>)
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 8000bae:	f8c3 b00c 	str.w	fp, [r3, #12]
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  if (usbp->state == USB_STOP) {
 8000bb2:	2901      	cmp	r1, #1
 8000bb4:	f8c3 b010 	str.w	fp, [r3, #16]
 8000bb8:	f8c3 b014 	str.w	fp, [r3, #20]
 8000bbc:	f8c3 b018 	str.w	fp, [r3, #24]
  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
 8000bc0:	605a      	str	r2, [r3, #4]
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 8000bc2:	f8d3 a054 	ldr.w	sl, [r3, #84]	; 0x54

  if (usbp->state == USB_STOP) {
 8000bc6:	d020      	beq.n	8000c0a <main+0x7ba>
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
  }
  usb_lld_start(usbp);
  usbp->state = USB_READY;
 8000bc8:	2302      	movs	r3, #2
 8000bca:	7023      	strb	r3, [r4, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000bcc:	f002 faf8 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000bd0:	6833      	ldr	r3, [r6, #0]
 8000bd2:	4ab4      	ldr	r2, [pc, #720]	; (8000ea4 <main+0xa54>)
 8000bd4:	42b3      	cmp	r3, r6
 8000bd6:	d005      	beq.n	8000be4 <main+0x794>
 8000bd8:	6992      	ldr	r2, [r2, #24]
 8000bda:	689b      	ldr	r3, [r3, #8]
 8000bdc:	6892      	ldr	r2, [r2, #8]
 8000bde:	429a      	cmp	r2, r3
 8000be0:	f0c0 80a4 	bcc.w	8000d2c <main+0x8dc>
 8000be4:	2300      	movs	r3, #0
 8000be6:	f383 8811 	msr	BASEPRI, r3
	usbStart(serusbcfg.usbp, &usbcfg);
	usbConnectBus(serusbcfg.usbp);
 8000bea:	6d61      	ldr	r1, [r4, #84]	; 0x54
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {

  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
 8000bec:	782a      	ldrb	r2, [r5, #0]
 8000bee:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 8000bf0:	1e50      	subs	r0, r2, #1
 8000bf2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8000bf6:	2801      	cmp	r0, #1
 8000bf8:	638b      	str	r3, [r1, #56]	; 0x38
 8000bfa:	f240 809a 	bls.w	8000d32 <main+0x8e2>
 8000bfe:	2a05      	cmp	r2, #5
 8000c00:	f000 8097 	beq.w	8000d32 <main+0x8e2>
 8000c04:	48a8      	ldr	r0, [pc, #672]	; (8000ea8 <main+0xa58>)
 8000c06:	f002 f80b 	bl	8002c20 <chSysHalt>
    /* Clock activation.*/

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(false);
 8000c0a:	4aa8      	ldr	r2, [pc, #672]	; (8000eac <main+0xa5c>)
 8000c0c:	9102      	str	r1, [sp, #8]
 8000c0e:	f8d2 c034 	ldr.w	ip, [r2, #52]	; 0x34

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000c12:	f8df e2d4 	ldr.w	lr, [pc, #724]	; 8000ee8 <main+0xa98>
 8000c16:	f04c 0c80 	orr.w	ip, ip, #128	; 0x80
 8000c1a:	f8c2 c034 	str.w	ip, [r2, #52]	; 0x34
      rccResetOTG_FS();
 8000c1e:	f8d2 c014 	ldr.w	ip, [r2, #20]
 8000c22:	f04c 0c80 	orr.w	ip, ip, #128	; 0x80
 8000c26:	f8c2 c014 	str.w	ip, [r2, #20]
 8000c2a:	f8c2 b014 	str.w	fp, [r2, #20]
 8000c2e:	22e0      	movs	r2, #224	; 0xe0
 8000c30:	f88e 2343 	strb.w	r2, [lr, #835]	; 0x343
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000c34:	2208      	movs	r2, #8
 8000c36:	f8ce 2188 	str.w	r2, [lr, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000c3a:	f8ce 2008 	str.w	r2, [lr, #8]
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);

      /* - Forced device mode.
         - USB turn-around time = TRDT_VALUE_FS.
         - Full Speed 1.1 PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8000c3e:	4a9c      	ldr	r2, [pc, #624]	; (8000eb0 <main+0xa60>)
 8000c40:	f8ca 200c 	str.w	r2, [sl, #12]
                      GUSBCFG_PHYSEL;

      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8000c44:	f8df e2a4 	ldr.w	lr, [pc, #676]	; 8000eec <main+0xa9c>
 8000c48:	f8ca e800 	str.w	lr, [sl, #2048]	; 0x800

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8000c4c:	f04f 0cc0 	mov.w	ip, #192	; 0xc0
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8000c50:	f44f 2250 	mov.w	r2, #851968	; 0xd0000
#endif
    }
#endif

    /* Clearing mask of TXFIFOs to be filled.*/
    usbp->txpending = 0;
 8000c54:	f8c3 b060 	str.w	fp, [r3, #96]	; 0x60

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 8000c58:	f8ca be00 	str.w	fp, [sl, #3584]	; 0xe00

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8000c5c:	f8ca c000 	str.w	ip, [sl]
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8000c60:	f8ca 2038 	str.w	r2, [sl, #56]	; 0x38
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
 8000c64:	f001 ffcc 	bl	8002c00 <chSysPolledDelayX>
  stm32_otg_t *otgp = usbp->otg;

  osalSysPolledDelayX(32);

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 8000c68:	9902      	ldr	r1, [sp, #8]
 8000c6a:	f8ca 1010 	str.w	r1, [sl, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 8000c6e:	f8da 3010 	ldr.w	r3, [sl, #16]
 8000c72:	07db      	lsls	r3, r3, #31
 8000c74:	d4fb      	bmi.n	8000c6e <main+0x81e>
 8000c76:	2012      	movs	r0, #18
 8000c78:	f001 ffc2 	bl	8002c00 <chSysPolledDelayX>
    ;

  osalSysPolledDelayX(18);

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8000c7c:	f8da 3010 	ldr.w	r3, [sl, #16]
 8000c80:	2b00      	cmp	r3, #0
 8000c82:	dafb      	bge.n	8000c7c <main+0x82c>

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000c84:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000c86:	f8d4 e054 	ldr.w	lr, [r4, #84]	; 0x54
 8000c8a:	f8d3 b008 	ldr.w	fp, [r3, #8]

    /* Soft core reset.*/
    otg_core_reset(usbp);

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 8000c8e:	2300      	movs	r3, #0

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000c90:	461a      	mov	r2, r3

    /* Soft core reset.*/
    otg_core_reset(usbp);

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 8000c92:	f8ca 3008 	str.w	r3, [sl, #8]
static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
    otgp->ie[i].DIEPCTL = 0;
 8000c96:	4619      	mov	r1, r3
    otgp->ie[i].DIEPTSIZ = 0;
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8000c98:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 8000c9c:	eb0e 1342 	add.w	r3, lr, r2, lsl #5

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000ca0:	3201      	adds	r2, #1
 8000ca2:	455a      	cmp	r2, fp
    otgp->ie[i].DIEPCTL = 0;
 8000ca4:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
 8000ca8:	f04f 0000 	mov.w	r0, #0
    otgp->ie[i].DIEPTSIZ = 0;
 8000cac:	f8c3 1910 	str.w	r1, [r3, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8000cb0:	f8c3 c908 	str.w	ip, [r3, #2312]	; 0x908

    otgp->oe[i].DOEPCTL = 0;
 8000cb4:	f8c3 1b00 	str.w	r1, [r3, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
 8000cb8:	f8c3 1b10 	str.w	r1, [r3, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8000cbc:	f8c3 cb08 	str.w	ip, [r3, #2824]	; 0xb08

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000cc0:	d9ec      	bls.n	8000c9c <main+0x84c>
    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
 8000cc2:	6863      	ldr	r3, [r4, #4]
 8000cc4:	68db      	ldr	r3, [r3, #12]

    otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8000cc6:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8000cca:	f8ce 281c 	str.w	r2, [lr, #2076]	; 0x81c
    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 8000cce:	f8ca 0810 	str.w	r0, [sl, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 8000cd2:	f8ca 0814 	str.w	r0, [sl, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8000cd6:	f8ca 081c 	str.w	r0, [sl, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 8000cda:	2b00      	cmp	r3, #0
 8000cdc:	f000 8268 	beq.w	80011b0 <main+0xd60>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8000ce0:	4b74      	ldr	r3, [pc, #464]	; (8000eb4 <main+0xa64>)
 8000ce2:	f8ca 3018 	str.w	r3, [sl, #24]
    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 8000ce6:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8000ce8:	f8df b204 	ldr.w	fp, [pc, #516]	; 8000ef0 <main+0xaa0>
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM |
                       GINTMSK_SOFM;

    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;
 8000cec:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000cf0:	f8ca 2014 	str.w	r2, [sl, #20]

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 8000cf4:	b99b      	cbnz	r3, 8000d1e <main+0x8ce>
      thread_descriptor_t usbpump_descriptor = {
 8000cf6:	4970      	ldr	r1, [pc, #448]	; (8000eb8 <main+0xa68>)
 8000cf8:	4b70      	ldr	r3, [pc, #448]	; (8000ebc <main+0xa6c>)
 8000cfa:	9106      	str	r1, [sp, #24]
 8000cfc:	2202      	movs	r2, #2
 *
 * @iclass
 */
thread_t *chThdCreateI(const thread_descriptor_t *tdp) {

  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8000cfe:	a806      	add	r0, sp, #24
 8000d00:	9209      	str	r2, [sp, #36]	; 0x24
 8000d02:	930a      	str	r3, [sp, #40]	; 0x28
 8000d04:	9707      	str	r7, [sp, #28]
 8000d06:	f8cd 8020 	str.w	r8, [sp, #32]
 8000d0a:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
 8000d0e:	f001 ffef 	bl	8002cf0 <chThdCreateSuspendedI>
 8000d12:	f002 f97d 	bl	8003010 <chSchReadyI>
        STM32_USB_OTG_THREAD_PRIO,
        usb_lld_pump,
        (void *)usbp
      };

      usbp->tr = chThdCreateI(&usbpump_descriptor);
 8000d16:	f8cb 0068 	str.w	r0, [fp, #104]	; 0x68
      chSchRescheduleS();
 8000d1a:	f002 f949 	bl	8002fb0 <chSchRescheduleS>
  }
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8000d1e:	f8da 3008 	ldr.w	r3, [sl, #8]
 8000d22:	f043 0301 	orr.w	r3, r3, #1
 8000d26:	f8ca 3008 	str.w	r3, [sl, #8]
 8000d2a:	e74d      	b.n	8000bc8 <main+0x778>
 8000d2c:	4864      	ldr	r0, [pc, #400]	; (8000ec0 <main+0xa70>)
 8000d2e:	f001 ff77 	bl	8002c20 <chSysHalt>
 8000d32:	2320      	movs	r3, #32
 8000d34:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000d38:	f002 fa6a 	bl	8003210 <_dbg_check_lock>
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8000d3c:	f895 8000 	ldrb.w	r8, [r5]
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 8000d40:	4b60      	ldr	r3, [pc, #384]	; (8000ec4 <main+0xa74>)
 8000d42:	606b      	str	r3, [r5, #4]
 8000d44:	f1b8 0f01 	cmp.w	r8, #1
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 8000d48:	6b6c      	ldr	r4, [r5, #52]	; 0x34
 8000d4a:	4f5f      	ldr	r7, [pc, #380]	; (8000ec8 <main+0xa78>)

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8000d4c:	f000 81e2 	beq.w	8001114 <main+0xcc4>
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8000d50:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 * @notapi
 */
static void i2c_lld_set_clock(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
 8000d52:	6868      	ldr	r0, [r5, #4]
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8000d54:	6b2b      	ldr	r3, [r5, #48]	; 0x30
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8000d56:	f8d1 c000 	ldr.w	ip, [r1]
 * @notapi
 */
static void i2c_lld_set_clock(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
 8000d5a:	6842      	ldr	r2, [r0, #4]
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8000d5c:	f8d3 a000 	ldr.w	sl, [r3]
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
  i2cdutycycle_t duty = i2cp->config->duty_cycle;

  osalDbgCheck((i2cp != NULL) &&
 8000d60:	f8df e190 	ldr.w	lr, [pc, #400]	; 8000ef4 <main+0xaa4>
 */
static void i2c_lld_set_clock(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
  i2cdutycycle_t duty = i2cp->config->duty_cycle;
 8000d64:	7a07      	ldrb	r7, [r0, #8]
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_set_clock(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 8000d66:	6b69      	ldr	r1, [r5, #52]	; 0x34
    }
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
 8000d68:	f104 0310 	add.w	r3, r4, #16
 8000d6c:	f8cc 3008 	str.w	r3, [ip, #8]
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
  i2cdutycycle_t duty = i2cp->config->duty_cycle;

  osalDbgCheck((i2cp != NULL) &&
 8000d70:	f102 3cff 	add.w	ip, r2, #4294967295	; 0xffffffff
#endif /* STM32_I2C_USE_I2C3 */
  }

  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);
 8000d74:	f8ca 3008 	str.w	r3, [sl, #8]

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 8000d78:	f44f 4800 	mov.w	r8, #32768	; 0x8000
  dp->CR1 = 0;
 8000d7c:	2300      	movs	r3, #0
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8000d7e:	f44f 6a10 	mov.w	sl, #2304	; 0x900
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
  i2cdutycycle_t duty = i2cp->config->duty_cycle;

  osalDbgCheck((i2cp != NULL) &&
 8000d82:	45f4      	cmp	ip, lr
  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->DR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->DR);

  /* Reset i2c peripheral.*/
  dp->CR1 = I2C_CR1_SWRST;
 8000d84:	f8c4 8000 	str.w	r8, [r4]
  dp->CR1 = 0;
 8000d88:	6023      	str	r3, [r4, #0]
  dp->CR2 = I2C_CR2_ITERREN | I2C_CR2_DMAEN;
 8000d8a:	f8c4 a004 	str.w	sl, [r4, #4]
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
  i2cdutycycle_t duty = i2cp->config->duty_cycle;

  osalDbgCheck((i2cp != NULL) &&
 8000d8e:	f200 81b2 	bhi.w	80010f6 <main+0xca6>
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 8000d92:	f8d1 8004 	ldr.w	r8, [r1, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 8000d96:	f8df c160 	ldr.w	ip, [pc, #352]	; 8000ef8 <main+0xaa8>
  osalDbgCheck((i2cp != NULL) &&
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
 8000d9a:	f64f 7ec0 	movw	lr, #65472	; 0xffc0
 8000d9e:	ea08 0e0e 	and.w	lr, r8, lr
 8000da2:	f8c1 e004 	str.w	lr, [r1, #4]
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8000da6:	f8d1 e004 	ldr.w	lr, [r1, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 8000daa:	4562      	cmp	r2, ip
               (clock_speed > 0) &&
               (clock_speed <= 4000000));

  /* CR2 Configuration.*/
  dp->CR2 &= (uint16_t)~I2C_CR2_FREQ;
  dp->CR2 |= (uint16_t)I2C_CLK_FREQ;
 8000dac:	f04e 0e2a 	orr.w	lr, lr, #42	; 0x2a
 8000db0:	f8c1 e004 	str.w	lr, [r1, #4]

  /* CCR Configuration.*/
  regCCR = 0;
  clock_div = I2C_CCR_CCR;

  if (clock_speed <= 100000) {
 8000db4:	f300 817f 	bgt.w	80010b6 <main+0xc66>
    /* Configure clock_div in standard mode.*/
    osalDbgAssert(duty == STD_DUTY_CYCLE, "invalid standard mode duty cycle");
 8000db8:	2f01      	cmp	r7, #1
 8000dba:	f040 819c 	bne.w	80010f6 <main+0xca6>

    /* Standard mode clock_div calculate: Tlow/Thigh = 1/1.*/
    osalDbgAssert((STM32_PCLK1 % (clock_speed * 2)) == 0,
 8000dbe:	0052      	lsls	r2, r2, #1
 8000dc0:	4f42      	ldr	r7, [pc, #264]	; (8000ecc <main+0xa7c>)
 8000dc2:	fbb7 f3f2 	udiv	r3, r7, r2
 8000dc6:	fb02 f203 	mul.w	r2, r2, r3
 8000dca:	1abf      	subs	r7, r7, r2
 8000dcc:	2f00      	cmp	r7, #0
 8000dce:	f040 8192 	bne.w	80010f6 <main+0xca6>
                  "PCLK1 must be divisible without remainder");
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));
 8000dd2:	b29a      	uxth	r2, r3

    osalDbgAssert(clock_div >= 0x04,
 8000dd4:	2a03      	cmp	r2, #3
 8000dd6:	f240 818e 	bls.w	80010f6 <main+0xca6>
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
 8000dda:	232b      	movs	r3, #43	; 0x2b

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
  }

  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 8000ddc:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    osalDbgAssert(clock_div >= 0x04,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
 8000de0:	620b      	str	r3, [r1, #32]
                  "PCLK1 must be divisible without remainder");
    clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 2));

    osalDbgAssert(clock_div >= 0x04,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (clock_div & I2C_CCR_CCR);
 8000de2:	f3c2 030b 	ubfx	r3, r2, #0, #12

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
  }

  osalDbgAssert((clock_div <= I2C_CCR_CCR), "the selected clock is too low");
 8000de6:	f080 8186 	bcs.w	80010f6 <main+0xca6>

  dp->CCR = regCCR;
 8000dea:	61cb      	str	r3, [r1, #28]
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
  switch (opmode) {
 8000dec:	7802      	ldrb	r2, [r0, #0]
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 8000dee:	680b      	ldr	r3, [r1, #0]
  switch (opmode) {
 8000df0:	2a02      	cmp	r2, #2
static void i2c_lld_set_opmode(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  i2copmode_t opmode = i2cp->config->op_mode;
  uint16_t regCR1;

  regCR1 = dp->CR1;
 8000df2:	b29b      	uxth	r3, r3
  switch (opmode) {
 8000df4:	f000 81d6 	beq.w	80011a4 <main+0xd54>
 8000df8:	2a03      	cmp	r2, #3
 8000dfa:	f000 81ce 	beq.w	800119a <main+0xd4a>
 8000dfe:	2a01      	cmp	r2, #1
 8000e00:	d102      	bne.n	8000e08 <main+0x9b8>
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 8000e02:	f023 030a 	bic.w	r3, r3, #10
 8000e06:	b29b      	uxth	r3, r3
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  }
  dp->CR1 = regCR1;
 8000e08:	600b      	str	r3, [r1, #0]
  /* Setup I2C parameters.*/
  i2c_lld_set_clock(i2cp);
  i2c_lld_set_opmode(i2cp);

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 8000e0a:	6823      	ldr	r3, [r4, #0]
 8000e0c:	f043 0301 	orr.w	r3, r3, #1
 8000e10:	6023      	str	r3, [r4, #0]
  i2c_lld_start(i2cp);
  i2cp->state = I2C_READY;
 8000e12:	2302      	movs	r3, #2
 8000e14:	702b      	strb	r3, [r5, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000e16:	f002 f9d3 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000e1a:	6833      	ldr	r3, [r6, #0]
 8000e1c:	4a21      	ldr	r2, [pc, #132]	; (8000ea4 <main+0xa54>)
 8000e1e:	42b3      	cmp	r3, r6
 8000e20:	d004      	beq.n	8000e2c <main+0x9dc>
 8000e22:	6992      	ldr	r2, [r2, #24]
 8000e24:	689b      	ldr	r3, [r3, #8]
 8000e26:	6892      	ldr	r2, [r2, #8]
 8000e28:	429a      	cmp	r2, r3
 8000e2a:	d335      	bcc.n	8000e98 <main+0xa48>
 8000e2c:	2500      	movs	r5, #0
 8000e2e:	f385 8811 	msr	BASEPRI, r5


void i2c_initialization(void) {

	i2cStart(&I2CD1, &i2cfg1);
	palSetPadMode(GPIOB, 8, PAL_MODE_ALTERNATE(4) | PAL_STM32_OTYPE_OPENDRAIN);
 8000e32:	f44f 7080 	mov.w	r0, #256	; 0x100
 8000e36:	f003 fbcb 	bl	80045d0 <_pal_lld_setgroupmode.constprop.12>
	palSetPadMode(GPIOB, 9, PAL_MODE_ALTERNATE(4) | PAL_STM32_OTYPE_OPENDRAIN);
 8000e3a:	f44f 7000 	mov.w	r0, #512	; 0x200
 8000e3e:	f003 fbc7 	bl	80045d0 <_pal_lld_setgroupmode.constprop.12>
	chThdSleepMilliseconds(100);
 8000e42:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000e46:	f002 fc13 	bl	8003670 <chThdSleep>
//	start_usb( );
	i2c_initialization( );
	palSetLine(LINE_LED3);
 8000e4a:	4b21      	ldr	r3, [pc, #132]	; (8000ed0 <main+0xa80>)
 * @see MPU6050_DEFAULT_ADDRESS
 * @see MPU6050_ADDRESS_AD0_LOW
 * @see MPU6050_ADDRESS_AD0_HIGH
 */
void MPU6050(uint8_t address) {
    MPUdevAddr = address;
 8000e4c:	4f21      	ldr	r7, [pc, #132]	; (8000ed4 <main+0xa84>)
 8000e4e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000e52:	2468      	movs	r4, #104	; 0x68
 8000e54:	831a      	strh	r2, [r3, #24]
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2CdevreadByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout) {
    return I2CdevreadBytes(devAddr, regAddr, 1, data, timeout);
 8000e56:	4620      	mov	r0, r4
 8000e58:	ab06      	add	r3, sp, #24
 8000e5a:	2175      	movs	r1, #117	; 0x75
 8000e5c:	2201      	movs	r2, #1
      // 01101001 read byte
    // 76543210 bit numbers
    //    xxx   args: bitStart=4, length=3
    //    010   masked
    //   -> 010 shifted
    uint8_t count, b=0;
 8000e5e:	f88d 5018 	strb.w	r5, [sp, #24]
 8000e62:	703c      	strb	r4, [r7, #0]
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2CdevreadByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout) {
    return I2CdevreadBytes(devAddr, regAddr, 1, data, timeout);
 8000e64:	f003 fdbc 	bl	80049e0 <I2CdevreadBytes.constprop.3>
    // 76543210 bit numbers
    //    xxx   args: bitStart=4, length=3
    //    010   masked
    //   -> 010 shifted
    uint8_t count, b=0;
    if ((count = I2CdevreadByte(devAddr, regAddr, &b, timeout)) != 0) {
 8000e68:	2800      	cmp	r0, #0
 8000e6a:	f000 8199 	beq.w	80011a0 <main+0xd50>
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
        b &= mask;
 8000e6e:	f89d 3018 	ldrb.w	r3, [sp, #24]
        b >>= (bitStart - length + 1);
        *data = b;
 8000e72:	4d19      	ldr	r5, [pc, #100]	; (8000ed8 <main+0xa88>)
    //   -> 010 shifted
    uint8_t count, b=0;
    if ((count = I2CdevreadByte(devAddr, regAddr, &b, timeout)) != 0) {
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
        b &= mask;
        b >>= (bitStart - length + 1);
 8000e74:	f3c3 0345 	ubfx	r3, r3, #1, #6
 8000e78:	702b      	strb	r3, [r5, #0]
	/* MPU6050, AD0 is connected to VCC */
	MPU6050(MPU6050_ADDRESS_AD0_LOW);

	/* Test connection */
	sts = MPUtestConnection();
	if (!sts) return FALSE;
 8000e7a:	782b      	ldrb	r3, [r5, #0]
 8000e7c:	2b34      	cmp	r3, #52	; 0x34
 8000e7e:	f000 80e4 	beq.w	800104a <main+0xbfa>

	if(initSensors( )){
		palSetLine(LINE_LED4);
	} else {

		palSetLine(LINE_LED5);
 8000e82:	4b13      	ldr	r3, [pc, #76]	; (8000ed0 <main+0xa80>)
 8000e84:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8000e88:	831a      	strh	r2, [r3, #24]
             (size >= THD_WORKING_AREA_SIZE(0)) &&
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 8000e8a:	4814      	ldr	r0, [pc, #80]	; (8000edc <main+0xa8c>)
 8000e8c:	f002 fac8 	bl	8003420 <chRegFindThreadByWorkingArea>
 8000e90:	b3a0      	cbz	r0, 8000efc <main+0xaac>
 8000e92:	4813      	ldr	r0, [pc, #76]	; (8000ee0 <main+0xa90>)
 8000e94:	f001 fec4 	bl	8002c20 <chSysHalt>
 8000e98:	4812      	ldr	r0, [pc, #72]	; (8000ee4 <main+0xa94>)
 8000e9a:	f001 fec1 	bl	8002c20 <chSysHalt>
 8000e9e:	bf00      	nop
 8000ea0:	08004ca8 	.word	0x08004ca8
 8000ea4:	20001320 	.word	0x20001320
 8000ea8:	08004d20 	.word	0x08004d20
 8000eac:	40023800 	.word	0x40023800
 8000eb0:	40001440 	.word	0x40001440
 8000eb4:	c0303c08 	.word	0xc0303c08
 8000eb8:	08004cd8 	.word	0x08004cd8
 8000ebc:	080041c1 	.word	0x080041c1
 8000ec0:	08004bd4 	.word	0x08004bd4
 8000ec4:	08004b84 	.word	0x08004b84
 8000ec8:	20001c2c 	.word	0x20001c2c
 8000ecc:	0280de80 	.word	0x0280de80
 8000ed0:	40020c00 	.word	0x40020c00
 8000ed4:	20000d60 	.word	0x20000d60
 8000ed8:	200008bc 	.word	0x200008bc
 8000edc:	20000d68 	.word	0x20000d68
 8000ee0:	08004d0c 	.word	0x08004d0c
 8000ee4:	08005390 	.word	0x08005390
 8000ee8:	e000e100 	.word	0xe000e100
 8000eec:	02200003 	.word	0x02200003
 8000ef0:	200010e0 	.word	0x200010e0
 8000ef4:	003d08ff 	.word	0x003d08ff
 8000ef8:	000186a0 	.word	0x000186a0
 8000efc:	49ae      	ldr	r1, [pc, #696]	; (80011b8 <main+0xd68>)
 8000efe:	4603      	mov	r3, r0
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 8000f00:	2255      	movs	r2, #85	; 0x55
 8000f02:	54ca      	strb	r2, [r1, r3]
 8000f04:	3301      	adds	r3, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000f06:	f5b3 7fe8 	cmp.w	r3, #464	; 0x1d0
    *startp++ = v;
 8000f0a:	4cab      	ldr	r4, [pc, #684]	; (80011b8 <main+0xd68>)
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000f0c:	d1f9      	bne.n	8000f02 <main+0xab2>
 8000f0e:	2320      	movs	r3, #32
 8000f10:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8000f14:	f002 f97c 	bl	8003210 <_dbg_check_lock>
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000f18:	f504 7892 	add.w	r8, r4, #292	; 0x124
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000f1c:	6972      	ldr	r2, [r6, #20]
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000f1e:	49a7      	ldr	r1, [pc, #668]	; (80011bc <main+0xd6c>)
 8000f20:	f8c4 8194 	str.w	r8, [r4, #404]	; 0x194
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000f24:	f504 73c4 	add.w	r3, r4, #392	; 0x188
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000f28:	f04f 0800 	mov.w	r8, #0
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8000f2c:	f04f 0c02 	mov.w	ip, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000f30:	f04f 0e01 	mov.w	lr, #1
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000f34:	f8c4 1164 	str.w	r1, [r4, #356]	; 0x164
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8000f38:	48a1      	ldr	r0, [pc, #644]	; (80011c0 <main+0xd70>)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000f3a:	f8df a2b0 	ldr.w	sl, [pc, #688]	; 80011ec <main+0xd9c>
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8000f3e:	f884 c1a8 	strb.w	ip, [r4, #424]	; 0x1a8
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000f42:	2181      	movs	r1, #129	; 0x81
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000f44:	f884 e1aa 	strb.w	lr, [r4, #426]	; 0x1aa
  tp->name      = name;
 8000f48:	f8c4 01a0 	str.w	r0, [r4, #416]	; 0x1a0
  REG_INSERT(tp);
 8000f4c:	f8c4 219c 	str.w	r2, [r4, #412]	; 0x19c
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000f50:	f8c4 1190 	str.w	r1, [r4, #400]	; 0x190
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000f54:	f8c4 11c4 	str.w	r1, [r4, #452]	; 0x1c4
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8000f58:	f8c4 41a4 	str.w	r4, [r4, #420]	; 0x1a4
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000f5c:	f504 71d8 	add.w	r1, r4, #432	; 0x1b0
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000f60:	f8c4 6198 	str.w	r6, [r4, #408]	; 0x198
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000f64:	f8c4 a184 	str.w	sl, [r4, #388]	; 0x184
 8000f68:	f8c4 8168 	str.w	r8, [r4, #360]	; 0x168
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000f6c:	f884 81a9 	strb.w	r8, [r4, #425]	; 0x1a9
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8000f70:	f8c4 81c0 	str.w	r8, [r4, #448]	; 0x1c0
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000f74:	f8c4 81bc 	str.w	r8, [r4, #444]	; 0x1bc
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000f78:	6113      	str	r3, [r2, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000f7a:	f504 72da 	add.w	r2, r4, #436	; 0x1b4
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8000f7e:	4618      	mov	r0, r3
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000f80:	f8c4 11b0 	str.w	r1, [r4, #432]	; 0x1b0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000f84:	f8c4 21b4 	str.w	r2, [r4, #436]	; 0x1b4
  tqp->prev = (thread_t *)tqp;
 8000f88:	f8c4 21b8 	str.w	r2, [r4, #440]	; 0x1b8
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000f8c:	6173      	str	r3, [r6, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8000f8e:	f003 fa4f 	bl	8004430 <chSchWakeupS.constprop.51>
  chSysUnlock();
 8000f92:	f002 f925 	bl	80031e0 <chSysUnlock.lto_priv.59>
	//shellInit();

	COM_HEADER header = COM_PACKAGE_IMU;
	unsigned char tx_buffer[64];
	unsigned int tx_length;
	tx_buffer[0] = START_BYTE;
 8000f96:	23aa      	movs	r3, #170	; 0xaa
	tx_buffer[1] = header;
 8000f98:	f88d 8019 	strb.w	r8, [sp, #25]
	tx_buffer[2] = 0;
 8000f9c:	f88d 801a 	strb.w	r8, [sp, #26]
	//shellInit();

	COM_HEADER header = COM_PACKAGE_IMU;
	unsigned char tx_buffer[64];
	unsigned int tx_length;
	tx_buffer[0] = START_BYTE;
 8000fa0:	f88d 3018 	strb.w	r3, [sp, #24]
//		chprintf((BaseSequentialStream *)&SDU1, "A: Z-axis: %d mg\r\n", ZaccelRaw);
//		chprintf((BaseSequentialStream *)&SDU1, "G: X-axis: %d mg\r\n", XgyroRaw);
//		chprintf((BaseSequentialStream *)&SDU1, "G: Y-axis: %d mg\r\n", YgyroRaw);
//		chprintf((BaseSequentialStream *)&SDU1, "G: Z-axis: %d mg\r\n", ZgyroRaw);

		tx_length = 3;
 8000fa4:	2203      	movs	r2, #3
 8000fa6:	9205      	str	r2, [sp, #20]
 * @see getAcceleration()
 * @see getRotation()
 * @see MPU6050_RA_ACCEL_XOUT_H
 */
void MPUgetMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
    I2CdevreadBytes(MPUdevAddr, MPU6050_RA_ACCEL_XOUT_H, 14, MPUbuffer, I2CDEV_DEFAULT_READ_TIMEOUT);
 8000fa8:	7838      	ldrb	r0, [r7, #0]
 8000faa:	4b86      	ldr	r3, [pc, #536]	; (80011c4 <main+0xd74>)
 8000fac:	213b      	movs	r1, #59	; 0x3b
 8000fae:	220e      	movs	r2, #14
 8000fb0:	f003 fd16 	bl	80049e0 <I2CdevreadBytes.constprop.3>
    *ax = (((int16_t)MPUbuffer[0]) << 8) | MPUbuffer[1];
 8000fb4:	786a      	ldrb	r2, [r5, #1]
 8000fb6:	7829      	ldrb	r1, [r5, #0]
    *ay = (((int16_t)MPUbuffer[2]) << 8) | MPUbuffer[3];
    *az = (((int16_t)MPUbuffer[4]) << 8) | MPUbuffer[5];
 8000fb8:	796b      	ldrb	r3, [r5, #5]
 8000fba:	f895 a004 	ldrb.w	sl, [r5, #4]
 * @see MPU6050_RA_ACCEL_XOUT_H
 */
void MPUgetMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
    I2CdevreadBytes(MPUdevAddr, MPU6050_RA_ACCEL_XOUT_H, 14, MPUbuffer, I2CDEV_DEFAULT_READ_TIMEOUT);
    *ax = (((int16_t)MPUbuffer[0]) << 8) | MPUbuffer[1];
    *ay = (((int16_t)MPUbuffer[2]) << 8) | MPUbuffer[3];
 8000fbe:	f895 e003 	ldrb.w	lr, [r5, #3]
    *az = (((int16_t)MPUbuffer[4]) << 8) | MPUbuffer[5];
    *gx = (((int16_t)MPUbuffer[8]) << 8) | MPUbuffer[9];
 8000fc2:	7a68      	ldrb	r0, [r5, #9]
 * @see MPU6050_RA_ACCEL_XOUT_H
 */
void MPUgetMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
    I2CdevreadBytes(MPUdevAddr, MPU6050_RA_ACCEL_XOUT_H, 14, MPUbuffer, I2CDEV_DEFAULT_READ_TIMEOUT);
    *ax = (((int16_t)MPUbuffer[0]) << 8) | MPUbuffer[1];
    *ay = (((int16_t)MPUbuffer[2]) << 8) | MPUbuffer[3];
 8000fc4:	f895 b002 	ldrb.w	fp, [r5, #2]
    *az = (((int16_t)MPUbuffer[4]) << 8) | MPUbuffer[5];
    *gx = (((int16_t)MPUbuffer[8]) << 8) | MPUbuffer[9];
 8000fc8:	f895 8008 	ldrb.w	r8, [r5, #8]
    *gy = (((int16_t)MPUbuffer[10]) << 8) | MPUbuffer[11];
 8000fcc:	7aae      	ldrb	r6, [r5, #10]
    *gz = (((int16_t)MPUbuffer[12]) << 8) | MPUbuffer[13];
 8000fce:	7b2c      	ldrb	r4, [r5, #12]
 * @see getRotation()
 * @see MPU6050_RA_ACCEL_XOUT_H
 */
void MPUgetMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
    I2CdevreadBytes(MPUdevAddr, MPU6050_RA_ACCEL_XOUT_H, 14, MPUbuffer, I2CDEV_DEFAULT_READ_TIMEOUT);
    *ax = (((int16_t)MPUbuffer[0]) << 8) | MPUbuffer[1];
 8000fd0:	ea42 2101 	orr.w	r1, r2, r1, lsl #8
    *ay = (((int16_t)MPUbuffer[2]) << 8) | MPUbuffer[3];
    *az = (((int16_t)MPUbuffer[4]) << 8) | MPUbuffer[5];
    *gx = (((int16_t)MPUbuffer[8]) << 8) | MPUbuffer[9];
    *gy = (((int16_t)MPUbuffer[10]) << 8) | MPUbuffer[11];
 8000fd4:	7aea      	ldrb	r2, [r5, #11]
 */
void MPUgetMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
    I2CdevreadBytes(MPUdevAddr, MPU6050_RA_ACCEL_XOUT_H, 14, MPUbuffer, I2CDEV_DEFAULT_READ_TIMEOUT);
    *ax = (((int16_t)MPUbuffer[0]) << 8) | MPUbuffer[1];
    *ay = (((int16_t)MPUbuffer[2]) << 8) | MPUbuffer[3];
    *az = (((int16_t)MPUbuffer[4]) << 8) | MPUbuffer[5];
 8000fd6:	ea43 2a0a 	orr.w	sl, r3, sl, lsl #8
    *gx = (((int16_t)MPUbuffer[8]) << 8) | MPUbuffer[9];
    *gy = (((int16_t)MPUbuffer[10]) << 8) | MPUbuffer[11];
    *gz = (((int16_t)MPUbuffer[12]) << 8) | MPUbuffer[13];
 8000fda:	7b6b      	ldrb	r3, [r5, #13]
 * @see MPU6050_RA_ACCEL_XOUT_H
 */
void MPUgetMotion6(int16_t* ax, int16_t* ay, int16_t* az, int16_t* gx, int16_t* gy, int16_t* gz) {
    I2CdevreadBytes(MPUdevAddr, MPU6050_RA_ACCEL_XOUT_H, 14, MPUbuffer, I2CDEV_DEFAULT_READ_TIMEOUT);
    *ax = (((int16_t)MPUbuffer[0]) << 8) | MPUbuffer[1];
    *ay = (((int16_t)MPUbuffer[2]) << 8) | MPUbuffer[3];
 8000fdc:	ea4e 2b0b 	orr.w	fp, lr, fp, lsl #8
    *az = (((int16_t)MPUbuffer[4]) << 8) | MPUbuffer[5];
    *gx = (((int16_t)MPUbuffer[8]) << 8) | MPUbuffer[9];
 8000fe0:	ea40 2808 	orr.w	r8, r0, r8, lsl #8
    *gy = (((int16_t)MPUbuffer[10]) << 8) | MPUbuffer[11];
 8000fe4:	ea42 2606 	orr.w	r6, r2, r6, lsl #8
void get_data_IMU(unsigned char *tx_data, unsigned int *index) {

	int16_t XaccelRaw, YaccelRaw, ZaccelRaw, XgyroRaw, YgyroRaw, ZgyroRaw;
	MPUgetMotion6(&XaccelRaw, &YaccelRaw, &ZaccelRaw, &XgyroRaw, &YgyroRaw, &ZgyroRaw);

	buffer_append_int16(tx_data, XaccelRaw, index);
 8000fe8:	a806      	add	r0, sp, #24
 8000fea:	aa05      	add	r2, sp, #20
 8000fec:	b209      	sxth	r1, r1
    *gz = (((int16_t)MPUbuffer[12]) << 8) | MPUbuffer[13];
 8000fee:	ea43 2404 	orr.w	r4, r3, r4, lsl #8
 8000ff2:	f003 fc05 	bl	8004800 <buffer_append_int16>
	buffer_append_int16(tx_data, YaccelRaw, index);
 8000ff6:	a806      	add	r0, sp, #24
 8000ff8:	fa0f f18b 	sxth.w	r1, fp
 8000ffc:	aa05      	add	r2, sp, #20
 8000ffe:	f003 fbff 	bl	8004800 <buffer_append_int16>
	buffer_append_int16(tx_data, ZaccelRaw, index);
 8001002:	a806      	add	r0, sp, #24
 8001004:	fa0f f18a 	sxth.w	r1, sl
 8001008:	aa05      	add	r2, sp, #20
 800100a:	f003 fbf9 	bl	8004800 <buffer_append_int16>

	buffer_append_int16(tx_data, XgyroRaw, index);
 800100e:	a806      	add	r0, sp, #24
 8001010:	fa0f f188 	sxth.w	r1, r8
 8001014:	aa05      	add	r2, sp, #20
 8001016:	f003 fbf3 	bl	8004800 <buffer_append_int16>
	buffer_append_int16(tx_data, YgyroRaw, index);
 800101a:	a806      	add	r0, sp, #24
 800101c:	b231      	sxth	r1, r6
 800101e:	aa05      	add	r2, sp, #20
 8001020:	f003 fbee 	bl	8004800 <buffer_append_int16>
	buffer_append_int16(tx_data, ZgyroRaw, index);
 8001024:	a806      	add	r0, sp, #24
 8001026:	b221      	sxth	r1, r4
 8001028:	aa05      	add	r2, sp, #20
 800102a:	f003 fbe9 	bl	8004800 <buffer_append_int16>
		get_data_IMU(tx_buffer, &tx_length);
		tx_buffer[2] = (unsigned char)tx_length-3;
 800102e:	9a05      	ldr	r2, [sp, #20]
		streamWrite(&SDU1, tx_buffer, tx_length);
 8001030:	f8d9 3000 	ldr.w	r3, [r9]
 8001034:	4864      	ldr	r0, [pc, #400]	; (80011c8 <main+0xd78>)
//		chprintf((BaseSequentialStream *)&SDU1, "G: Y-axis: %d mg\r\n", YgyroRaw);
//		chprintf((BaseSequentialStream *)&SDU1, "G: Z-axis: %d mg\r\n", ZgyroRaw);

		tx_length = 3;
		get_data_IMU(tx_buffer, &tx_length);
		tx_buffer[2] = (unsigned char)tx_length-3;
 8001036:	1ed1      	subs	r1, r2, #3
 8001038:	f88d 101a 	strb.w	r1, [sp, #26]
		streamWrite(&SDU1, tx_buffer, tx_length);
 800103c:	681b      	ldr	r3, [r3, #0]
 800103e:	a906      	add	r1, sp, #24
 8001040:	4798      	blx	r3
//
		chThdSleepMilliseconds(20);
 8001042:	20c8      	movs	r0, #200	; 0xc8
 8001044:	f002 fb14 	bl	8003670 <chThdSleep>
 8001048:	e7ac      	b.n	8000fa4 <main+0xb54>
 * A small delay of ~50ms may be desirable after triggering a reset.
 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_DEVICE_RESET_BIT
 */
void MPUreset() {
    I2CdevwriteBit(MPUdevAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_DEVICE_RESET_BIT, TRUE);
 800104a:	216b      	movs	r1, #107	; 0x6b
 800104c:	2207      	movs	r2, #7
 800104e:	2301      	movs	r3, #1
 8001050:	7838      	ldrb	r0, [r7, #0]
 8001052:	f003 fd1d 	bl	8004a90 <I2CdevwriteBit>
 *
 * @see MPU6050_RA_USER_CTRL
 * @see MPU6050_USERCTRL_SIG_COND_RESET_BIT
 */
void MPUresetSensors() {
    I2CdevwriteBit(MPUdevAddr, MPU6050_RA_USER_CTRL, MPU6050_USERCTRL_SIG_COND_RESET_BIT, TRUE);
 8001056:	216a      	movs	r1, #106	; 0x6a
 8001058:	2200      	movs	r2, #0
 800105a:	2301      	movs	r3, #1
 800105c:	7838      	ldrb	r0, [r7, #0]
 800105e:	f003 fd17 	bl	8004a90 <I2CdevwriteBit>
	sts = MPUtestConnection();
	if (!sts) return FALSE;

	MPUreset();
	MPUresetSensors();
	chThdSleepMilliseconds(100);
 8001062:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001066:	f002 fb03 	bl	8003670 <chThdSleep>
 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_CLKSEL_BIT
 * @see MPU6050_PWR1_CLKSEL_LENGTH
 */
void MPUsetClockSource(uint8_t source) {
    I2CdevwriteBits(MPUdevAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, source);
 800106a:	2301      	movs	r3, #1
 * @see MPU6050_RA_GYRO_CONFIG
 * @see MPU6050_GCONFIG_FS_SEL_BIT
 * @see MPU6050_GCONFIG_FS_SEL_LENGTH
 */
void MPUsetFullScaleGyroRange(uint8_t range) {
    I2CdevwriteBits(MPUdevAddr, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, range);
 800106c:	2400      	movs	r4, #0
 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_CLKSEL_BIT
 * @see MPU6050_PWR1_CLKSEL_LENGTH
 */
void MPUsetClockSource(uint8_t source) {
    I2CdevwriteBits(MPUdevAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_CLKSEL_BIT, MPU6050_PWR1_CLKSEL_LENGTH, source);
 800106e:	7838      	ldrb	r0, [r7, #0]
 8001070:	9300      	str	r3, [sp, #0]
 8001072:	216b      	movs	r1, #107	; 0x6b
 8001074:	2202      	movs	r2, #2
 8001076:	2303      	movs	r3, #3
 8001078:	f003 fcda 	bl	8004a30 <I2CdevwriteBits>
 * @see MPU6050_RA_GYRO_CONFIG
 * @see MPU6050_GCONFIG_FS_SEL_BIT
 * @see MPU6050_GCONFIG_FS_SEL_LENGTH
 */
void MPUsetFullScaleGyroRange(uint8_t range) {
    I2CdevwriteBits(MPUdevAddr, MPU6050_RA_GYRO_CONFIG, MPU6050_GCONFIG_FS_SEL_BIT, MPU6050_GCONFIG_FS_SEL_LENGTH, range);
 800107c:	7838      	ldrb	r0, [r7, #0]
 800107e:	9400      	str	r4, [sp, #0]
 8001080:	211b      	movs	r1, #27
 8001082:	2204      	movs	r2, #4
 8001084:	2302      	movs	r3, #2
 8001086:	f003 fcd3 	bl	8004a30 <I2CdevwriteBits>
/** Set full-scale accelerometer range.
 * @param range New full-scale accelerometer range setting
 * @see getFullScaleAccelRange()
 */
void MPUsetFullScaleAccelRange(uint8_t range) {
    I2CdevwriteBits(MPUdevAddr, MPU6050_RA_ACCEL_CONFIG, MPU6050_ACONFIG_AFS_SEL_BIT, MPU6050_ACONFIG_AFS_SEL_LENGTH, range);
 800108a:	7838      	ldrb	r0, [r7, #0]
 800108c:	9400      	str	r4, [sp, #0]
 800108e:	211c      	movs	r1, #28
 8001090:	2204      	movs	r2, #4
 8001092:	2302      	movs	r3, #2
 8001094:	f003 fccc 	bl	8004a30 <I2CdevwriteBits>
 * @see getSleepEnabled()
 * @see MPU6050_RA_PWR_MGMT_1
 * @see MPU6050_PWR1_SLEEP_BIT
 */
void MPUsetSleepEnabled(bool enabled) {
    I2CdevwriteBit(MPUdevAddr, MPU6050_RA_PWR_MGMT_1, MPU6050_PWR1_SLEEP_BIT, enabled);
 8001098:	4623      	mov	r3, r4
 800109a:	2206      	movs	r2, #6
 800109c:	216b      	movs	r1, #107	; 0x6b
 800109e:	7838      	ldrb	r0, [r7, #0]
 80010a0:	f003 fcf6 	bl	8004a90 <I2CdevwriteBit>
	MPUinitialize();
	chThdSleepMilliseconds(100);
 80010a4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80010a8:	f002 fae2 	bl	8003670 <chThdSleep>
//	start_usb( );
	i2c_initialization( );
	palSetLine(LINE_LED3);

	if(initSensors( )){
		palSetLine(LINE_LED4);
 80010ac:	4b47      	ldr	r3, [pc, #284]	; (80011cc <main+0xd7c>)
 80010ae:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80010b2:	831a      	strh	r2, [r3, #24]
 80010b4:	e6e9      	b.n	8000e8a <main+0xa3a>
    regCCR |= (clock_div & I2C_CCR_CCR);

    /* Sets the Maximum Rise Time for standard mode.*/
    dp->TRISE = I2C_CLK_FREQ + 1;
  }
  else if (clock_speed <= 400000) {
 80010b6:	f8df e138 	ldr.w	lr, [pc, #312]	; 80011f0 <main+0xda0>
 80010ba:	4572      	cmp	r2, lr
 80010bc:	f73f ae95 	bgt.w	8000dea <main+0x99a>
    /* Configure clock_div in fast mode.*/
    osalDbgAssert((duty == FAST_DUTY_CYCLE_2) ||
 80010c0:	1ebb      	subs	r3, r7, #2
 80010c2:	2b01      	cmp	r3, #1
 80010c4:	d817      	bhi.n	80010f6 <main+0xca6>
                  (duty == FAST_DUTY_CYCLE_16_9),
                  "invalid fast mode duty cycle");

    if (duty == FAST_DUTY_CYCLE_2) {
 80010c6:	2f02      	cmp	r7, #2
 80010c8:	d018      	beq.n	80010fc <main+0xcac>
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
    }
    else if (duty == FAST_DUTY_CYCLE_16_9) {
      /* Fast mode clock_div calculate: Tlow/Thigh = 16/9.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 25)) == 0,
 80010ca:	2319      	movs	r3, #25
 80010cc:	fb03 f202 	mul.w	r2, r3, r2
 80010d0:	4f3f      	ldr	r7, [pc, #252]	; (80011d0 <main+0xd80>)
 80010d2:	fbb7 f3f2 	udiv	r3, r7, r2
 80010d6:	fb02 f203 	mul.w	r2, r2, r3
 80010da:	1abf      	subs	r7, r7, r2
 80010dc:	b95f      	cbnz	r7, 80010f6 <main+0xca6>
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 25));
 80010de:	b29a      	uxth	r2, r3
      regCCR |= I2C_CCR_DUTY;
 80010e0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    }

    osalDbgAssert(clock_div >= 0x01,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));
 80010e4:	4313      	orrs	r3, r2
 80010e6:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 80010ea:	ea6f 4353 	mvn.w	r3, r3, lsr #17

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 80010ee:	220d      	movs	r2, #13
      regCCR |= I2C_CCR_DUTY;
    }

    osalDbgAssert(clock_div >= 0x01,
                  "clock divider less then 0x04 not allowed");
    regCCR |= (I2C_CCR_FS | (clock_div & I2C_CCR_CCR));
 80010f0:	b29b      	uxth	r3, r3

    /* Sets the Maximum Rise Time for fast mode.*/
    dp->TRISE = (I2C_CLK_FREQ * 300 / 1000) + 1;
 80010f2:	620a      	str	r2, [r1, #32]
 80010f4:	e679      	b.n	8000dea <main+0x99a>
  I2C_TypeDef *dp = i2cp->i2c;
  uint16_t regCCR, clock_div;
  int32_t clock_speed = i2cp->config->clock_speed;
  i2cdutycycle_t duty = i2cp->config->duty_cycle;

  osalDbgCheck((i2cp != NULL) &&
 80010f6:	4837      	ldr	r0, [pc, #220]	; (80011d4 <main+0xd84>)
 80010f8:	f001 fd92 	bl	8002c20 <chSysHalt>
                  (duty == FAST_DUTY_CYCLE_16_9),
                  "invalid fast mode duty cycle");

    if (duty == FAST_DUTY_CYCLE_2) {
      /* Fast mode clock_div calculate: Tlow/Thigh = 2/1.*/
      osalDbgAssert((STM32_PCLK1 % (clock_speed * 3)) == 0,
 80010fc:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8001100:	4b33      	ldr	r3, [pc, #204]	; (80011d0 <main+0xd80>)
 8001102:	fbb3 f7f2 	udiv	r7, r3, r2
 8001106:	fb02 f207 	mul.w	r2, r2, r7
 800110a:	1a9b      	subs	r3, r3, r2
 800110c:	2b00      	cmp	r3, #0
 800110e:	d1f2      	bne.n	80010f6 <main+0xca6>
                    "PCLK1 must be divided without remainder");
      clock_div = (uint16_t)(STM32_PCLK1 / (clock_speed * 3));
 8001110:	b2ba      	uxth	r2, r7
 8001112:	e7e7      	b.n	80010e4 <main+0xc94>

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 8001114:	f8df a0dc 	ldr.w	sl, [pc, #220]	; 80011f4 <main+0xda4>
      b = dmaStreamAllocate(i2cp->dmarx,
 8001118:	6af8      	ldr	r0, [r7, #44]	; 0x2c

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 800111a:	f8da 3020 	ldr.w	r3, [sl, #32]
      b = dmaStreamAllocate(i2cp->dmarx,
 800111e:	492e      	ldr	r1, [pc, #184]	; (80011d8 <main+0xd88>)

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 8001120:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001124:	f04f 0e00 	mov.w	lr, #0
 8001128:	f8ca 3020 	str.w	r3, [sl, #32]
  I2C_TypeDef *dp = i2cp->i2c;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {

    i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 800112c:	f240 4256 	movw	r2, #1110	; 0x456

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
 8001130:	f8ca e020 	str.w	lr, [sl, #32]

    i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
                      STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                      STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                      STM32_DMA_CR_DIR_M2P;
    i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8001134:	f240 4316 	movw	r3, #1046	; 0x416
  I2C_TypeDef *dp = i2cp->i2c;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {

    i2cp->txdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 8001138:	62ba      	str	r2, [r7, #40]	; 0x28
                      STM32_DMA_CR_MINC       | STM32_DMA_CR_DMEIE |
                      STM32_DMA_CR_TEIE       | STM32_DMA_CR_TCIE |
                      STM32_DMA_CR_DIR_M2P;
    i2cp->rxdmamode = STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE |
 800113a:	627b      	str	r3, [r7, #36]	; 0x24
#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {
      bool b;

      rccResetI2C1();
      b = dmaStreamAllocate(i2cp->dmarx,
 800113c:	f003 f9e8 	bl	8004510 <dmaStreamAllocate.constprop.31>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 8001140:	bb40      	cbnz	r0, 8001194 <main+0xd44>
      b = dmaStreamAllocate(i2cp->dmatx,
 8001142:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8001144:	4925      	ldr	r1, [pc, #148]	; (80011dc <main+0xd8c>)
 8001146:	f003 f9e3 	bl	8004510 <dmaStreamAllocate.constprop.31>
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 800114a:	bb18      	cbnz	r0, 8001194 <main+0xd44>
      rccEnableI2C1(FALSE);
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 800114c:	6a79      	ldr	r1, [r7, #36]	; 0x24
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 800114e:	6aba      	ldr	r2, [r7, #40]	; 0x28
      b = dmaStreamAllocate(i2cp->dmatx,
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
 8001150:	f8da 0040 	ldr.w	r0, [sl, #64]	; 0x40

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001154:	4b22      	ldr	r3, [pc, #136]	; (80011e0 <main+0xd90>)
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 8001156:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 800115a:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 800115e:	f04f 0e50 	mov.w	lr, #80	; 0x50
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001162:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
      b = dmaStreamAllocate(i2cp->dmatx,
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
 8001166:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 800116a:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 800116e:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
      b = dmaStreamAllocate(i2cp->dmatx,
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_tx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableI2C1(FALSE);
 8001172:	f8ca 0040 	str.w	r0, [sl, #64]	; 0x40
      nvicEnableVector(I2C1_EV_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);
      nvicEnableVector(I2C1_ER_IRQn, STM32_I2C_I2C1_IRQ_PRIORITY);

      i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 8001176:	6279      	str	r1, [r7, #36]	; 0x24

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001178:	f883 e31f 	strb.w	lr, [r3, #799]	; 0x31f
                       STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 800117c:	62ba      	str	r2, [r7, #40]	; 0x28
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800117e:	f8c3 c180 	str.w	ip, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001182:	f8c3 c000 	str.w	ip, [r3]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001186:	f883 e320 	strb.w	lr, [r3, #800]	; 0x320
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800118a:	f8c3 8184 	str.w	r8, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800118e:	f8c3 8004 	str.w	r8, [r3, #4]
 8001192:	e5dd      	b.n	8000d50 <main+0x900>
      rccResetI2C1();
      b = dmaStreamAllocate(i2cp->dmarx,
                            STM32_I2C_I2C1_IRQ_PRIORITY,
                            (stm32_dmaisr_t)i2c_lld_serve_rx_end_irq,
                            (void *)i2cp);
      osalDbgAssert(!b, "stream already allocated");
 8001194:	4813      	ldr	r0, [pc, #76]	; (80011e4 <main+0xd94>)
 8001196:	f001 fd43 	bl	8002c20 <chSysHalt>
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_HOST:
    regCR1 |= (I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
 800119a:	f043 030a 	orr.w	r3, r3, #10
 800119e:	e633      	b.n	8000e08 <main+0x9b8>
 80011a0:	4d08      	ldr	r5, [pc, #32]	; (80011c4 <main+0xd74>)
 80011a2:	e66a      	b.n	8000e7a <main+0xa2a>
  case OPMODE_I2C:
    regCR1 &= (uint16_t)~(I2C_CR1_SMBUS|I2C_CR1_SMBTYPE);
    break;
  case OPMODE_SMBUS_DEVICE:
    regCR1 |= I2C_CR1_SMBUS;
    regCR1 &= (uint16_t)~(I2C_CR1_SMBTYPE);
 80011a4:	f023 0308 	bic.w	r3, r3, #8
 80011a8:	b29b      	uxth	r3, r3
 80011aa:	f043 0302 	orr.w	r3, r3, #2
 80011ae:	e62b      	b.n	8000e08 <main+0x9b8>
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 80011b0:	4b0d      	ldr	r3, [pc, #52]	; (80011e8 <main+0xd98>)
 80011b2:	f8ca 3018 	str.w	r3, [sl, #24]
 80011b6:	e596      	b.n	8000ce6 <main+0x896>
 80011b8:	20000d68 	.word	0x20000d68
 80011bc:	080037e1 	.word	0x080037e1
 80011c0:	08004ce4 	.word	0x08004ce4
 80011c4:	200008bc 	.word	0x200008bc
 80011c8:	200008cc 	.word	0x200008cc
 80011cc:	40020c00 	.word	0x40020c00
 80011d0:	0280de80 	.word	0x0280de80
 80011d4:	08004d38 	.word	0x08004d38
 80011d8:	08002431 	.word	0x08002431
 80011dc:	080023f1 	.word	0x080023f1
 80011e0:	e000e100 	.word	0xe000e100
 80011e4:	08004b74 	.word	0x08004b74
 80011e8:	c0303c00 	.word	0xc0303c00
 80011ec:	080002f5 	.word	0x080002f5
 80011f0:	00061a80 	.word	0x00061a80
 80011f4:	40023800 	.word	0x40023800
	...

08001200 <sduInterruptTransmitted>:
 *          interrupt endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
 8001200:	4770      	bx	lr
 8001202:	bf00      	nop
	...

08001210 <sduRequestsHook>:
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8001210:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8001214:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8001218:	2b20      	cmp	r3, #32
 800121a:	d001      	beq.n	8001220 <sduRequestsHook+0x10>
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
      return true;
    default:
      return false;
 800121c:	2000      	movs	r0, #0
    }
  }
  return false;
}
 800121e:	4770      	bx	lr
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
    switch (usbp->setup[1]) {
 8001220:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8001224:	2b21      	cmp	r3, #33	; 0x21
 8001226:	d003      	beq.n	8001230 <sduRequestsHook+0x20>
 8001228:	2b22      	cmp	r3, #34	; 0x22
 800122a:	d009      	beq.n	8001240 <sduRequestsHook+0x30>
 800122c:	2b20      	cmp	r3, #32
 800122e:	d1f5      	bne.n	800121c <sduRequestsHook+0xc>
    case CDC_GET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
      return true;
    case CDC_SET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8001230:	4b06      	ldr	r3, [pc, #24]	; (800124c <sduRequestsHook+0x3c>)
 8001232:	6383      	str	r3, [r0, #56]	; 0x38
 8001234:	2207      	movs	r2, #7
 8001236:	2300      	movs	r3, #0
 8001238:	63c2      	str	r2, [r0, #60]	; 0x3c
 800123a:	6403      	str	r3, [r0, #64]	; 0x40
      return true;
 800123c:	2001      	movs	r0, #1
 800123e:	4770      	bx	lr
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8001240:	2300      	movs	r3, #0
 8001242:	6383      	str	r3, [r0, #56]	; 0x38
 8001244:	63c3      	str	r3, [r0, #60]	; 0x3c
 8001246:	6403      	str	r3, [r0, #64]	; 0x40
      return true;
 8001248:	2001      	movs	r0, #1
 800124a:	4770      	bx	lr
 800124c:	20000800 	.word	0x20000800

08001250 <SVC_Handler>:
/*lint -restore*/
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8001250:	4a06      	ldr	r2, [pc, #24]	; (800126c <SVC_Handler+0x1c>)
 8001252:	6853      	ldr	r3, [r2, #4]
 8001254:	f023 0301 	bic.w	r3, r3, #1
 8001258:	6053      	str	r3, [r2, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800125a:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 800125e:	3368      	adds	r3, #104	; 0x68
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001260:	f383 8809 	msr	PSP, r3
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001264:	2300      	movs	r3, #0
 8001266:	f383 8811 	msr	BASEPRI, r3
 800126a:	4770      	bx	lr
 800126c:	e000ef30 	.word	0xe000ef30

08001270 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 8001270:	b570      	push	{r4, r5, r6, lr}
 8001272:	460d      	mov	r5, r1
 8001274:	4604      	mov	r4, r0

  osalDbgCheckClassS();
 8001276:	f001 fcf3 	bl	8002c60 <chDbgCheckClassS>
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 800127a:	b1d5      	cbz	r5, 80012b2 <obqPostFullBufferS+0x42>
 800127c:	69e3      	ldr	r3, [r4, #28]
 800127e:	3b04      	subs	r3, #4
 8001280:	429d      	cmp	r5, r3
 8001282:	d816      	bhi.n	80012b2 <obqPostFullBufferS+0x42>
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");
 8001284:	68e3      	ldr	r3, [r4, #12]
 8001286:	b1a3      	cbz	r3, 80012b2 <obqPostFullBufferS+0x42>

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 8001288:	6921      	ldr	r1, [r4, #16]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
  obqp->bwrptr += obqp->bsize;
  if (obqp->bwrptr >= obqp->btop) {
 800128a:	69a0      	ldr	r0, [r4, #24]
  osalDbgCheckClassS();
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 800128c:	600d      	str	r5, [r1, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
  obqp->bwrptr += obqp->bsize;
 800128e:	69e3      	ldr	r3, [r4, #28]

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 8001290:	68e2      	ldr	r2, [r4, #12]
  obqp->bwrptr += obqp->bsize;
 8001292:	440b      	add	r3, r1
  if (obqp->bwrptr >= obqp->btop) {
 8001294:	4283      	cmp	r3, r0
  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
  obqp->bwrptr += obqp->bsize;
 8001296:	6123      	str	r3, [r4, #16]
  if (obqp->bwrptr >= obqp->btop) {
    obqp->bwrptr = obqp->buffers;
 8001298:	bf24      	itt	cs
 800129a:	6a63      	ldrcs	r3, [r4, #36]	; 0x24
 800129c:	6123      	strcs	r3, [r4, #16]

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 800129e:	3a01      	subs	r2, #1

  /* No "current" buffer.*/
  obqp->ptr = NULL;

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 80012a0:	6b23      	ldr	r3, [r4, #48]	; 0x30

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 80012a2:	60e2      	str	r2, [r4, #12]
  if (obqp->bwrptr >= obqp->btop) {
    obqp->bwrptr = obqp->buffers;
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 80012a4:	2200      	movs	r2, #0
 80012a6:	62a2      	str	r2, [r4, #40]	; 0x28

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 80012a8:	b133      	cbz	r3, 80012b8 <obqPostFullBufferS+0x48>
    obqp->notify(obqp);
 80012aa:	4620      	mov	r0, r4
  }
}
 80012ac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  /* No "current" buffer.*/
  obqp->ptr = NULL;

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
    obqp->notify(obqp);
 80012b0:	4718      	bx	r3
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {

  osalDbgCheckClassS();
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
 80012b2:	4802      	ldr	r0, [pc, #8]	; (80012bc <obqPostFullBufferS+0x4c>)
 80012b4:	f001 fcb4 	bl	8002c20 <chSysHalt>
 80012b8:	bd70      	pop	{r4, r5, r6, pc}
 80012ba:	bf00      	nop
 80012bc:	08004e5c 	.word	0x08004e5c

080012c0 <ibqReleaseEmptyBufferS>:
   *
   * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
   *
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 80012c0:	b510      	push	{r4, lr}
 80012c2:	4604      	mov	r4, r0

  osalDbgCheckClassS();
 80012c4:	f001 fccc 	bl	8002c60 <chDbgCheckClassS>
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 80012c8:	68e3      	ldr	r3, [r4, #12]
 80012ca:	b19b      	cbz	r3, 80012f4 <ibqReleaseEmptyBufferS+0x34>

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
  ibqp->brdptr += ibqp->bsize;
  if (ibqp->brdptr >= ibqp->btop) {
 80012cc:	f104 0014 	add.w	r0, r4, #20
 80012d0:	c80b      	ldmia	r0, {r0, r1, r3}
  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
  ibqp->brdptr += ibqp->bsize;
 80012d2:	4403      	add	r3, r0
  if (ibqp->brdptr >= ibqp->btop) {
 80012d4:	428b      	cmp	r3, r1

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 80012d6:	68e2      	ldr	r2, [r4, #12]
  ibqp->brdptr += ibqp->bsize;
 80012d8:	6163      	str	r3, [r4, #20]
  if (ibqp->brdptr >= ibqp->btop) {
    ibqp->brdptr = ibqp->buffers;
 80012da:	bf24      	itt	cs
 80012dc:	6a63      	ldrcs	r3, [r4, #36]	; 0x24
 80012de:	6163      	strcs	r3, [r4, #20]

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 80012e0:	3a01      	subs	r2, #1

  /* No "current" buffer.*/
  ibqp->ptr = NULL;

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 80012e2:	6b23      	ldr	r3, [r4, #48]	; 0x30

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 80012e4:	60e2      	str	r2, [r4, #12]
  if (ibqp->brdptr >= ibqp->btop) {
    ibqp->brdptr = ibqp->buffers;
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 80012e6:	2200      	movs	r2, #0
 80012e8:	62a2      	str	r2, [r4, #40]	; 0x28

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 80012ea:	b133      	cbz	r3, 80012fa <ibqReleaseEmptyBufferS+0x3a>
    ibqp->notify(ibqp);
 80012ec:	4620      	mov	r0, r4
  }
}
 80012ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  /* No "current" buffer.*/
  ibqp->ptr = NULL;

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
    ibqp->notify(ibqp);
 80012f2:	4718      	bx	r3
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");
 80012f4:	4801      	ldr	r0, [pc, #4]	; (80012fc <ibqReleaseEmptyBufferS+0x3c>)
 80012f6:	f001 fc93 	bl	8002c20 <chSysHalt>
 80012fa:	bd10      	pop	{r4, pc}
 80012fc:	08004e44 	.word	0x08004e44

08001300 <obqGetEmptyBufferTimeoutS>:
 *                      suspended state.
 *
 * @sclass
 */
msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                systime_t timeout) {
 8001300:	b570      	push	{r4, r5, r6, lr}
 8001302:	4604      	mov	r4, r0
 8001304:	460d      	mov	r5, r1

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8001306:	4e15      	ldr	r6, [pc, #84]	; (800135c <obqGetEmptyBufferTimeoutS+0x5c>)

  osalDbgCheckClassS();
 8001308:	f001 fcaa 	bl	8002c60 <chDbgCheckClassS>
 800130c:	e00b      	b.n	8001326 <obqGetEmptyBufferTimeoutS+0x26>
 800130e:	69b3      	ldr	r3, [r6, #24]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8001310:	6862      	ldr	r2, [r4, #4]
 8001312:	605a      	str	r2, [r3, #4]
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 8001314:	601c      	str	r4, [r3, #0]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001316:	2004      	movs	r0, #4
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
 8001318:	6013      	str	r3, [r2, #0]
 800131a:	4629      	mov	r1, r5
  tqp->prev                  = tp;
 800131c:	6063      	str	r3, [r4, #4]
 800131e:	f001 fd47 	bl	8002db0 <chSchGoSleepTimeoutS>
  while (obqIsFullI(obqp)) {
    if (obqp->suspended) {
      return MSG_RESET;
    }
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
    if (msg < MSG_OK) {
 8001322:	2800      	cmp	r0, #0
 8001324:	db18      	blt.n	8001358 <obqGetEmptyBufferTimeoutS+0x58>
msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                systime_t timeout) {

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 8001326:	68e3      	ldr	r3, [r4, #12]
 8001328:	b933      	cbnz	r3, 8001338 <obqGetEmptyBufferTimeoutS+0x38>
    if (obqp->suspended) {
 800132a:	7a23      	ldrb	r3, [r4, #8]
 800132c:	b973      	cbnz	r3, 800134c <obqGetEmptyBufferTimeoutS+0x4c>
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 800132e:	2d00      	cmp	r5, #0
 8001330:	d1ed      	bne.n	800130e <obqGetEmptyBufferTimeoutS+0xe>
    return MSG_TIMEOUT;
 8001332:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001336:	bd70      	pop	{r4, r5, r6, pc}
    if (msg < MSG_OK) {
      return msg;
    }
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");
 8001338:	68e3      	ldr	r3, [r4, #12]
 800133a:	b153      	cbz	r3, 8001352 <obqGetEmptyBufferTimeoutS+0x52>

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 800133c:	6922      	ldr	r2, [r4, #16]
  obqp->top = obqp->bwrptr + obqp->bsize;
 800133e:	69e3      	ldr	r3, [r4, #28]
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8001340:	1d11      	adds	r1, r2, #4
  obqp->top = obqp->bwrptr + obqp->bsize;
 8001342:	4413      	add	r3, r2
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8001344:	62a1      	str	r1, [r4, #40]	; 0x28
  obqp->top = obqp->bwrptr + obqp->bsize;
 8001346:	62e3      	str	r3, [r4, #44]	; 0x2c
 8001348:	2000      	movs	r0, #0
 800134a:	bd70      	pop	{r4, r5, r6, pc}

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
    if (obqp->suspended) {
      return MSG_RESET;
 800134c:	f06f 0001 	mvn.w	r0, #1
  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
  obqp->top = obqp->bwrptr + obqp->bsize;

  return MSG_OK;
}
 8001350:	bd70      	pop	{r4, r5, r6, pc}
    if (msg < MSG_OK) {
      return msg;
    }
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");
 8001352:	4803      	ldr	r0, [pc, #12]	; (8001360 <obqGetEmptyBufferTimeoutS+0x60>)
 8001354:	f001 fc64 	bl	8002c20 <chSysHalt>
 8001358:	bd70      	pop	{r4, r5, r6, pc}
 800135a:	bf00      	nop
 800135c:	20001320 	.word	0x20001320
 8001360:	08004dfc 	.word	0x08004dfc
	...

08001370 <ibqGetFullBufferTimeoutS>:
   *                      suspended state.
   *
   * @sclass
   */
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {
 8001370:	b570      	push	{r4, r5, r6, lr}
 8001372:	4604      	mov	r4, r0
 8001374:	460d      	mov	r5, r1
  }

  queue_insert(currp, tqp);
 8001376:	4e15      	ldr	r6, [pc, #84]	; (80013cc <ibqGetFullBufferTimeoutS+0x5c>)

  osalDbgCheckClassS();
 8001378:	f001 fc72 	bl	8002c60 <chDbgCheckClassS>
 800137c:	e00b      	b.n	8001396 <ibqGetFullBufferTimeoutS+0x26>
 800137e:	69b3      	ldr	r3, [r6, #24]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8001380:	6862      	ldr	r2, [r4, #4]
 8001382:	605a      	str	r2, [r3, #4]
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 8001384:	601c      	str	r4, [r3, #0]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001386:	2004      	movs	r0, #4
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
 8001388:	6013      	str	r3, [r2, #0]
 800138a:	4629      	mov	r1, r5
  tqp->prev                  = tp;
 800138c:	6063      	str	r3, [r4, #4]
 800138e:	f001 fd0f 	bl	8002db0 <chSchGoSleepTimeoutS>
  while (ibqIsEmptyI(ibqp)) {
    if (ibqp->suspended) {
      return MSG_RESET;
    }
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
    if (msg < MSG_OK) {
 8001392:	2800      	cmp	r0, #0
 8001394:	db18      	blt.n	80013c8 <ibqGetFullBufferTimeoutS+0x58>
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 8001396:	68e3      	ldr	r3, [r4, #12]
 8001398:	b933      	cbnz	r3, 80013a8 <ibqGetFullBufferTimeoutS+0x38>
    if (ibqp->suspended) {
 800139a:	7a23      	ldrb	r3, [r4, #8]
 800139c:	b973      	cbnz	r3, 80013bc <ibqGetFullBufferTimeoutS+0x4c>
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 800139e:	2d00      	cmp	r5, #0
 80013a0:	d1ed      	bne.n	800137e <ibqGetFullBufferTimeoutS+0xe>
    return MSG_TIMEOUT;
 80013a2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80013a6:	bd70      	pop	{r4, r5, r6, pc}
    if (msg < MSG_OK) {
       return msg;
    }
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 80013a8:	68e3      	ldr	r3, [r4, #12]
 80013aa:	b153      	cbz	r3, 80013c2 <ibqGetFullBufferTimeoutS+0x52>

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 80013ac:	6963      	ldr	r3, [r4, #20]
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 80013ae:	681a      	ldr	r2, [r3, #0]
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 80013b0:	3304      	adds	r3, #4
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 80013b2:	441a      	add	r2, r3
 80013b4:	62e2      	str	r2, [r4, #44]	; 0x2c
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 80013b6:	62a3      	str	r3, [r4, #40]	; 0x28
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 80013b8:	2000      	movs	r0, #0
 80013ba:	bd70      	pop	{r4, r5, r6, pc}

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
    if (ibqp->suspended) {
      return MSG_RESET;
 80013bc:	f06f 0001 	mvn.w	r0, #1
  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);

  return MSG_OK;
}
 80013c0:	bd70      	pop	{r4, r5, r6, pc}
    if (msg < MSG_OK) {
       return msg;
    }
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");
 80013c2:	4803      	ldr	r0, [pc, #12]	; (80013d0 <ibqGetFullBufferTimeoutS+0x60>)
 80013c4:	f001 fc2c 	bl	8002c20 <chSysHalt>
 80013c8:	bd70      	pop	{r4, r5, r6, pc}
 80013ca:	bf00      	nop
 80013cc:	20001320 	.word	0x20001320
 80013d0:	08004e18 	.word	0x08004e18
	...

080013e0 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 80013e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80013e4:	4604      	mov	r4, r0
 80013e6:	460e      	mov	r6, r1
 80013e8:	4615      	mov	r5, r2

  osalDbgCheckClassI();
 80013ea:	f001 fc71 	bl	8002cd0 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 80013ee:	b11c      	cbz	r4, 80013f8 <usbInitEndpointI+0x18>
 80013f0:	b115      	cbz	r5, 80013f8 <usbInitEndpointI+0x18>
  osalDbgAssert(usbp->state == USB_ACTIVE,
 80013f2:	7823      	ldrb	r3, [r4, #0]
 80013f4:	2b04      	cmp	r3, #4
 80013f6:	d002      	beq.n	80013fe <usbInitEndpointI+0x1e>
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {

  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (epcp != NULL));
 80013f8:	485d      	ldr	r0, [pc, #372]	; (8001570 <usbInitEndpointI+0x190>)
 80013fa:	f001 fc11 	bl	8002c20 <chSysHalt>
 80013fe:	fa0f f886 	sxth.w	r8, r6
 8001402:	eb04 0788 	add.w	r7, r4, r8, lsl #2
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");
 8001406:	68f9      	ldr	r1, [r7, #12]
 8001408:	2900      	cmp	r1, #0
 800140a:	d1f5      	bne.n	80013f8 <usbInitEndpointI+0x18>

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 800140c:	60fd      	str	r5, [r7, #12]

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 800140e:	6968      	ldr	r0, [r5, #20]
 8001410:	b110      	cbz	r0, 8001418 <usbInitEndpointI+0x38>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8001412:	2210      	movs	r2, #16
 8001414:	f003 fb60 	bl	8004ad8 <memset>
  }
  if (epcp->out_state != NULL) {
 8001418:	69a8      	ldr	r0, [r5, #24]
 800141a:	b118      	cbz	r0, 8001424 <usbInitEndpointI+0x44>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 800141c:	2100      	movs	r1, #0
 800141e:	2210      	movs	r2, #16
 8001420:	f003 fb5a 	bl	8004ad8 <memset>
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8001424:	68fb      	ldr	r3, [r7, #12]
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 8001426:	6d65      	ldr	r5, [r4, #84]	; 0x54

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8001428:	681a      	ldr	r2, [r3, #0]
 800142a:	f002 0203 	and.w	r2, r2, #3
 800142e:	2a02      	cmp	r2, #2
 8001430:	d05d      	beq.n	80014ee <usbInitEndpointI+0x10e>
 8001432:	2a03      	cmp	r2, #3
 8001434:	d05e      	beq.n	80014f4 <usbInitEndpointI+0x114>
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 8001436:	484f      	ldr	r0, [pc, #316]	; (8001574 <usbInitEndpointI+0x194>)
 8001438:	494f      	ldr	r1, [pc, #316]	; (8001578 <usbInitEndpointI+0x198>)
 800143a:	2a01      	cmp	r2, #1
 800143c:	bf0c      	ite	eq
 800143e:	4681      	moveq	r9, r0
 8001440:	4689      	movne	r9, r1
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 8001442:	0172      	lsls	r2, r6, #5
  if (usbp->epc[ep]->out_state != NULL) {
 8001444:	6999      	ldr	r1, [r3, #24]
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 8001446:	18a8      	adds	r0, r5, r2
 8001448:	f04f 0e00 	mov.w	lr, #0
 800144c:	f8c0 eb10 	str.w	lr, [r0, #2832]	; 0xb10
  if (usbp->epc[ep]->out_state != NULL) {
 8001450:	2900      	cmp	r1, #0
 8001452:	d055      	beq.n	8001500 <usbInitEndpointI+0x120>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8001454:	8a58      	ldrh	r0, [r3, #18]
 8001456:	f106 0158 	add.w	r1, r6, #88	; 0x58
 800145a:	0149      	lsls	r1, r1, #5
 800145c:	ea49 0000 	orr.w	r0, r9, r0
 8001460:	5068      	str	r0, [r5, r1]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8001462:	f106 0e10 	add.w	lr, r6, #16
 8001466:	f8d5 081c 	ldr.w	r0, [r5, #2076]	; 0x81c
 800146a:	2101      	movs	r1, #1
 800146c:	fa01 f10e 	lsl.w	r1, r1, lr
 8001470:	4301      	orrs	r1, r0
 8001472:	f8c5 181c 	str.w	r1, [r5, #2076]	; 0x81c
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 8001476:	442a      	add	r2, r5
  if (usbp->epc[ep]->in_state != NULL) {
 8001478:	6959      	ldr	r1, [r3, #20]
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 800147a:	2000      	movs	r0, #0
 800147c:	f8c2 0910 	str.w	r0, [r2, #2320]	; 0x910
  if (usbp->epc[ep]->in_state != NULL) {
 8001480:	2900      	cmp	r1, #0
 8001482:	d051      	beq.n	8001528 <usbInitEndpointI+0x148>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
 8001484:	8b9a      	ldrh	r2, [r3, #28]

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8001486:	8a19      	ldrh	r1, [r3, #16]
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 8001488:	f8d4 e05c 	ldr.w	lr, [r4, #92]	; 0x5c
  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
 800148c:	2a01      	cmp	r2, #1

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 800148e:	ea4f 0391 	mov.w	r3, r1, lsr #2
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
 8001492:	bf88      	it	hi
 8001494:	4353      	mulhi	r3, r2
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 8001496:	eb03 010e 	add.w	r1, r3, lr
 800149a:	6da2      	ldr	r2, [r4, #88]	; 0x58
 800149c:	65e1      	str	r1, [r4, #92]	; 0x5c
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 800149e:	6852      	ldr	r2, [r2, #4]
 80014a0:	4291      	cmp	r1, r2
 80014a2:	d82a      	bhi.n	80014fa <usbInitEndpointI+0x11a>
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 80014a4:	f106 003f 	add.w	r0, r6, #63	; 0x3f
 80014a8:	6d62      	ldr	r2, [r4, #84]	; 0x54
 80014aa:	eb05 0080 	add.w	r0, r5, r0, lsl #2
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80014ae:	01b1      	lsls	r1, r6, #6
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 80014b0:	ea4e 4303 	orr.w	r3, lr, r3, lsl #16
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80014b4:	f041 0120 	orr.w	r1, r1, #32
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 80014b8:	6043      	str	r3, [r0, #4]
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80014ba:	6111      	str	r1, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 80014bc:	6913      	ldr	r3, [r2, #16]
 80014be:	0699      	lsls	r1, r3, #26
 80014c0:	d4fc      	bmi.n	80014bc <usbInitEndpointI+0xdc>
 80014c2:	2012      	movs	r0, #18
 80014c4:	f001 fb9c 	bl	8002c00 <chSysPolledDelayX>
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 80014c8:	68fb      	ldr	r3, [r7, #12]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 80014ca:	8a1a      	ldrh	r2, [r3, #16]
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 80014cc:	f106 0348 	add.w	r3, r6, #72	; 0x48
 80014d0:	015b      	lsls	r3, r3, #5
 80014d2:	ea42 5286 	orr.w	r2, r2, r6, lsl #22
                           DIEPCTL_TXFNUM(ep) |
 80014d6:	ea42 0209 	orr.w	r2, r2, r9
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 80014da:	50ea      	str	r2, [r5, r3]
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 80014dc:	2301      	movs	r3, #1
 80014de:	f8d5 281c 	ldr.w	r2, [r5, #2076]	; 0x81c
 80014e2:	40b3      	lsls	r3, r6
 80014e4:	4313      	orrs	r3, r2
 80014e6:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
 80014ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    break;
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
    break;
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 80014ee:	f8df 9094 	ldr.w	r9, [pc, #148]	; 8001584 <usbInitEndpointI+0x1a4>
 80014f2:	e7a6      	b.n	8001442 <usbInitEndpointI+0x62>
    break;
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 80014f4:	f8df 9090 	ldr.w	r9, [pc, #144]	; 8001588 <usbInitEndpointI+0x1a8>
 80014f8:	e7a3      	b.n	8001442 <usbInitEndpointI+0x62>
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 80014fa:	4820      	ldr	r0, [pc, #128]	; (800157c <usbInitEndpointI+0x19c>)
 80014fc:	f001 fb90 	bl	8002c20 <chSysHalt>
 8001500:	eb05 1148 	add.w	r1, r5, r8, lsl #5
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8001504:	f106 0e10 	add.w	lr, r6, #16
  if (usbp->epc[ep]->out_state != NULL) {
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8001508:	f8d1 0b00 	ldr.w	r0, [r1, #2816]	; 0xb00
 800150c:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
 8001510:	f8c1 0b00 	str.w	r0, [r1, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8001514:	f8d5 081c 	ldr.w	r0, [r5, #2076]	; 0x81c
 8001518:	2101      	movs	r1, #1
 800151a:	fa01 f10e 	lsl.w	r1, r1, lr
 800151e:	ea20 0101 	bic.w	r1, r0, r1
 8001522:	f8c5 181c 	str.w	r1, [r5, #2076]	; 0x81c
 8001526:	e7a6      	b.n	8001476 <usbInitEndpointI+0x96>
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8001528:	f106 033f 	add.w	r3, r6, #63	; 0x3f
 800152c:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800152e:	4814      	ldr	r0, [pc, #80]	; (8001580 <usbInitEndpointI+0x1a0>)
 8001530:	eb05 0383 	add.w	r3, r5, r3, lsl #2
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8001534:	01b1      	lsls	r1, r6, #6
 8001536:	f041 0120 	orr.w	r1, r1, #32
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 800153a:	6058      	str	r0, [r3, #4]
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800153c:	6111      	str	r1, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 800153e:	6913      	ldr	r3, [r2, #16]
 8001540:	069b      	lsls	r3, r3, #26
 8001542:	d4fc      	bmi.n	800153e <usbInitEndpointI+0x15e>
 8001544:	eb05 1848 	add.w	r8, r5, r8, lsl #5
 8001548:	2012      	movs	r0, #18
 800154a:	f001 fb59 	bl	8002c00 <chSysPolledDelayX>
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
    otg_txfifo_flush(usbp, ep);
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 800154e:	f8d8 2900 	ldr.w	r2, [r8, #2304]	; 0x900
 8001552:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001556:	f8c8 2900 	str.w	r2, [r8, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 800155a:	f8d5 281c 	ldr.w	r2, [r5, #2076]	; 0x81c
 800155e:	2301      	movs	r3, #1
 8001560:	40b3      	lsls	r3, r6
 8001562:	ea22 0303 	bic.w	r3, r2, r3
 8001566:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
 800156a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800156e:	bf00      	nop
 8001570:	08004d8c 	.word	0x08004d8c
 8001574:	10048000 	.word	0x10048000
 8001578:	10008000 	.word	0x10008000
 800157c:	080052f4 	.word	0x080052f4
 8001580:	02000400 	.word	0x02000400
 8001584:	10088000 	.word	0x10088000
 8001588:	100c8000 	.word	0x100c8000
 800158c:	00000000 	.word	0x00000000

08001590 <sdu_start_receive.lto_priv.78>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static bool sdu_start_receive(SerialUSBDriver *sdup) {
 8001590:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint8_t *buf;

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8001592:	f8d0 648c 	ldr.w	r6, [r0, #1164]	; 0x48c
 8001596:	6837      	ldr	r7, [r6, #0]
 8001598:	783b      	ldrb	r3, [r7, #0]
 800159a:	2b04      	cmp	r3, #4
 800159c:	d001      	beq.n	80015a2 <sdu_start_receive.lto_priv.78+0x12>
      (sdup->state != SDU_READY)) {
    return true;
 800159e:	2001      	movs	r0, #1
 80015a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
static bool sdu_start_receive(SerialUSBDriver *sdup) {
  uint8_t *buf;

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80015a2:	7a03      	ldrb	r3, [r0, #8]
 80015a4:	2b02      	cmp	r3, #2
 80015a6:	d1fa      	bne.n	800159e <sdu_start_receive.lto_priv.78+0xe>
      (sdup->state != SDU_READY)) {
    return true;
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 80015a8:	7932      	ldrb	r2, [r6, #4]
 80015aa:	897b      	ldrh	r3, [r7, #10]
 80015ac:	2501      	movs	r5, #1
 80015ae:	fa05 f202 	lsl.w	r2, r5, r2
 80015b2:	421a      	tst	r2, r3
 80015b4:	d1f3      	bne.n	800159e <sdu_start_receive.lto_priv.78+0xe>
 80015b6:	4604      	mov	r4, r0
 *
 * @iclass
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();
 80015b8:	f001 fb8a 	bl	8002cd0 <chDbgCheckClassI>

  if (ibqIsFullI(ibqp)) {
 80015bc:	69e2      	ldr	r2, [r4, #28]
 80015be:	6a23      	ldr	r3, [r4, #32]
 80015c0:	429a      	cmp	r2, r3
 80015c2:	d009      	beq.n	80015d8 <sdu_start_receive.lto_priv.78+0x48>
    return true;
  }

  /* Checking if there is a buffer ready for incoming data.*/
  buf = ibqGetEmptyBufferI(&sdup->ibqueue);
  if (buf == NULL) {
 80015c4:	3204      	adds	r2, #4
 80015c6:	d0ea      	beq.n	800159e <sdu_start_receive.lto_priv.78+0xe>
    return true;
  }

  /* Buffer found, starting a new transaction.*/
  usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out,
 80015c8:	4638      	mov	r0, r7
 80015ca:	7971      	ldrb	r1, [r6, #5]
 80015cc:	f44f 7380 	mov.w	r3, #256	; 0x100
 80015d0:	f000 ffd6 	bl	8002580 <usbStartReceiveI>
                   buf, SERIAL_USB_BUFFERS_SIZE);

  return false;
 80015d4:	2000      	movs	r0, #0
 80015d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80015d8:	69a3      	ldr	r3, [r4, #24]
 80015da:	2b00      	cmp	r3, #0
 80015dc:	d1df      	bne.n	800159e <sdu_start_receive.lto_priv.78+0xe>
 80015de:	e7f1      	b.n	80015c4 <sdu_start_receive.lto_priv.78+0x34>

080015e0 <ibnotify.lto_priv.62>:
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void ibnotify(io_buffers_queue_t *bqp) {
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
  (void) sdu_start_receive(sdup);
 80015e0:	6b40      	ldr	r0, [r0, #52]	; 0x34
 80015e2:	f7ff bfd5 	b.w	8001590 <sdu_start_receive.lto_priv.78>
 80015e6:	bf00      	nop
	...

080015f0 <obqGetFullBufferI>:
 * @retval NULL         if the queue is empty.
 *
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {
 80015f0:	b538      	push	{r3, r4, r5, lr}
 80015f2:	4604      	mov	r4, r0
 80015f4:	460d      	mov	r5, r1

  osalDbgCheckClassI();
 80015f6:	f001 fb6b 	bl	8002cd0 <chDbgCheckClassI>

  if (obqIsEmptyI(obqp)) {
 80015fa:	6963      	ldr	r3, [r4, #20]
 80015fc:	6922      	ldr	r2, [r4, #16]
 80015fe:	429a      	cmp	r2, r3
 8001600:	d004      	beq.n	800160c <obqGetFullBufferI+0x1c>
    return NULL;
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 8001602:	4618      	mov	r0, r3
 8001604:	f850 3b04 	ldr.w	r3, [r0], #4
 8001608:	602b      	str	r3, [r5, #0]

  return obqp->brdptr + sizeof (size_t);
}
 800160a:	bd38      	pop	{r3, r4, r5, pc}
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {

  osalDbgCheckClassI();

  if (obqIsEmptyI(obqp)) {
 800160c:	68e2      	ldr	r2, [r4, #12]
 800160e:	2a00      	cmp	r2, #0
 8001610:	d0f7      	beq.n	8001602 <obqGetFullBufferI+0x12>
    return NULL;
 8001612:	2000      	movs	r0, #0
 8001614:	bd38      	pop	{r3, r4, r5, pc}
 8001616:	bf00      	nop
	...

08001620 <obnotify.lto_priv.63>:
/**
 * @brief   Notification of filled buffer inserted into the output buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void obnotify(io_buffers_queue_t *bqp) {
 8001620:	b510      	push	{r4, lr}
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);
 8001622:	6b44      	ldr	r4, [r0, #52]	; 0x34

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8001624:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 8001628:	6813      	ldr	r3, [r2, #0]
 800162a:	7819      	ldrb	r1, [r3, #0]
 800162c:	2904      	cmp	r1, #4
/**
 * @brief   Notification of filled buffer inserted into the output buffers queue.
 *
 * @param[in] bqp       the buffers queue pointer.
 */
static void obnotify(io_buffers_queue_t *bqp) {
 800162e:	b082      	sub	sp, #8
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8001630:	d001      	beq.n	8001636 <obnotify.lto_priv.63+0x16>
    if (buf != NULL) {
      /* Buffer found, starting a new transaction.*/
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
    }
  }
}
 8001632:	b002      	add	sp, #8
 8001634:	bd10      	pop	{r4, pc}
  size_t n;
  SerialUSBDriver *sdup = bqGetLinkX(bqp);

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8001636:	7a21      	ldrb	r1, [r4, #8]
 8001638:	2902      	cmp	r1, #2
 800163a:	d1fa      	bne.n	8001632 <obnotify.lto_priv.63+0x12>
      (sdup->state != SDU_READY)) {
    return;
  }

  /* Checking if there is already a transaction ongoing on the endpoint.*/
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 800163c:	7911      	ldrb	r1, [r2, #4]
 800163e:	891a      	ldrh	r2, [r3, #8]
 8001640:	2301      	movs	r3, #1
 8001642:	408b      	lsls	r3, r1
 8001644:	4213      	tst	r3, r2
 8001646:	d1f4      	bne.n	8001632 <obnotify.lto_priv.63+0x12>
    /* Trying to get a full buffer.*/
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8001648:	f104 0044 	add.w	r0, r4, #68	; 0x44
 800164c:	a901      	add	r1, sp, #4
 800164e:	f7ff ffcf 	bl	80015f0 <obqGetFullBufferI>
    if (buf != NULL) {
 8001652:	4602      	mov	r2, r0
 8001654:	2800      	cmp	r0, #0
 8001656:	d0ec      	beq.n	8001632 <obnotify.lto_priv.63+0x12>
      /* Buffer found, starting a new transaction.*/
      usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 8001658:	f8d4 148c 	ldr.w	r1, [r4, #1164]	; 0x48c
 800165c:	9b01      	ldr	r3, [sp, #4]
 800165e:	6808      	ldr	r0, [r1, #0]
 8001660:	7909      	ldrb	r1, [r1, #4]
 8001662:	f000 ff1d 	bl	80024a0 <usbStartTransmitI>
 8001666:	e7e4      	b.n	8001632 <obnotify.lto_priv.63+0x12>
	...

08001670 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8001670:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8001672:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001676:	68da      	ldr	r2, [r3, #12]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8001678:	0792      	lsls	r2, r2, #30
 800167a:	d501      	bpl.n	8001680 <stSetAlarm+0x10>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800167c:	6358      	str	r0, [r3, #52]	; 0x34
 800167e:	bd08      	pop	{r3, pc}
 8001680:	4801      	ldr	r0, [pc, #4]	; (8001688 <stSetAlarm+0x18>)
 8001682:	f001 facd 	bl	8002c20 <chSysHalt>
 8001686:	bf00      	nop
 8001688:	08004de4 	.word	0x08004de4
 800168c:	00000000 	.word	0x00000000

08001690 <_port_irq_epilogue>:
 8001690:	2320      	movs	r3, #32
 8001692:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8001696:	4b12      	ldr	r3, [pc, #72]	; (80016e0 <_port_irq_epilogue+0x50>)
 8001698:	685b      	ldr	r3, [r3, #4]
 800169a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800169e:	d102      	bne.n	80016a6 <_port_irq_epilogue+0x16>
 80016a0:	f383 8811 	msr	BASEPRI, r3
 80016a4:	4770      	bx	lr
#if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
  uint32_t result;

  /* Empty asm statement works as a scheduling barrier */
  __ASM volatile ("");
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 80016a6:	eef1 3a10 	vmrs	r3, fpscr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80016aa:	f3ef 8309 	mrs	r3, PSP
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80016ae:	4a0d      	ldr	r2, [pc, #52]	; (80016e4 <_port_irq_epilogue+0x54>)
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80016b0:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80016b4:	68d2      	ldr	r2, [r2, #12]
 80016b6:	f843 2c08 	str.w	r2, [r3, #-8]
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80016ba:	f843 1c4c 	str.w	r1, [r3, #-76]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80016be:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80016c2:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80016c6:	4a08      	ldr	r2, [pc, #32]	; (80016e8 <_port_irq_epilogue+0x58>)
 80016c8:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 80016ca:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80016cc:	6889      	ldr	r1, [r1, #8]
 80016ce:	6892      	ldr	r2, [r2, #8]
 80016d0:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80016d2:	bf8c      	ite	hi
 80016d4:	4a05      	ldrhi	r2, [pc, #20]	; (80016ec <_port_irq_epilogue+0x5c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80016d6:	4a06      	ldrls	r2, [pc, #24]	; (80016f0 <_port_irq_epilogue+0x60>)
 80016d8:	f843 2c50 	str.w	r2, [r3, #-80]
 80016dc:	4770      	bx	lr
 80016de:	bf00      	nop
 80016e0:	e000ed00 	.word	0xe000ed00
 80016e4:	e000ef30 	.word	0xe000ef30
 80016e8:	20001320 	.word	0x20001320
 80016ec:	08000309 	.word	0x08000309
 80016f0:	08000314 	.word	0x08000314
	...

08001700 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8001700:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001704:	4606      	mov	r6, r0
 8001706:	4688      	mov	r8, r1
  event_listener_t *elp;

  chDbgCheckClassI();
 8001708:	f001 fae2 	bl	8002cd0 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 800170c:	2e00      	cmp	r6, #0
 800170e:	d039      	beq.n	8001784 <chEvtBroadcastFlagsI+0x84>

  elp = esp->next;
 8001710:	6834      	ldr	r4, [r6, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8001712:	42a6      	cmp	r6, r4
 8001714:	d029      	beq.n	800176a <chEvtBroadcastFlagsI+0x6a>
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8001716:	2700      	movs	r7, #0
 8001718:	e002      	b.n	8001720 <chEvtBroadcastFlagsI+0x20>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 800171a:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800171c:	42a6      	cmp	r6, r4
 800171e:	d024      	beq.n	800176a <chEvtBroadcastFlagsI+0x6a>
  /*lint -restore*/
    elp->flags |= flags;
 8001720:	68e3      	ldr	r3, [r4, #12]
 8001722:	ea48 0303 	orr.w	r3, r8, r3
 8001726:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8001728:	f1b8 0f00 	cmp.w	r8, #0
 800172c:	d002      	beq.n	8001734 <chEvtBroadcastFlagsI+0x34>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
 800172e:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8001730:	4213      	tst	r3, r2
 8001732:	d0f2      	beq.n	800171a <chEvtBroadcastFlagsI+0x1a>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
 8001734:	6865      	ldr	r5, [r4, #4]
 8001736:	f8d4 9008 	ldr.w	r9, [r4, #8]
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
 800173a:	f001 fac9 	bl	8002cd0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800173e:	b1f5      	cbz	r5, 800177e <chEvtBroadcastFlagsI+0x7e>

  tp->epending |= events;
 8001740:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8001742:	f895 2020 	ldrb.w	r2, [r5, #32]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8001746:	ea49 0303 	orr.w	r3, r9, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 800174a:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 800174c:	636b      	str	r3, [r5, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 800174e:	d00e      	beq.n	800176e <chEvtBroadcastFlagsI+0x6e>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8001750:	2a0b      	cmp	r2, #11
 8001752:	d1e2      	bne.n	800171a <chEvtBroadcastFlagsI+0x1a>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8001754:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8001756:	4013      	ands	r3, r2

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
 8001758:	429a      	cmp	r2, r3
 800175a:	d1de      	bne.n	800171a <chEvtBroadcastFlagsI+0x1a>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 800175c:	626f      	str	r7, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 800175e:	4628      	mov	r0, r5
 8001760:	f001 fc56 	bl	8003010 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 8001764:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8001766:	42a6      	cmp	r6, r4
 8001768:	d1da      	bne.n	8001720 <chEvtBroadcastFlagsI+0x20>
 800176a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 800176e:	6a6a      	ldr	r2, [r5, #36]	; 0x24
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8001770:	4213      	tst	r3, r2
 8001772:	d0d2      	beq.n	800171a <chEvtBroadcastFlagsI+0x1a>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 8001774:	626f      	str	r7, [r5, #36]	; 0x24
    (void) chSchReadyI(tp);
 8001776:	4628      	mov	r0, r5
 8001778:	f001 fc4a 	bl	8003010 <chSchReadyI>
 800177c:	e7f2      	b.n	8001764 <chEvtBroadcastFlagsI+0x64>
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 800177e:	4803      	ldr	r0, [pc, #12]	; (800178c <chEvtBroadcastFlagsI+0x8c>)
 8001780:	f001 fa4e 	bl	8002c20 <chSysHalt>
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);
 8001784:	4802      	ldr	r0, [pc, #8]	; (8001790 <chEvtBroadcastFlagsI+0x90>)
 8001786:	f001 fa4b 	bl	8002c20 <chSysHalt>
 800178a:	bf00      	nop
 800178c:	08004e34 	.word	0x08004e34
 8001790:	08004da0 	.word	0x08004da0
	...

080017a0 <sduDataReceived>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        OUT endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 80017a0:	3109      	adds	r1, #9
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        OUT endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 80017a2:	b538      	push	{r3, r4, r5, lr}
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 80017a4:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
  if (sdup == NULL) {
 80017a8:	2c00      	cmp	r4, #0
 80017aa:	d03d      	beq.n	8001828 <sduDataReceived+0x88>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80017ac:	2320      	movs	r3, #32
 80017ae:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80017b2:	f001 fcb5 	bl	8003120 <_dbg_check_lock_from_isr>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80017b6:	1d20      	adds	r0, r4, #4
 80017b8:	2104      	movs	r1, #4
 80017ba:	f7ff ffa1 	bl	8001700 <chEvtBroadcastFlagsI>
  /* Signaling that data is available in the input queue.*/
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);

  /* Posting the filled buffer in the queue.*/
  ibqPostFullBufferI(&sdup->ibqueue,
                     usbGetReceiveTransactionSizeX(sdup->config->usbp,
 80017be:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 80017c2:	6813      	ldr	r3, [r2, #0]
 80017c4:	7952      	ldrb	r2, [r2, #5]
 80017c6:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80017ca:	68db      	ldr	r3, [r3, #12]

  /* Signaling that data is available in the input queue.*/
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);

  /* Posting the filled buffer in the queue.*/
  ibqPostFullBufferI(&sdup->ibqueue,
 80017cc:	699b      	ldr	r3, [r3, #24]
 80017ce:	685d      	ldr	r5, [r3, #4]
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {

  osalDbgCheckClassI();
 80017d0:	f001 fa7e 	bl	8002cd0 <chDbgCheckClassI>

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 80017d4:	b32d      	cbz	r5, 8001822 <sduDataReceived+0x82>
 80017d6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80017d8:	3b04      	subs	r3, #4
 80017da:	429d      	cmp	r5, r3
 80017dc:	d821      	bhi.n	8001822 <sduDataReceived+0x82>
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 80017de:	69e2      	ldr	r2, [r4, #28]
 80017e0:	6a23      	ldr	r3, [r4, #32]
 80017e2:	429a      	cmp	r2, r3
 80017e4:	d01a      	beq.n	800181c <sduDataReceived+0x7c>

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 80017e6:	6015      	str	r5, [r2, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
  ibqp->bwrptr += ibqp->bsize;
 80017e8:	6aa3      	ldr	r3, [r4, #40]	; 0x28

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 80017ea:	69a1      	ldr	r1, [r4, #24]
  ibqp->bwrptr += ibqp->bsize;
  if (ibqp->bwrptr >= ibqp->btop) {
 80017ec:	6a60      	ldr	r0, [r4, #36]	; 0x24
  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
  ibqp->bwrptr += ibqp->bsize;
 80017ee:	4413      	add	r3, r2

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 80017f0:	3101      	adds	r1, #1
  ibqp->bwrptr += ibqp->bsize;
  if (ibqp->bwrptr >= ibqp->btop) {
 80017f2:	4283      	cmp	r3, r0

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 80017f4:	61a1      	str	r1, [r4, #24]
  ibqp->bwrptr += ibqp->bsize;
 80017f6:	61e3      	str	r3, [r4, #28]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 80017f8:	68e0      	ldr	r0, [r4, #12]
  if (ibqp->bwrptr >= ibqp->btop) {
 80017fa:	d301      	bcc.n	8001800 <sduDataReceived+0x60>
    ibqp->bwrptr = ibqp->buffers;
 80017fc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80017fe:	61e3      	str	r3, [r4, #28]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&ibqp->waiting, MSG_OK);
 8001800:	f104 030c 	add.w	r3, r4, #12
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8001804:	4298      	cmp	r0, r3
 8001806:	d014      	beq.n	8001832 <sduDataReceived+0x92>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8001808:	6802      	ldr	r2, [r0, #0]
 800180a:	60e2      	str	r2, [r4, #12]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 800180c:	f890 1020 	ldrb.w	r1, [r0, #32]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001810:	6053      	str	r3, [r2, #4]
 8001812:	2904      	cmp	r1, #4
 8001814:	d009      	beq.n	800182a <sduDataReceived+0x8a>
 8001816:	480b      	ldr	r0, [pc, #44]	; (8001844 <sduDataReceived+0xa4>)
 8001818:	f001 fa02 	bl	8002c20 <chSysHalt>
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {

  osalDbgCheckClassI();

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");
 800181c:	69a3      	ldr	r3, [r4, #24]
 800181e:	2b00      	cmp	r3, #0
 8001820:	d0e1      	beq.n	80017e6 <sduDataReceived+0x46>
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {

  osalDbgCheckClassI();

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
 8001822:	4809      	ldr	r0, [pc, #36]	; (8001848 <sduDataReceived+0xa8>)
 8001824:	f001 f9fc 	bl	8002c20 <chSysHalt>
 8001828:	bd38      	pop	{r3, r4, r5, pc}

  tp->u.rdymsg = msg;
 800182a:	2300      	movs	r3, #0
 800182c:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 800182e:	f001 fbef 	bl	8003010 <chSchReadyI>
                                                   sdup->config->bulk_out));

  /* The endpoint cannot be busy, we are in the context of the callback,
     so a packet is in the buffer for sure. Trying to get a free buffer
     for the next transaction.*/
  (void) sdu_start_receive(sdup);
 8001832:	4620      	mov	r0, r4
 8001834:	f7ff feac 	bl	8001590 <sdu_start_receive.lto_priv.78>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8001838:	f001 fc5a 	bl	80030f0 <_dbg_check_unlock_from_isr>
 800183c:	2300      	movs	r3, #0
 800183e:	f383 8811 	msr	BASEPRI, r3
 8001842:	bd38      	pop	{r3, r4, r5, pc}
 8001844:	080053c4 	.word	0x080053c4
 8001848:	08004dd0 	.word	0x08004dd0
 800184c:	00000000 	.word	0x00000000

08001850 <sduDataTransmitted>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        IN endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8001850:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8001854:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        IN endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8001858:	b082      	sub	sp, #8
  uint8_t *buf;
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 800185a:	699c      	ldr	r4, [r3, #24]

  if (sdup == NULL) {
 800185c:	b314      	cbz	r4, 80018a4 <sduDataTransmitted+0x54>
 800185e:	460e      	mov	r6, r1
 8001860:	4605      	mov	r5, r0
 8001862:	2320      	movs	r3, #32
 8001864:	f383 8811 	msr	BASEPRI, r3
 8001868:	eb00 0781 	add.w	r7, r0, r1, lsl #2
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800186c:	f001 fc58 	bl	8003120 <_dbg_check_lock_from_isr>
 8001870:	1d20      	adds	r0, r4, #4
 8001872:	2108      	movs	r1, #8
 8001874:	f7ff ff44 	bl	8001700 <chEvtBroadcastFlagsI>

  /* Signaling that space is available in the output queue.*/
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);

  /* Freeing the buffer just transmitted, if it was not a zero size packet.*/
  if (usbp->epc[ep]->in_state->txsize > 0U) {
 8001878:	68fb      	ldr	r3, [r7, #12]
 800187a:	695b      	ldr	r3, [r3, #20]
 800187c:	681b      	ldr	r3, [r3, #0]
 800187e:	b9a3      	cbnz	r3, 80018aa <sduDataTransmitted+0x5a>
 8001880:	f104 0844 	add.w	r8, r4, #68	; 0x44
    obqReleaseEmptyBufferI(&sdup->obqueue);
  }

  /* Checking if there is a buffer ready for transmission.*/
  buf = obqGetFullBufferI(&sdup->obqueue, &n);
 8001884:	4640      	mov	r0, r8
 8001886:	a901      	add	r1, sp, #4
 8001888:	f7ff feb2 	bl	80015f0 <obqGetFullBufferI>

  if (buf != NULL) {
 800188c:	4602      	mov	r2, r0
 800188e:	b368      	cbz	r0, 80018ec <sduDataTransmitted+0x9c>
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
 8001890:	4628      	mov	r0, r5
 8001892:	4631      	mov	r1, r6
 8001894:	9b01      	ldr	r3, [sp, #4]
 8001896:	f000 fe03 	bl	80024a0 <usbStartTransmitI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800189a:	f001 fc29 	bl	80030f0 <_dbg_check_unlock_from_isr>
 800189e:	2300      	movs	r3, #0
 80018a0:	f383 8811 	msr	BASEPRI, r3
  else {
    /* Nothing to transmit.*/
  }

  osalSysUnlockFromISR();
}
 80018a4:	b002      	add	sp, #8
 80018a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();
 80018aa:	f001 fa11 	bl	8002cd0 <chDbgCheckClassI>
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 80018ae:	6da0      	ldr	r0, [r4, #88]	; 0x58
 80018b0:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80018b2:	4283      	cmp	r3, r0
 80018b4:	d02a      	beq.n	800190c <sduDataTransmitted+0xbc>

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
  obqp->brdptr += obqp->bsize;
 80018b6:	6e23      	ldr	r3, [r4, #96]	; 0x60

  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 80018b8:	6d22      	ldr	r2, [r4, #80]	; 0x50
  obqp->brdptr += obqp->bsize;
  if (obqp->brdptr >= obqp->btop) {
 80018ba:	6de1      	ldr	r1, [r4, #92]	; 0x5c
  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
  obqp->brdptr += obqp->bsize;
 80018bc:	4403      	add	r3, r0

  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 80018be:	3201      	adds	r2, #1
  obqp->brdptr += obqp->bsize;
  if (obqp->brdptr >= obqp->btop) {
 80018c0:	428b      	cmp	r3, r1

  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 80018c2:	6522      	str	r2, [r4, #80]	; 0x50
  obqp->brdptr += obqp->bsize;
 80018c4:	65a3      	str	r3, [r4, #88]	; 0x58
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 80018c6:	6c60      	ldr	r0, [r4, #68]	; 0x44
  if (obqp->brdptr >= obqp->btop) {
 80018c8:	d301      	bcc.n	80018ce <sduDataTransmitted+0x7e>
    obqp->brdptr = obqp->buffers;
 80018ca:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 80018cc:	65a3      	str	r3, [r4, #88]	; 0x58
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
 80018ce:	f104 0844 	add.w	r8, r4, #68	; 0x44
 80018d2:	4540      	cmp	r0, r8
 80018d4:	d0d6      	beq.n	8001884 <sduDataTransmitted+0x34>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80018d6:	6803      	ldr	r3, [r0, #0]
 80018d8:	6463      	str	r3, [r4, #68]	; 0x44

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 80018da:	f890 2020 	ldrb.w	r2, [r0, #32]
  tqp->next->queue.prev = (thread_t *)tqp;
 80018de:	f8c3 8004 	str.w	r8, [r3, #4]
 80018e2:	2a04      	cmp	r2, #4
 80018e4:	d018      	beq.n	8001918 <sduDataTransmitted+0xc8>
 80018e6:	480f      	ldr	r0, [pc, #60]	; (8001924 <sduDataTransmitted+0xd4>)
 80018e8:	f001 f99a 	bl	8002c20 <chSysHalt>
  if (buf != NULL) {
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 80018ec:	68fb      	ldr	r3, [r7, #12]
 80018ee:	695a      	ldr	r2, [r3, #20]
 80018f0:	6812      	ldr	r2, [r2, #0]
 80018f2:	2a00      	cmp	r2, #0
 80018f4:	d0d1      	beq.n	800189a <sduDataTransmitted+0x4a>
           ((usbp->epc[ep]->in_state->txsize &
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 80018f6:	8a1b      	ldrh	r3, [r3, #16]
 80018f8:	3b01      	subs	r3, #1
  if (buf != NULL) {
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    usbStartTransmitI(usbp, ep, buf, n);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 80018fa:	4013      	ands	r3, r2
 80018fc:	d1cd      	bne.n	800189a <sduDataTransmitted+0x4a>
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
    /* Transmit zero sized packet in case the last one has maximum allowed
       size. Otherwise the recipient may expect more data coming soon and
       not return buffered data to app. See section 5.8.3 Bulk Transfer
       Packet Size Constraints of the USB Specification document.*/
    usbStartTransmitI(usbp, ep, usbp->setup, 0);
 80018fe:	4631      	mov	r1, r6
 8001900:	4628      	mov	r0, r5
 8001902:	f105 0244 	add.w	r2, r5, #68	; 0x44
 8001906:	f000 fdcb 	bl	80024a0 <usbStartTransmitI>
 800190a:	e7c6      	b.n	800189a <sduDataTransmitted+0x4a>
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");
 800190c:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800190e:	2b00      	cmp	r3, #0
 8001910:	d0d1      	beq.n	80018b6 <sduDataTransmitted+0x66>
 8001912:	4805      	ldr	r0, [pc, #20]	; (8001928 <sduDataTransmitted+0xd8>)
 8001914:	f001 f984 	bl	8002c20 <chSysHalt>

  tp->u.rdymsg = msg;
 8001918:	2300      	movs	r3, #0
 800191a:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 800191c:	f001 fb78 	bl	8003010 <chSchReadyI>
 8001920:	e7b0      	b.n	8001884 <sduDataTransmitted+0x34>
 8001922:	bf00      	nop
 8001924:	080053c4 	.word	0x080053c4
 8001928:	08004db8 	.word	0x08004db8
 800192c:	00000000 	.word	0x00000000

08001930 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
 8001930:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t w = 0;
  systime_t deadline;

  osalDbgCheck(n > 0U);
 8001934:	4616      	mov	r6, r2
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
 8001936:	b085      	sub	sp, #20
  size_t w = 0;
  systime_t deadline;

  osalDbgCheck(n > 0U);
 8001938:	2a00      	cmp	r2, #0
 800193a:	f000 8085 	beq.w	8001a48 <obqWriteTimeout+0x118>
 800193e:	461f      	mov	r7, r3
 8001940:	4682      	mov	sl, r0
 8001942:	468b      	mov	fp, r1
 8001944:	2320      	movs	r3, #32
 8001946:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800194a:	f001 fc61 	bl	8003210 <_dbg_check_lock>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800194e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001952:	4d4a      	ldr	r5, [pc, #296]	; (8001a7c <obqWriteTimeout+0x14c>)
 8001954:	6a5a      	ldr	r2, [r3, #36]	; 0x24

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 8001956:	f8da 0028 	ldr.w	r0, [sl, #40]	; 0x28
 800195a:	9303      	str	r3, [sp, #12]
  osalDbgCheck(n > 0U);

  osalSysLock();

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 800195c:	18bb      	adds	r3, r7, r2
 800195e:	9302      	str	r3, [sp, #8]
    if (obqp->ptr == NULL) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8001960:	1e7b      	subs	r3, r7, #1
 8001962:	9301      	str	r3, [sp, #4]

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001964:	46a8      	mov	r8, r5
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
  size_t w = 0;
 8001966:	2400      	movs	r4, #0

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 8001968:	2800      	cmp	r0, #0
 800196a:	d05a      	beq.n	8001a22 <obqWriteTimeout+0xf2>
        return w;
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 800196c:	f8da 302c 	ldr.w	r3, [sl, #44]	; 0x2c
    if (size > (n - w)) {
 8001970:	ebc4 0906 	rsb	r9, r4, r6
        return w;
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 8001974:	1a1b      	subs	r3, r3, r0
 8001976:	4599      	cmp	r9, r3
 8001978:	bf28      	it	cs
 800197a:	4699      	movcs	r9, r3
      size = n - w;
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 800197c:	f1b9 0f40 	cmp.w	r9, #64	; 0x40
 8001980:	d927      	bls.n	80019d2 <obqWriteTimeout+0xa2>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
 8001982:	f10b 0340 	add.w	r3, fp, #64	; 0x40
 8001986:	f8db e000 	ldr.w	lr, [fp]
 800198a:	f8db 1004 	ldr.w	r1, [fp, #4]
 800198e:	f8db 2008 	ldr.w	r2, [fp, #8]
 8001992:	f8db c00c 	ldr.w	ip, [fp, #12]
 8001996:	f8c0 c00c 	str.w	ip, [r0, #12]
 800199a:	f10b 0b10 	add.w	fp, fp, #16
 800199e:	459b      	cmp	fp, r3
 80019a0:	f8c0 e000 	str.w	lr, [r0]
 80019a4:	6041      	str	r1, [r0, #4]
 80019a6:	6082      	str	r2, [r0, #8]
 80019a8:	f100 0010 	add.w	r0, r0, #16
 80019ac:	d1eb      	bne.n	8001986 <obqWriteTimeout+0x56>
      bp        += 64U;
      obqp->ptr += 64U;
 80019ae:	f8da 3028 	ldr.w	r3, [sl, #40]	; 0x28
      obqp->ptr += size;
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 80019b2:	f8da 202c 	ldr.w	r2, [sl, #44]	; 0x2c
       this impacts throughput however.*/
    if (size > 64U) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
      bp        += 64U;
      obqp->ptr += 64U;
 80019b6:	3340      	adds	r3, #64	; 0x40
      obqp->ptr += size;
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 80019b8:	429a      	cmp	r2, r3
    if (size > 64U) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
      bp        += 64U;
      obqp->ptr += 64U;
      w         += 64U;
 80019ba:	f104 0440 	add.w	r4, r4, #64	; 0x40
       this impacts throughput however.*/
    if (size > 64U) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
      bp        += 64U;
      obqp->ptr += 64U;
 80019be:	f8ca 3028 	str.w	r3, [sl, #40]	; 0x28
      obqp->ptr += size;
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 80019c2:	d815      	bhi.n	80019f0 <obqWriteTimeout+0xc0>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 80019c4:	f8da 101c 	ldr.w	r1, [sl, #28]
 80019c8:	4650      	mov	r0, sl
 80019ca:	3904      	subs	r1, #4
 80019cc:	f7ff fc50 	bl	8001270 <obqPostFullBufferS>
 80019d0:	e00e      	b.n	80019f0 <obqWriteTimeout+0xc0>
      bp        += 64U;
      obqp->ptr += 64U;
      w         += 64U;
    }
    else {
      memcpy(obqp->ptr, bp, size);
 80019d2:	4659      	mov	r1, fp
 80019d4:	464a      	mov	r2, r9
 80019d6:	f7fe fc9f 	bl	8000318 <memcpy>
      bp        += size;
      obqp->ptr += size;
 80019da:	f8da 3028 	ldr.w	r3, [sl, #40]	; 0x28
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 80019de:	f8da 202c 	ldr.w	r2, [sl, #44]	; 0x2c
      w         += 64U;
    }
    else {
      memcpy(obqp->ptr, bp, size);
      bp        += size;
      obqp->ptr += size;
 80019e2:	444b      	add	r3, r9
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 80019e4:	429a      	cmp	r2, r3
    }
    else {
      memcpy(obqp->ptr, bp, size);
      bp        += size;
      obqp->ptr += size;
      w         += size;
 80019e6:	444c      	add	r4, r9
      obqp->ptr += 64U;
      w         += 64U;
    }
    else {
      memcpy(obqp->ptr, bp, size);
      bp        += size;
 80019e8:	44cb      	add	fp, r9
      obqp->ptr += size;
 80019ea:	f8ca 3028 	str.w	r3, [sl, #40]	; 0x28
      w         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 80019ee:	d9e9      	bls.n	80019c4 <obqWriteTimeout+0x94>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80019f0:	f001 fbe6 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80019f4:	682b      	ldr	r3, [r5, #0]
 80019f6:	42ab      	cmp	r3, r5
 80019f8:	d005      	beq.n	8001a06 <obqWriteTimeout+0xd6>
 80019fa:	f8d8 2018 	ldr.w	r2, [r8, #24]
 80019fe:	689b      	ldr	r3, [r3, #8]
 8001a00:	6892      	ldr	r2, [r2, #8]
 8001a02:	429a      	cmp	r2, r3
 8001a04:	d31d      	bcc.n	8001a42 <obqWriteTimeout+0x112>
 8001a06:	2300      	movs	r3, #0
 8001a08:	f383 8811 	msr	BASEPRI, r3
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
    if (w >= n) {
 8001a0c:	42b4      	cmp	r4, r6
 8001a0e:	d231      	bcs.n	8001a74 <obqWriteTimeout+0x144>
 8001a10:	2320      	movs	r3, #32
 8001a12:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001a16:	f001 fbfb 	bl	8003210 <_dbg_check_lock>

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 8001a1a:	f8da 0028 	ldr.w	r0, [sl, #40]	; 0x28
 8001a1e:	2800      	cmp	r0, #0
 8001a20:	d1a4      	bne.n	800196c <obqWriteTimeout+0x3c>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8001a22:	9b01      	ldr	r3, [sp, #4]
 8001a24:	3303      	adds	r3, #3
 8001a26:	d812      	bhi.n	8001a4e <obqWriteTimeout+0x11e>
 8001a28:	9b03      	ldr	r3, [sp, #12]
 8001a2a:	6a59      	ldr	r1, [r3, #36]	; 0x24
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8001a2c:	9b02      	ldr	r3, [sp, #8]
 8001a2e:	1a59      	subs	r1, r3, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8001a30:	428f      	cmp	r7, r1
 8001a32:	d311      	bcc.n	8001a58 <obqWriteTimeout+0x128>
          osalSysUnlock();
          return w;
        }
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
 8001a34:	4650      	mov	r0, sl
 8001a36:	f7ff fc63 	bl	8001300 <obqGetEmptyBufferTimeoutS>
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8001a3a:	b968      	cbnz	r0, 8001a58 <obqWriteTimeout+0x128>
 8001a3c:	f8da 0028 	ldr.w	r0, [sl, #40]	; 0x28
 8001a40:	e794      	b.n	800196c <obqWriteTimeout+0x3c>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001a42:	480f      	ldr	r0, [pc, #60]	; (8001a80 <obqWriteTimeout+0x150>)
 8001a44:	f001 f8ec 	bl	8002c20 <chSysHalt>
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
  size_t w = 0;
  systime_t deadline;

  osalDbgCheck(n > 0U);
 8001a48:	480e      	ldr	r0, [pc, #56]	; (8001a84 <obqWriteTimeout+0x154>)
 8001a4a:	f001 f8e9 	bl	8002c20 <chSysHalt>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8001a4e:	4650      	mov	r0, sl
 8001a50:	4639      	mov	r1, r7
 8001a52:	f7ff fc55 	bl	8001300 <obqGetEmptyBufferTimeoutS>
 8001a56:	e7f0      	b.n	8001a3a <obqWriteTimeout+0x10a>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001a58:	f001 fbb2 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001a5c:	682b      	ldr	r3, [r5, #0]
 8001a5e:	4a07      	ldr	r2, [pc, #28]	; (8001a7c <obqWriteTimeout+0x14c>)
 8001a60:	42ab      	cmp	r3, r5
 8001a62:	d004      	beq.n	8001a6e <obqWriteTimeout+0x13e>
 8001a64:	6992      	ldr	r2, [r2, #24]
 8001a66:	689b      	ldr	r3, [r3, #8]
 8001a68:	6892      	ldr	r2, [r2, #8]
 8001a6a:	429a      	cmp	r2, r3
 8001a6c:	d3e9      	bcc.n	8001a42 <obqWriteTimeout+0x112>
 8001a6e:	2300      	movs	r3, #0
 8001a70:	f383 8811 	msr	BASEPRI, r3
    if (w >= n) {
      return w;
    }
    osalSysLock();
  }
}
 8001a74:	4620      	mov	r0, r4
 8001a76:	b005      	add	sp, #20
 8001a78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001a7c:	20001320 	.word	0x20001320
 8001a80:	08004df0 	.word	0x08004df0
 8001a84:	08004d68 	.word	0x08004d68
	...

08001a90 <_writet.lto_priv.75>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
}

static size_t _writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
 8001a90:	3044      	adds	r0, #68	; 0x44
 8001a92:	f7ff bf4d 	b.w	8001930 <obqWriteTimeout>
 8001a96:	bf00      	nop
	...

08001aa0 <_write.lto_priv.69>:
 * Interface implementation.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {

  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp,
 8001aa0:	3044      	adds	r0, #68	; 0x44
 8001aa2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001aa6:	f7ff bf43 	b.w	8001930 <obqWriteTimeout>
 8001aaa:	bf00      	nop
 8001aac:	0000      	movs	r0, r0
	...

08001ab0 <obqPutTimeout>:
 *                      suspended state.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    systime_t timeout) {
 8001ab0:	b570      	push	{r4, r5, r6, lr}
 8001ab2:	2320      	movs	r3, #32
 8001ab4:	b082      	sub	sp, #8
 8001ab6:	4604      	mov	r4, r0
 8001ab8:	460d      	mov	r5, r1
 8001aba:	4616      	mov	r6, r2
 8001abc:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001ac0:	f001 fba6 	bl	8003210 <_dbg_check_lock>
  msg_t msg;

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 8001ac4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001ac6:	b1fb      	cbz	r3, 8001b08 <obqPutTimeout+0x58>
      return msg;
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 8001ac8:	701d      	strb	r5, [r3, #0]
  obqp->ptr++;
 8001aca:	6aa3      	ldr	r3, [r4, #40]	; 0x28

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8001acc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
  obqp->ptr++;
 8001ace:	3301      	adds	r3, #1

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8001ad0:	4293      	cmp	r3, r2
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
  obqp->ptr++;
 8001ad2:	62a3      	str	r3, [r4, #40]	; 0x28

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8001ad4:	d212      	bcs.n	8001afc <obqPutTimeout+0x4c>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001ad6:	f001 fb73 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001ada:	4b17      	ldr	r3, [pc, #92]	; (8001b38 <obqPutTimeout+0x88>)
 8001adc:	681a      	ldr	r2, [r3, #0]
 8001ade:	429a      	cmp	r2, r3
 8001ae0:	d004      	beq.n	8001aec <obqPutTimeout+0x3c>
 8001ae2:	6999      	ldr	r1, [r3, #24]
 8001ae4:	6893      	ldr	r3, [r2, #8]
 8001ae6:	688a      	ldr	r2, [r1, #8]
 8001ae8:	429a      	cmp	r2, r3
 8001aea:	d304      	bcc.n	8001af6 <obqPutTimeout+0x46>
 8001aec:	2000      	movs	r0, #0
 8001aee:	f380 8811 	msr	BASEPRI, r0
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
  }

  osalSysUnlock();
  return MSG_OK;
}
 8001af2:	b002      	add	sp, #8
 8001af4:	bd70      	pop	{r4, r5, r6, pc}
 8001af6:	4811      	ldr	r0, [pc, #68]	; (8001b3c <obqPutTimeout+0x8c>)
 8001af8:	f001 f892 	bl	8002c20 <chSysHalt>
  obqp->ptr++;

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8001afc:	69e1      	ldr	r1, [r4, #28]
 8001afe:	4620      	mov	r0, r4
 8001b00:	3904      	subs	r1, #4
 8001b02:	f7ff fbb5 	bl	8001270 <obqPostFullBufferS>
 8001b06:	e7e6      	b.n	8001ad6 <obqPutTimeout+0x26>

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 8001b08:	4631      	mov	r1, r6
 8001b0a:	4620      	mov	r0, r4
 8001b0c:	f7ff fbf8 	bl	8001300 <obqGetEmptyBufferTimeoutS>
    if (msg != MSG_OK) {
 8001b10:	b908      	cbnz	r0, 8001b16 <obqPutTimeout+0x66>
 8001b12:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001b14:	e7d8      	b.n	8001ac8 <obqPutTimeout+0x18>
 8001b16:	9001      	str	r0, [sp, #4]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001b18:	f001 fb52 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001b1c:	4b06      	ldr	r3, [pc, #24]	; (8001b38 <obqPutTimeout+0x88>)
 8001b1e:	9801      	ldr	r0, [sp, #4]
 8001b20:	681a      	ldr	r2, [r3, #0]
 8001b22:	429a      	cmp	r2, r3
 8001b24:	d004      	beq.n	8001b30 <obqPutTimeout+0x80>
 8001b26:	6999      	ldr	r1, [r3, #24]
 8001b28:	6893      	ldr	r3, [r2, #8]
 8001b2a:	688a      	ldr	r2, [r1, #8]
 8001b2c:	429a      	cmp	r2, r3
 8001b2e:	d3e2      	bcc.n	8001af6 <obqPutTimeout+0x46>
 8001b30:	2300      	movs	r3, #0
 8001b32:	f383 8811 	msr	BASEPRI, r3
 8001b36:	e7dc      	b.n	8001af2 <obqPutTimeout+0x42>
 8001b38:	20001320 	.word	0x20001320
 8001b3c:	08004df0 	.word	0x08004df0

08001b40 <_putt.lto_priv.73>:
  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
}

static msg_t _putt(void *ip, uint8_t b, systime_t timeout) {

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
 8001b40:	3044      	adds	r0, #68	; 0x44
 8001b42:	f7ff bfb5 	b.w	8001ab0 <obqPutTimeout>
 8001b46:	bf00      	nop
	...

08001b50 <_put.lto_priv.71>:
                        n, TIME_INFINITE);
}

static msg_t _put(void *ip, uint8_t b) {

  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
 8001b50:	3044      	adds	r0, #68	; 0x44
 8001b52:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001b56:	f7ff bfab 	b.w	8001ab0 <obqPutTimeout>
 8001b5a:	bf00      	nop
 8001b5c:	0000      	movs	r0, r0
	...

08001b60 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
 8001b60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  size_t r = 0;
  systime_t deadline;

  osalDbgCheck(n > 0U);
 8001b64:	4690      	mov	r8, r2
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
 8001b66:	b085      	sub	sp, #20
  size_t r = 0;
  systime_t deadline;

  osalDbgCheck(n > 0U);
 8001b68:	2a00      	cmp	r2, #0
 8001b6a:	d07b      	beq.n	8001c64 <ibqReadTimeout+0x104>
 8001b6c:	4699      	mov	r9, r3
 8001b6e:	4604      	mov	r4, r0
 8001b70:	460e      	mov	r6, r1
 8001b72:	2320      	movs	r3, #32
 8001b74:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001b78:	f001 fb4a 	bl	8003210 <_dbg_check_lock>
 8001b7c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001b80:	4f45      	ldr	r7, [pc, #276]	; (8001c98 <ibqReadTimeout+0x138>)
 8001b82:	6a5a      	ldr	r2, [r3, #36]	; 0x24

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 8001b84:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8001b86:	9303      	str	r3, [sp, #12]
  osalDbgCheck(n > 0U);

  osalSysLock();

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8001b88:	eb09 0302 	add.w	r3, r9, r2
 8001b8c:	9302      	str	r3, [sp, #8]
    if (ibqp->ptr == NULL) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8001b8e:	f109 33ff 	add.w	r3, r9, #4294967295	; 0xffffffff
 8001b92:	9301      	str	r3, [sp, #4]

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001b94:	46ba      	mov	sl, r7
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
  size_t r = 0;
 8001b96:	2500      	movs	r5, #0

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 8001b98:	2900      	cmp	r1, #0
 8001b9a:	d051      	beq.n	8001c40 <ibqReadTimeout+0xe0>
        return r;
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8001b9c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    if (size > (n - r)) {
 8001b9e:	ebc5 0b08 	rsb	fp, r5, r8
        return r;
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8001ba2:	1a5b      	subs	r3, r3, r1
 8001ba4:	459b      	cmp	fp, r3
 8001ba6:	bf28      	it	cs
 8001ba8:	469b      	movcs	fp, r3
      size = n - r;
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 8001baa:	f1bb 0f40 	cmp.w	fp, #64	; 0x40
 8001bae:	d923      	bls.n	8001bf8 <ibqReadTimeout+0x98>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
 8001bb0:	f101 0240 	add.w	r2, r1, #64	; 0x40
 8001bb4:	4633      	mov	r3, r6
 8001bb6:	f8d1 c000 	ldr.w	ip, [r1]
 8001bba:	f8d1 e004 	ldr.w	lr, [r1, #4]
 8001bbe:	6888      	ldr	r0, [r1, #8]
 8001bc0:	f8d1 b00c 	ldr.w	fp, [r1, #12]
 8001bc4:	f8c3 b00c 	str.w	fp, [r3, #12]
 8001bc8:	3110      	adds	r1, #16
 8001bca:	4291      	cmp	r1, r2
 8001bcc:	f8c3 c000 	str.w	ip, [r3]
 8001bd0:	f8c3 e004 	str.w	lr, [r3, #4]
 8001bd4:	6098      	str	r0, [r3, #8]
 8001bd6:	f103 0310 	add.w	r3, r3, #16
 8001bda:	d1ec      	bne.n	8001bb6 <ibqReadTimeout+0x56>
      bp        += 64U;
      ibqp->ptr += 64U;
 8001bdc:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      ibqp->ptr += size;
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8001bde:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
       this impacts throughput however.*/
    if (size > 64U) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
      bp        += 64U;
      ibqp->ptr += 64U;
 8001be0:	3340      	adds	r3, #64	; 0x40
      ibqp->ptr += size;
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8001be2:	429a      	cmp	r2, r3
    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
      bp        += 64U;
 8001be4:	f106 0640 	add.w	r6, r6, #64	; 0x40
      ibqp->ptr += 64U;
      r         += 64U;
 8001be8:	f105 0540 	add.w	r5, r5, #64	; 0x40
       this impacts throughput however.*/
    if (size > 64U) {
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
      bp        += 64U;
      ibqp->ptr += 64U;
 8001bec:	62a3      	str	r3, [r4, #40]	; 0x28
      ibqp->ptr += size;
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8001bee:	d80f      	bhi.n	8001c10 <ibqReadTimeout+0xb0>
      ibqReleaseEmptyBufferS(ibqp);
 8001bf0:	4620      	mov	r0, r4
 8001bf2:	f7ff fb65 	bl	80012c0 <ibqReleaseEmptyBufferS>
 8001bf6:	e00b      	b.n	8001c10 <ibqReadTimeout+0xb0>
      bp        += 64U;
      ibqp->ptr += 64U;
      r         += 64U;
    }
    else {
      memcpy(bp, ibqp->ptr, size);
 8001bf8:	4630      	mov	r0, r6
 8001bfa:	465a      	mov	r2, fp
 8001bfc:	f7fe fb8c 	bl	8000318 <memcpy>
      bp        += size;
      ibqp->ptr += size;
 8001c00:	6aa3      	ldr	r3, [r4, #40]	; 0x28
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8001c02:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
      r         += 64U;
    }
    else {
      memcpy(bp, ibqp->ptr, size);
      bp        += size;
      ibqp->ptr += size;
 8001c04:	445b      	add	r3, fp
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8001c06:	429a      	cmp	r2, r3
    }
    else {
      memcpy(bp, ibqp->ptr, size);
      bp        += size;
      ibqp->ptr += size;
      r         += size;
 8001c08:	445d      	add	r5, fp
      ibqp->ptr += 64U;
      r         += 64U;
    }
    else {
      memcpy(bp, ibqp->ptr, size);
      bp        += size;
 8001c0a:	445e      	add	r6, fp
      ibqp->ptr += size;
 8001c0c:	62a3      	str	r3, [r4, #40]	; 0x28
      r         += size;
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8001c0e:	d9ef      	bls.n	8001bf0 <ibqReadTimeout+0x90>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001c10:	f001 fad6 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001c14:	683b      	ldr	r3, [r7, #0]
 8001c16:	42bb      	cmp	r3, r7
 8001c18:	d005      	beq.n	8001c26 <ibqReadTimeout+0xc6>
 8001c1a:	f8da 2018 	ldr.w	r2, [sl, #24]
 8001c1e:	689b      	ldr	r3, [r3, #8]
 8001c20:	6892      	ldr	r2, [r2, #8]
 8001c22:	429a      	cmp	r2, r3
 8001c24:	d31b      	bcc.n	8001c5e <ibqReadTimeout+0xfe>
 8001c26:	2300      	movs	r3, #0
 8001c28:	f383 8811 	msr	BASEPRI, r3
      ibqReleaseEmptyBufferS(ibqp);
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
    if (r >= n) {
 8001c2c:	4545      	cmp	r5, r8
 8001c2e:	d22f      	bcs.n	8001c90 <ibqReadTimeout+0x130>
 8001c30:	2320      	movs	r3, #32
 8001c32:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001c36:	f001 faeb 	bl	8003210 <_dbg_check_lock>

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 8001c3a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8001c3c:	2900      	cmp	r1, #0
 8001c3e:	d1ad      	bne.n	8001b9c <ibqReadTimeout+0x3c>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8001c40:	9b01      	ldr	r3, [sp, #4]
 8001c42:	3303      	adds	r3, #3
 8001c44:	d811      	bhi.n	8001c6a <ibqReadTimeout+0x10a>
 8001c46:	9b03      	ldr	r3, [sp, #12]
 8001c48:	6a59      	ldr	r1, [r3, #36]	; 0x24
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8001c4a:	9b02      	ldr	r3, [sp, #8]
 8001c4c:	1a59      	subs	r1, r3, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8001c4e:	4589      	cmp	r9, r1
 8001c50:	d310      	bcc.n	8001c74 <ibqReadTimeout+0x114>
          osalSysUnlock();
          return r;
        }
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
 8001c52:	4620      	mov	r0, r4
 8001c54:	f7ff fb8c 	bl	8001370 <ibqGetFullBufferTimeoutS>
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8001c58:	b960      	cbnz	r0, 8001c74 <ibqReadTimeout+0x114>
 8001c5a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8001c5c:	e79e      	b.n	8001b9c <ibqReadTimeout+0x3c>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001c5e:	480f      	ldr	r0, [pc, #60]	; (8001c9c <ibqReadTimeout+0x13c>)
 8001c60:	f000 ffde 	bl	8002c20 <chSysHalt>
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
  size_t r = 0;
  systime_t deadline;

  osalDbgCheck(n > 0U);
 8001c64:	480e      	ldr	r0, [pc, #56]	; (8001ca0 <ibqReadTimeout+0x140>)
 8001c66:	f000 ffdb 	bl	8002c20 <chSysHalt>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8001c6a:	4620      	mov	r0, r4
 8001c6c:	4649      	mov	r1, r9
 8001c6e:	f7ff fb7f 	bl	8001370 <ibqGetFullBufferTimeoutS>
 8001c72:	e7f1      	b.n	8001c58 <ibqReadTimeout+0xf8>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001c74:	f001 faa4 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001c78:	683b      	ldr	r3, [r7, #0]
 8001c7a:	4a07      	ldr	r2, [pc, #28]	; (8001c98 <ibqReadTimeout+0x138>)
 8001c7c:	42bb      	cmp	r3, r7
 8001c7e:	d004      	beq.n	8001c8a <ibqReadTimeout+0x12a>
 8001c80:	6992      	ldr	r2, [r2, #24]
 8001c82:	689b      	ldr	r3, [r3, #8]
 8001c84:	6892      	ldr	r2, [r2, #8]
 8001c86:	429a      	cmp	r2, r3
 8001c88:	d3e9      	bcc.n	8001c5e <ibqReadTimeout+0xfe>
 8001c8a:	2300      	movs	r3, #0
 8001c8c:	f383 8811 	msr	BASEPRI, r3
    if (r >= n) {
      return r;
    }
    osalSysLock();
  }
}
 8001c90:	4628      	mov	r0, r5
 8001c92:	b005      	add	sp, #20
 8001c94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001c98:	20001320 	.word	0x20001320
 8001c9c:	08004df0 	.word	0x08004df0
 8001ca0:	08004d58 	.word	0x08004d58
	...

08001cb0 <_readt.lto_priv.76>:
  return obqWriteTimeout(&((SerialUSBDriver *)ip)->obqueue, bp, n, timeout);
}

static size_t _readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp, n, timeout);
 8001cb0:	300c      	adds	r0, #12
 8001cb2:	f7ff bf55 	b.w	8001b60 <ibqReadTimeout>
 8001cb6:	bf00      	nop
	...

08001cc0 <_read.lto_priv.70>:
                         n, TIME_INFINITE);
}

static size_t _read(void *ip, uint8_t *bp, size_t n) {

  return ibqReadTimeout(&((SerialUSBDriver *)ip)->ibqueue, bp,
 8001cc0:	300c      	adds	r0, #12
 8001cc2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001cc6:	f7ff bf4b 	b.w	8001b60 <ibqReadTimeout>
 8001cca:	bf00      	nop
 8001ccc:	0000      	movs	r0, r0
	...

08001cd0 <ibqGetTimeout>:
 * @retval MSG_RESET    if the queue has been reset or has been put in
 *                      suspended state.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 8001cd0:	b530      	push	{r4, r5, lr}
 8001cd2:	2320      	movs	r3, #32
 8001cd4:	b083      	sub	sp, #12
 8001cd6:	4604      	mov	r4, r0
 8001cd8:	460d      	mov	r5, r1
 8001cda:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001cde:	f001 fa97 	bl	8003210 <_dbg_check_lock>
  msg_t msg;

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 8001ce2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001ce4:	b1eb      	cbz	r3, 8001d22 <ibqGetTimeout+0x52>
      return msg;
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 8001ce6:	f813 5b01 	ldrb.w	r5, [r3], #1
  ibqp->ptr++;

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 8001cea:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
  ibqp->ptr++;
 8001cec:	62a3      	str	r3, [r4, #40]	; 0x28

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 8001cee:	4293      	cmp	r3, r2
 8001cf0:	d213      	bcs.n	8001d1a <ibqGetTimeout+0x4a>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001cf2:	f001 fa65 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001cf6:	4b17      	ldr	r3, [pc, #92]	; (8001d54 <ibqGetTimeout+0x84>)
 8001cf8:	681a      	ldr	r2, [r3, #0]
 8001cfa:	429a      	cmp	r2, r3
 8001cfc:	d004      	beq.n	8001d08 <ibqGetTimeout+0x38>
 8001cfe:	6999      	ldr	r1, [r3, #24]
 8001d00:	6893      	ldr	r3, [r2, #8]
 8001d02:	688a      	ldr	r2, [r1, #8]
 8001d04:	429a      	cmp	r2, r3
 8001d06:	d305      	bcc.n	8001d14 <ibqGetTimeout+0x44>
 8001d08:	2300      	movs	r3, #0
 8001d0a:	f383 8811 	msr	BASEPRI, r3
    ibqReleaseEmptyBufferS(ibqp);
  }

  osalSysUnlock();
  return msg;
 8001d0e:	4628      	mov	r0, r5
}
 8001d10:	b003      	add	sp, #12
 8001d12:	bd30      	pop	{r4, r5, pc}
 8001d14:	4810      	ldr	r0, [pc, #64]	; (8001d58 <ibqGetTimeout+0x88>)
 8001d16:	f000 ff83 	bl	8002c20 <chSysHalt>
  ibqp->ptr++;

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
    ibqReleaseEmptyBufferS(ibqp);
 8001d1a:	4620      	mov	r0, r4
 8001d1c:	f7ff fad0 	bl	80012c0 <ibqReleaseEmptyBufferS>
 8001d20:	e7e7      	b.n	8001cf2 <ibqGetTimeout+0x22>

  osalSysLock();

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8001d22:	4629      	mov	r1, r5
 8001d24:	4620      	mov	r0, r4
 8001d26:	f7ff fb23 	bl	8001370 <ibqGetFullBufferTimeoutS>
    if (msg != MSG_OK) {
 8001d2a:	b908      	cbnz	r0, 8001d30 <ibqGetTimeout+0x60>
 8001d2c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001d2e:	e7da      	b.n	8001ce6 <ibqGetTimeout+0x16>
 8001d30:	9001      	str	r0, [sp, #4]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001d32:	f001 fa45 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001d36:	4b07      	ldr	r3, [pc, #28]	; (8001d54 <ibqGetTimeout+0x84>)
 8001d38:	9801      	ldr	r0, [sp, #4]
 8001d3a:	681a      	ldr	r2, [r3, #0]
 8001d3c:	429a      	cmp	r2, r3
 8001d3e:	d004      	beq.n	8001d4a <ibqGetTimeout+0x7a>
 8001d40:	6999      	ldr	r1, [r3, #24]
 8001d42:	6893      	ldr	r3, [r2, #8]
 8001d44:	688a      	ldr	r2, [r1, #8]
 8001d46:	429a      	cmp	r2, r3
 8001d48:	d3e4      	bcc.n	8001d14 <ibqGetTimeout+0x44>
 8001d4a:	2300      	movs	r3, #0
 8001d4c:	f383 8811 	msr	BASEPRI, r3
 8001d50:	e7de      	b.n	8001d10 <ibqGetTimeout+0x40>
 8001d52:	bf00      	nop
 8001d54:	20001320 	.word	0x20001320
 8001d58:	08004df0 	.word	0x08004df0
 8001d5c:	00000000 	.word	0x00000000

08001d60 <_gett.lto_priv.74>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, timeout);
}

static msg_t _gett(void *ip, systime_t timeout) {

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, timeout);
 8001d60:	300c      	adds	r0, #12
 8001d62:	f7ff bfb5 	b.w	8001cd0 <ibqGetTimeout>
 8001d66:	bf00      	nop
	...

08001d70 <_get.lto_priv.72>:
  return obqPutTimeout(&((SerialUSBDriver *)ip)->obqueue, b, TIME_INFINITE);
}

static msg_t _get(void *ip) {

  return ibqGetTimeout(&((SerialUSBDriver *)ip)->ibqueue, TIME_INFINITE);
 8001d70:	300c      	adds	r0, #12
 8001d72:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8001d76:	f7ff bfab 	b.w	8001cd0 <ibqGetTimeout>
 8001d7a:	bf00      	nop
 8001d7c:	0000      	movs	r0, r0
	...

08001d80 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 8001d80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001d82:	4605      	mov	r5, r0
 8001d84:	460c      	mov	r4, r1
 8001d86:	2320      	movs	r3, #32
 8001d88:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001d8c:	f001 fa40 	bl	8003210 <_dbg_check_lock>
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
  uint8_t *p;

  chDbgCheckClassI();
 8001d90:	f000 ff9e 	bl	8002cd0 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8001d94:	b32c      	cbz	r4, 8001de2 <chCoreAllocAligned+0x62>
 8001d96:	1e62      	subs	r2, r4, #1
 8001d98:	ea12 0704 	ands.w	r7, r2, r4
 8001d9c:	d121      	bne.n	8001de2 <chCoreAllocAligned+0x62>

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8001d9e:	4e14      	ldr	r6, [pc, #80]	; (8001df0 <chCoreAllocAligned+0x70>)

  if (((size_t)endmem - (size_t)p) < size) {
 8001da0:	4914      	ldr	r1, [pc, #80]	; (8001df4 <chCoreAllocAligned+0x74>)
 8001da2:	6833      	ldr	r3, [r6, #0]
 8001da4:	6809      	ldr	r1, [r1, #0]
 8001da6:	3b01      	subs	r3, #1

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8001da8:	4423      	add	r3, r4
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8001daa:	4264      	negs	r4, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8001dac:	ea03 0004 	and.w	r0, r3, r4
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8001db0:	442a      	add	r2, r5
 8001db2:	4014      	ands	r4, r2
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
 8001db4:	1a0b      	subs	r3, r1, r0
 8001db6:	429c      	cmp	r4, r3
    return NULL;
  }
  nextmem = p + size;
 8001db8:	bf9b      	ittet	ls
 8001dba:	1824      	addls	r4, r4, r0
 8001dbc:	6034      	strls	r4, [r6, #0]

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
    return NULL;
 8001dbe:	463c      	movhi	r4, r7
  }
  nextmem = p + size;

  return p;
 8001dc0:	4604      	movls	r4, r0
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8001dc2:	f001 f9fd 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001dc6:	4b0c      	ldr	r3, [pc, #48]	; (8001df8 <chCoreAllocAligned+0x78>)
 8001dc8:	681a      	ldr	r2, [r3, #0]
 8001dca:	429a      	cmp	r2, r3
 8001dcc:	d004      	beq.n	8001dd8 <chCoreAllocAligned+0x58>
 8001dce:	6999      	ldr	r1, [r3, #24]
 8001dd0:	6893      	ldr	r3, [r2, #8]
 8001dd2:	688a      	ldr	r2, [r1, #8]
 8001dd4:	429a      	cmp	r2, r3
 8001dd6:	d307      	bcc.n	8001de8 <chCoreAllocAligned+0x68>
 8001dd8:	2300      	movs	r3, #0
 8001dda:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedI(size, align);
  chSysUnlock();

  return p;
}
 8001dde:	4620      	mov	r0, r4
 8001de0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8001de2:	4806      	ldr	r0, [pc, #24]	; (8001dfc <chCoreAllocAligned+0x7c>)
 8001de4:	f000 ff1c 	bl	8002c20 <chSysHalt>
 8001de8:	4805      	ldr	r0, [pc, #20]	; (8001e00 <chCoreAllocAligned+0x80>)
 8001dea:	f000 ff19 	bl	8002c20 <chSysHalt>
 8001dee:	bf00      	nop
 8001df0:	20000d5c 	.word	0x20000d5c
 8001df4:	200008b8 	.word	0x200008b8
 8001df8:	20001320 	.word	0x20001320
 8001dfc:	08004d78 	.word	0x08004d78
 8001e00:	08004e70 	.word	0x08004e70
	...

08001e10 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8001e10:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001e12:	480d      	ldr	r0, [pc, #52]	; (8001e48 <Vector158+0x38>)
 8001e14:	f000 feb4 	bl	8002b80 <_trace_isr_enter>
 8001e18:	f001 f952 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8001e1c:	4b0b      	ldr	r3, [pc, #44]	; (8001e4c <Vector158+0x3c>)
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
 8001e1e:	480c      	ldr	r0, [pc, #48]	; (8001e50 <Vector158+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8001e20:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
 8001e22:	6f82      	ldr	r2, [r0, #120]	; 0x78
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8001e24:	0d89      	lsrs	r1, r1, #22
 8001e26:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 22U;
 8001e2a:	058c      	lsls	r4, r1, #22
 8001e2c:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[15].dma_func)
 8001e2e:	b10a      	cbz	r2, 8001e34 <Vector158+0x24>
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);
 8001e30:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
 8001e32:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001e34:	f001 f92c 	bl	8003090 <_dbg_check_leave_isr>
 8001e38:	4803      	ldr	r0, [pc, #12]	; (8001e48 <Vector158+0x38>)
 8001e3a:	f000 fe81 	bl	8002b40 <_trace_isr_leave>
}
 8001e3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 22U;
  if (dma_isr_redir[15].dma_func)
    dma_isr_redir[15].dma_func(dma_isr_redir[15].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001e42:	f7ff bc25 	b.w	8001690 <_port_irq_epilogue>
 8001e46:	bf00      	nop
 8001e48:	08004e88 	.word	0x08004e88
 8001e4c:	40026400 	.word	0x40026400
 8001e50:	20001ba8 	.word	0x20001ba8
	...

08001e60 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8001e60:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001e62:	480d      	ldr	r0, [pc, #52]	; (8001e98 <Vector154+0x38>)
 8001e64:	f000 fe8c 	bl	8002b80 <_trace_isr_enter>
 8001e68:	f001 f92a 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8001e6c:	4b0b      	ldr	r3, [pc, #44]	; (8001e9c <Vector154+0x3c>)
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
 8001e6e:	480c      	ldr	r0, [pc, #48]	; (8001ea0 <Vector154+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8001e70:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
 8001e72:	6f02      	ldr	r2, [r0, #112]	; 0x70
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8001e74:	0c09      	lsrs	r1, r1, #16
 8001e76:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 16U;
 8001e7a:	040c      	lsls	r4, r1, #16
 8001e7c:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[14].dma_func)
 8001e7e:	b10a      	cbz	r2, 8001e84 <Vector154+0x24>
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);
 8001e80:	6f40      	ldr	r0, [r0, #116]	; 0x74
 8001e82:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001e84:	f001 f904 	bl	8003090 <_dbg_check_leave_isr>
 8001e88:	4803      	ldr	r0, [pc, #12]	; (8001e98 <Vector154+0x38>)
 8001e8a:	f000 fe59 	bl	8002b40 <_trace_isr_leave>
}
 8001e8e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 16U;
  if (dma_isr_redir[14].dma_func)
    dma_isr_redir[14].dma_func(dma_isr_redir[14].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001e92:	f7ff bbfd 	b.w	8001690 <_port_irq_epilogue>
 8001e96:	bf00      	nop
 8001e98:	08004e7c 	.word	0x08004e7c
 8001e9c:	40026400 	.word	0x40026400
 8001ea0:	20001ba8 	.word	0x20001ba8
	...

08001eb0 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8001eb0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001eb2:	480d      	ldr	r0, [pc, #52]	; (8001ee8 <Vector150+0x38>)
 8001eb4:	f000 fe64 	bl	8002b80 <_trace_isr_enter>
 8001eb8:	f001 f902 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8001ebc:	4b0b      	ldr	r3, [pc, #44]	; (8001eec <Vector150+0x3c>)
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
 8001ebe:	480c      	ldr	r0, [pc, #48]	; (8001ef0 <Vector150+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8001ec0:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
 8001ec2:	6e82      	ldr	r2, [r0, #104]	; 0x68
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8001ec4:	0989      	lsrs	r1, r1, #6
 8001ec6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 6U;
 8001eca:	018c      	lsls	r4, r1, #6
 8001ecc:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[13].dma_func)
 8001ece:	b10a      	cbz	r2, 8001ed4 <Vector150+0x24>
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);
 8001ed0:	6ec0      	ldr	r0, [r0, #108]	; 0x6c
 8001ed2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001ed4:	f001 f8dc 	bl	8003090 <_dbg_check_leave_isr>
 8001ed8:	4803      	ldr	r0, [pc, #12]	; (8001ee8 <Vector150+0x38>)
 8001eda:	f000 fe31 	bl	8002b40 <_trace_isr_leave>
}
 8001ede:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 6U;
  if (dma_isr_redir[13].dma_func)
    dma_isr_redir[13].dma_func(dma_isr_redir[13].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001ee2:	f7ff bbd5 	b.w	8001690 <_port_irq_epilogue>
 8001ee6:	bf00      	nop
 8001ee8:	08004fac 	.word	0x08004fac
 8001eec:	40026400 	.word	0x40026400
 8001ef0:	20001ba8 	.word	0x20001ba8
	...

08001f00 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8001f00:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001f02:	480c      	ldr	r0, [pc, #48]	; (8001f34 <Vector130+0x34>)
 8001f04:	f000 fe3c 	bl	8002b80 <_trace_isr_enter>
 8001f08:	f001 f8da 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8001f0c:	4b0a      	ldr	r3, [pc, #40]	; (8001f38 <Vector130+0x38>)
  DMA2->HIFCR = flags << 0U;
  if (dma_isr_redir[12].dma_func)
 8001f0e:	480b      	ldr	r0, [pc, #44]	; (8001f3c <Vector130+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8001f10:	6859      	ldr	r1, [r3, #4]
  DMA2->HIFCR = flags << 0U;
  if (dma_isr_redir[12].dma_func)
 8001f12:	6e02      	ldr	r2, [r0, #96]	; 0x60
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8001f14:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 8001f18:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[12].dma_func)
 8001f1a:	b10a      	cbz	r2, 8001f20 <Vector130+0x20>
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);
 8001f1c:	6e40      	ldr	r0, [r0, #100]	; 0x64
 8001f1e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001f20:	f001 f8b6 	bl	8003090 <_dbg_check_leave_isr>
 8001f24:	4803      	ldr	r0, [pc, #12]	; (8001f34 <Vector130+0x34>)
 8001f26:	f000 fe0b 	bl	8002b40 <_trace_isr_leave>
}
 8001f2a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA2->HIFCR = flags << 0U;
  if (dma_isr_redir[12].dma_func)
    dma_isr_redir[12].dma_func(dma_isr_redir[12].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001f2e:	f7ff bbaf 	b.w	8001690 <_port_irq_epilogue>
 8001f32:	bf00      	nop
 8001f34:	08004fa0 	.word	0x08004fa0
 8001f38:	40026400 	.word	0x40026400
 8001f3c:	20001ba8 	.word	0x20001ba8

08001f40 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8001f40:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001f42:	480d      	ldr	r0, [pc, #52]	; (8001f78 <Vector12C+0x38>)
 8001f44:	f000 fe1c 	bl	8002b80 <_trace_isr_enter>
 8001f48:	f001 f8ba 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8001f4c:	4b0b      	ldr	r3, [pc, #44]	; (8001f7c <Vector12C+0x3c>)
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
 8001f4e:	480c      	ldr	r0, [pc, #48]	; (8001f80 <Vector12C+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8001f50:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
 8001f52:	6d82      	ldr	r2, [r0, #88]	; 0x58
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8001f54:	0d89      	lsrs	r1, r1, #22
 8001f56:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 22U;
 8001f5a:	058c      	lsls	r4, r1, #22
 8001f5c:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[11].dma_func)
 8001f5e:	b10a      	cbz	r2, 8001f64 <Vector12C+0x24>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 8001f60:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
 8001f62:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001f64:	f001 f894 	bl	8003090 <_dbg_check_leave_isr>
 8001f68:	4803      	ldr	r0, [pc, #12]	; (8001f78 <Vector12C+0x38>)
 8001f6a:	f000 fde9 	bl	8002b40 <_trace_isr_leave>
}
 8001f6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 22U;
  if (dma_isr_redir[11].dma_func)
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001f72:	f7ff bb8d 	b.w	8001690 <_port_irq_epilogue>
 8001f76:	bf00      	nop
 8001f78:	08004f88 	.word	0x08004f88
 8001f7c:	40026400 	.word	0x40026400
 8001f80:	20001ba8 	.word	0x20001ba8
	...

08001f90 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8001f90:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001f92:	480d      	ldr	r0, [pc, #52]	; (8001fc8 <Vector128+0x38>)
 8001f94:	f000 fdf4 	bl	8002b80 <_trace_isr_enter>
 8001f98:	f001 f892 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8001f9c:	4b0b      	ldr	r3, [pc, #44]	; (8001fcc <Vector128+0x3c>)
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
 8001f9e:	480c      	ldr	r0, [pc, #48]	; (8001fd0 <Vector128+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8001fa0:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
 8001fa2:	6d02      	ldr	r2, [r0, #80]	; 0x50
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8001fa4:	0c09      	lsrs	r1, r1, #16
 8001fa6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 16U;
 8001faa:	040c      	lsls	r4, r1, #16
 8001fac:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[10].dma_func)
 8001fae:	b10a      	cbz	r2, 8001fb4 <Vector128+0x24>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 8001fb0:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8001fb2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8001fb4:	f001 f86c 	bl	8003090 <_dbg_check_leave_isr>
 8001fb8:	4803      	ldr	r0, [pc, #12]	; (8001fc8 <Vector128+0x38>)
 8001fba:	f000 fdc1 	bl	8002b40 <_trace_isr_leave>
}
 8001fbe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 16U;
  if (dma_isr_redir[10].dma_func)
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8001fc2:	f7ff bb65 	b.w	8001690 <_port_irq_epilogue>
 8001fc6:	bf00      	nop
 8001fc8:	08004f7c 	.word	0x08004f7c
 8001fcc:	40026400 	.word	0x40026400
 8001fd0:	20001ba8 	.word	0x20001ba8
	...

08001fe0 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8001fe0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001fe2:	480d      	ldr	r0, [pc, #52]	; (8002018 <Vector124+0x38>)
 8001fe4:	f000 fdcc 	bl	8002b80 <_trace_isr_enter>
 8001fe8:	f001 f86a 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8001fec:	4b0b      	ldr	r3, [pc, #44]	; (800201c <Vector124+0x3c>)
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
 8001fee:	480c      	ldr	r0, [pc, #48]	; (8002020 <Vector124+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8001ff0:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
 8001ff2:	6c82      	ldr	r2, [r0, #72]	; 0x48
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8001ff4:	0989      	lsrs	r1, r1, #6
 8001ff6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 6U;
 8001ffa:	018c      	lsls	r4, r1, #6
 8001ffc:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[9].dma_func)
 8001ffe:	b10a      	cbz	r2, 8002004 <Vector124+0x24>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 8002000:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
 8002002:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002004:	f001 f844 	bl	8003090 <_dbg_check_leave_isr>
 8002008:	4803      	ldr	r0, [pc, #12]	; (8002018 <Vector124+0x38>)
 800200a:	f000 fd99 	bl	8002b40 <_trace_isr_leave>
}
 800200e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 6U;
  if (dma_isr_redir[9].dma_func)
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002012:	f7ff bb3d 	b.w	8001690 <_port_irq_epilogue>
 8002016:	bf00      	nop
 8002018:	08004f3c 	.word	0x08004f3c
 800201c:	40026400 	.word	0x40026400
 8002020:	20001ba8 	.word	0x20001ba8
	...

08002030 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8002030:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002032:	480c      	ldr	r0, [pc, #48]	; (8002064 <Vector120+0x34>)
 8002034:	f000 fda4 	bl	8002b80 <_trace_isr_enter>
 8002038:	f001 f842 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800203c:	4b0a      	ldr	r3, [pc, #40]	; (8002068 <Vector120+0x38>)
  DMA2->LIFCR = flags << 0U;
  if (dma_isr_redir[8].dma_func)
 800203e:	480b      	ldr	r0, [pc, #44]	; (800206c <Vector120+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002040:	6819      	ldr	r1, [r3, #0]
  DMA2->LIFCR = flags << 0U;
  if (dma_isr_redir[8].dma_func)
 8002042:	6c02      	ldr	r2, [r0, #64]	; 0x40
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8002044:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 8002048:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[8].dma_func)
 800204a:	b10a      	cbz	r2, 8002050 <Vector120+0x20>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 800204c:	6c40      	ldr	r0, [r0, #68]	; 0x44
 800204e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002050:	f001 f81e 	bl	8003090 <_dbg_check_leave_isr>
 8002054:	4803      	ldr	r0, [pc, #12]	; (8002064 <Vector120+0x34>)
 8002056:	f000 fd73 	bl	8002b40 <_trace_isr_leave>
}
 800205a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA2->LIFCR = flags << 0U;
  if (dma_isr_redir[8].dma_func)
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800205e:	f7ff bb17 	b.w	8001690 <_port_irq_epilogue>
 8002062:	bf00      	nop
 8002064:	08004f18 	.word	0x08004f18
 8002068:	40026400 	.word	0x40026400
 800206c:	20001ba8 	.word	0x20001ba8

08002070 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8002070:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002072:	480d      	ldr	r0, [pc, #52]	; (80020a8 <VectorFC+0x38>)
 8002074:	f000 fd84 	bl	8002b80 <_trace_isr_enter>
 8002078:	f001 f822 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800207c:	4b0b      	ldr	r3, [pc, #44]	; (80020ac <VectorFC+0x3c>)
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
 800207e:	480c      	ldr	r0, [pc, #48]	; (80020b0 <VectorFC+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002080:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
 8002082:	6b82      	ldr	r2, [r0, #56]	; 0x38
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8002084:	0d89      	lsrs	r1, r1, #22
 8002086:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 22U;
 800208a:	058c      	lsls	r4, r1, #22
 800208c:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[7].dma_func)
 800208e:	b10a      	cbz	r2, 8002094 <VectorFC+0x24>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 8002090:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 8002092:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002094:	f000 fffc 	bl	8003090 <_dbg_check_leave_isr>
 8002098:	4803      	ldr	r0, [pc, #12]	; (80020a8 <VectorFC+0x38>)
 800209a:	f000 fd51 	bl	8002b40 <_trace_isr_leave>
}
 800209e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 22U;
  if (dma_isr_redir[7].dma_func)
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80020a2:	f7ff baf5 	b.w	8001690 <_port_irq_epilogue>
 80020a6:	bf00      	nop
 80020a8:	08004f30 	.word	0x08004f30
 80020ac:	40026000 	.word	0x40026000
 80020b0:	20001ba8 	.word	0x20001ba8
	...

080020c0 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 80020c0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80020c2:	480d      	ldr	r0, [pc, #52]	; (80020f8 <Vector84+0x38>)
 80020c4:	f000 fd5c 	bl	8002b80 <_trace_isr_enter>
 80020c8:	f000 fffa 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80020cc:	4b0b      	ldr	r3, [pc, #44]	; (80020fc <Vector84+0x3c>)
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
 80020ce:	480c      	ldr	r0, [pc, #48]	; (8002100 <Vector84+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80020d0:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
 80020d2:	6b02      	ldr	r2, [r0, #48]	; 0x30
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80020d4:	0c09      	lsrs	r1, r1, #16
 80020d6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 16U;
 80020da:	040c      	lsls	r4, r1, #16
 80020dc:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[6].dma_func)
 80020de:	b10a      	cbz	r2, 80020e4 <Vector84+0x24>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 80020e0:	6b40      	ldr	r0, [r0, #52]	; 0x34
 80020e2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80020e4:	f000 ffd4 	bl	8003090 <_dbg_check_leave_isr>
 80020e8:	4803      	ldr	r0, [pc, #12]	; (80020f8 <Vector84+0x38>)
 80020ea:	f000 fd29 	bl	8002b40 <_trace_isr_leave>
}
 80020ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 16U;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80020f2:	f7ff bacd 	b.w	8001690 <_port_irq_epilogue>
 80020f6:	bf00      	nop
 80020f8:	08004f24 	.word	0x08004f24
 80020fc:	40026000 	.word	0x40026000
 8002100:	20001ba8 	.word	0x20001ba8
	...

08002110 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8002110:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002112:	480d      	ldr	r0, [pc, #52]	; (8002148 <Vector80+0x38>)
 8002114:	f000 fd34 	bl	8002b80 <_trace_isr_enter>
 8002118:	f000 ffd2 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800211c:	4b0b      	ldr	r3, [pc, #44]	; (800214c <Vector80+0x3c>)
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
 800211e:	480c      	ldr	r0, [pc, #48]	; (8002150 <Vector80+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002120:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
 8002122:	6a82      	ldr	r2, [r0, #40]	; 0x28
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8002124:	0989      	lsrs	r1, r1, #6
 8002126:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 6U;
 800212a:	018c      	lsls	r4, r1, #6
 800212c:	60dc      	str	r4, [r3, #12]
  if (dma_isr_redir[5].dma_func)
 800212e:	b10a      	cbz	r2, 8002134 <Vector80+0x24>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8002130:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8002132:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002134:	f000 ffac 	bl	8003090 <_dbg_check_leave_isr>
 8002138:	4803      	ldr	r0, [pc, #12]	; (8002148 <Vector80+0x38>)
 800213a:	f000 fd01 	bl	8002b40 <_trace_isr_leave>
}
 800213e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 6U;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002142:	f7ff baa5 	b.w	8001690 <_port_irq_epilogue>
 8002146:	bf00      	nop
 8002148:	08004eec 	.word	0x08004eec
 800214c:	40026000 	.word	0x40026000
 8002150:	20001ba8 	.word	0x20001ba8
	...

08002160 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8002160:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002162:	480c      	ldr	r0, [pc, #48]	; (8002194 <Vector7C+0x34>)
 8002164:	f000 fd0c 	bl	8002b80 <_trace_isr_enter>
 8002168:	f000 ffaa 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800216c:	4b0a      	ldr	r3, [pc, #40]	; (8002198 <Vector7C+0x38>)
  DMA1->HIFCR = flags << 0U;
  if (dma_isr_redir[4].dma_func)
 800216e:	480b      	ldr	r0, [pc, #44]	; (800219c <Vector7C+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002170:	6859      	ldr	r1, [r3, #4]
  DMA1->HIFCR = flags << 0U;
  if (dma_isr_redir[4].dma_func)
 8002172:	6a02      	ldr	r2, [r0, #32]
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8002174:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 8002178:	60d9      	str	r1, [r3, #12]
  if (dma_isr_redir[4].dma_func)
 800217a:	b10a      	cbz	r2, 8002180 <Vector7C+0x20>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 800217c:	6a40      	ldr	r0, [r0, #36]	; 0x24
 800217e:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002180:	f000 ff86 	bl	8003090 <_dbg_check_leave_isr>
 8002184:	4803      	ldr	r0, [pc, #12]	; (8002194 <Vector7C+0x34>)
 8002186:	f000 fcdb 	bl	8002b40 <_trace_isr_leave>
}
 800218a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA1->HIFCR = flags << 0U;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800218e:	f7ff ba7f 	b.w	8001690 <_port_irq_epilogue>
 8002192:	bf00      	nop
 8002194:	08004e94 	.word	0x08004e94
 8002198:	40026000 	.word	0x40026000
 800219c:	20001ba8 	.word	0x20001ba8

080021a0 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 80021a0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80021a2:	480d      	ldr	r0, [pc, #52]	; (80021d8 <Vector78+0x38>)
 80021a4:	f000 fcec 	bl	8002b80 <_trace_isr_enter>
 80021a8:	f000 ff8a 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80021ac:	4b0b      	ldr	r3, [pc, #44]	; (80021dc <Vector78+0x3c>)
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
 80021ae:	480c      	ldr	r0, [pc, #48]	; (80021e0 <Vector78+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80021b0:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
 80021b2:	6982      	ldr	r2, [r0, #24]
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80021b4:	0d89      	lsrs	r1, r1, #22
 80021b6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 22U;
 80021ba:	058c      	lsls	r4, r1, #22
 80021bc:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[3].dma_func)
 80021be:	b10a      	cbz	r2, 80021c4 <Vector78+0x24>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 80021c0:	69c0      	ldr	r0, [r0, #28]
 80021c2:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80021c4:	f000 ff64 	bl	8003090 <_dbg_check_leave_isr>
 80021c8:	4803      	ldr	r0, [pc, #12]	; (80021d8 <Vector78+0x38>)
 80021ca:	f000 fcb9 	bl	8002b40 <_trace_isr_leave>
}
 80021ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 22U;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80021d2:	f7ff ba5d 	b.w	8001690 <_port_irq_epilogue>
 80021d6:	bf00      	nop
 80021d8:	08004ea8 	.word	0x08004ea8
 80021dc:	40026000 	.word	0x40026000
 80021e0:	20001ba8 	.word	0x20001ba8
	...

080021f0 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 80021f0:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80021f2:	480d      	ldr	r0, [pc, #52]	; (8002228 <Vector74+0x38>)
 80021f4:	f000 fcc4 	bl	8002b80 <_trace_isr_enter>
 80021f8:	f000 ff62 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80021fc:	4b0b      	ldr	r3, [pc, #44]	; (800222c <Vector74+0x3c>)
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
 80021fe:	480c      	ldr	r0, [pc, #48]	; (8002230 <Vector74+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002200:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
 8002202:	6902      	ldr	r2, [r0, #16]
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8002204:	0c09      	lsrs	r1, r1, #16
 8002206:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 16U;
 800220a:	040c      	lsls	r4, r1, #16
 800220c:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[2].dma_func)
 800220e:	b10a      	cbz	r2, 8002214 <Vector74+0x24>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8002210:	6940      	ldr	r0, [r0, #20]
 8002212:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002214:	f000 ff3c 	bl	8003090 <_dbg_check_leave_isr>
 8002218:	4803      	ldr	r0, [pc, #12]	; (8002228 <Vector74+0x38>)
 800221a:	f000 fc91 	bl	8002b40 <_trace_isr_leave>
}
 800221e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 16U;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002222:	f7ff ba35 	b.w	8001690 <_port_irq_epilogue>
 8002226:	bf00      	nop
 8002228:	08004ef8 	.word	0x08004ef8
 800222c:	40026000 	.word	0x40026000
 8002230:	20001ba8 	.word	0x20001ba8
	...

08002240 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8002240:	b510      	push	{r4, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002242:	480d      	ldr	r0, [pc, #52]	; (8002278 <Vector70+0x38>)
 8002244:	f000 fc9c 	bl	8002b80 <_trace_isr_enter>
 8002248:	f000 ff3a 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800224c:	4b0b      	ldr	r3, [pc, #44]	; (800227c <Vector70+0x3c>)
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
 800224e:	480c      	ldr	r0, [pc, #48]	; (8002280 <Vector70+0x40>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002250:	6819      	ldr	r1, [r3, #0]
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
 8002252:	6882      	ldr	r2, [r0, #8]
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8002254:	0989      	lsrs	r1, r1, #6
 8002256:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 6U;
 800225a:	018c      	lsls	r4, r1, #6
 800225c:	609c      	str	r4, [r3, #8]
  if (dma_isr_redir[1].dma_func)
 800225e:	b10a      	cbz	r2, 8002264 <Vector70+0x24>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8002260:	68c0      	ldr	r0, [r0, #12]
 8002262:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8002264:	f000 ff14 	bl	8003090 <_dbg_check_leave_isr>
 8002268:	4803      	ldr	r0, [pc, #12]	; (8002278 <Vector70+0x38>)
 800226a:	f000 fc69 	bl	8002b40 <_trace_isr_leave>
}
 800226e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 6U;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8002272:	f7ff ba0d 	b.w	8001690 <_port_irq_epilogue>
 8002276:	bf00      	nop
 8002278:	08004f60 	.word	0x08004f60
 800227c:	40026000 	.word	0x40026000
 8002280:	20001ba8 	.word	0x20001ba8
	...

08002290 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8002290:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8002292:	480c      	ldr	r0, [pc, #48]	; (80022c4 <Vector6C+0x34>)
 8002294:	f000 fc74 	bl	8002b80 <_trace_isr_enter>
 8002298:	f000 ff12 	bl	80030c0 <_dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800229c:	4b0a      	ldr	r3, [pc, #40]	; (80022c8 <Vector6C+0x38>)
  DMA1->LIFCR = flags << 0U;
  if (dma_isr_redir[0].dma_func)
 800229e:	4a0b      	ldr	r2, [pc, #44]	; (80022cc <Vector6C+0x3c>)
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80022a0:	6819      	ldr	r1, [r3, #0]
 80022a2:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 80022a6:	6099      	str	r1, [r3, #8]
  if (dma_isr_redir[0].dma_func)
 80022a8:	6813      	ldr	r3, [r2, #0]
 80022aa:	b10b      	cbz	r3, 80022b0 <Vector6C+0x20>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 80022ac:	6850      	ldr	r0, [r2, #4]
 80022ae:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80022b0:	f000 feee 	bl	8003090 <_dbg_check_leave_isr>
 80022b4:	4803      	ldr	r0, [pc, #12]	; (80022c4 <Vector6C+0x34>)
 80022b6:	f000 fc43 	bl	8002b40 <_trace_isr_leave>
}
 80022ba:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
  DMA1->LIFCR = flags << 0U;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80022be:	f7ff b9e7 	b.w	8001690 <_port_irq_epilogue>
 80022c2:	bf00      	nop
 80022c4:	08004f54 	.word	0x08004f54
 80022c8:	40026000 	.word	0x40026000
 80022cc:	20001ba8 	.word	0x20001ba8

080022d0 <VectorBC>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 80022d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80022d2:	4d40      	ldr	r5, [pc, #256]	; (80023d4 <VectorBC+0x104>)
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 80022d4:	4840      	ldr	r0, [pc, #256]	; (80023d8 <VectorBC+0x108>)
 80022d6:	f000 fc53 	bl	8002b80 <_trace_isr_enter>
 80022da:	f000 fef1 	bl	80030c0 <_dbg_check_enter_isr>
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80022de:	6b6c      	ldr	r4, [r5, #52]	; 0x34
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80022e0:	4a3e      	ldr	r2, [pc, #248]	; (80023dc <VectorBC+0x10c>)
 *
 * @notapi
 */
static void i2c_lld_serve_event_interrupt(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t regSR2 = dp->SR2;
 80022e2:	69a3      	ldr	r3, [r4, #24]
  uint32_t event = dp->SR1;
 80022e4:	6966      	ldr	r6, [r4, #20]

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 80022e6:	ea46 4303 	orr.w	r3, r6, r3, lsl #16
 80022ea:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80022ee:	4293      	cmp	r3, r2
 80022f0:	d04e      	beq.n	8002390 <VectorBC+0xc0>
 80022f2:	d823      	bhi.n	800233c <VectorBC+0x6c>
 80022f4:	3a07      	subs	r2, #7
 80022f6:	4293      	cmp	r3, r2
 80022f8:	d03e      	beq.n	8002378 <VectorBC+0xa8>
 80022fa:	3201      	adds	r2, #1
 80022fc:	4293      	cmp	r3, r2
 80022fe:	d110      	bne.n	8002322 <VectorBC+0x52>
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8002300:	6862      	ldr	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 8002302:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8002304:	f422 7200 	bic.w	r2, r2, #512	; 0x200
    dmaStreamEnable(i2cp->dmarx);
 8002308:	681b      	ldr	r3, [r3, #0]
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
    break;
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800230a:	6062      	str	r2, [r4, #4]
    dmaStreamEnable(i2cp->dmarx);
 800230c:	681a      	ldr	r2, [r3, #0]
 800230e:	f042 0201 	orr.w	r2, r2, #1
 8002312:	601a      	str	r2, [r3, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
 8002314:	6862      	ldr	r2, [r4, #4]
 8002316:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800231a:	6062      	str	r2, [r4, #4]
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
 800231c:	685b      	ldr	r3, [r3, #4]
 800231e:	2b01      	cmp	r3, #1
 8002320:	d952      	bls.n	80023c8 <VectorBC+0xf8>
    break;
  default:
    break;
  }
  /* Clear ADDR flag. */
  if (event & (I2C_SR1_ADDR | I2C_SR1_ADD10))
 8002322:	f016 0f0a 	tst.w	r6, #10
    (void)dp->SR2;
 8002326:	bf18      	it	ne
 8002328:	69a3      	ldrne	r3, [r4, #24]

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
 800232a:	f000 feb1 	bl	8003090 <_dbg_check_leave_isr>
 800232e:	482a      	ldr	r0, [pc, #168]	; (80023d8 <VectorBC+0x108>)
 8002330:	f000 fc06 	bl	8002b40 <_trace_isr_leave>
}
 8002334:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  OSAL_IRQ_PROLOGUE();

  i2c_lld_serve_event_interrupt(&I2CD1);

  OSAL_IRQ_EPILOGUE();
 8002338:	f7ff b9aa 	b.w	8001690 <_port_irq_epilogue>
  uint32_t event = dp->SR1;

  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
 800233c:	4a28      	ldr	r2, [pc, #160]	; (80023e0 <VectorBC+0x110>)
 800233e:	4293      	cmp	r3, r2
 8002340:	d00f      	beq.n	8002362 <VectorBC+0x92>
 8002342:	3202      	adds	r2, #2
 8002344:	4293      	cmp	r3, r2
 8002346:	d1ec      	bne.n	8002322 <VectorBC+0x52>
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmatx);
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
 8002348:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800234a:	681b      	ldr	r3, [r3, #0]
 800234c:	685f      	ldr	r7, [r3, #4]
 800234e:	b327      	cbz	r7, 800239a <VectorBC+0xca>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8002350:	8c2a      	ldrh	r2, [r5, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8002352:	6823      	ldr	r3, [r4, #0]
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 8002354:	f042 0201 	orr.w	r2, r2, #1
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 8002358:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500
    break;
  case I2C_EV8_2_MASTER_BYTE_TRANSMITTED:
    /* Catches BTF event after the end of transmission.*/
    if (dmaStreamGetTransactionSize(i2cp->dmarx) > 0) {
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
 800235c:	842a      	strh	r2, [r5, #32]
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
 800235e:	6023      	str	r3, [r4, #0]
 8002360:	e7e3      	b.n	800232a <VectorBC+0x5a>
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8002362:	6863      	ldr	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 8002364:	6b2a      	ldr	r2, [r5, #48]	; 0x30
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 8002366:	f423 7300 	bic.w	r3, r3, #512	; 0x200
    dmaStreamEnable(i2cp->dmatx);
 800236a:	6812      	ldr	r2, [r2, #0]
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
    break;
  case I2C_EV6_MASTER_TRA_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800236c:	6063      	str	r3, [r4, #4]
    dmaStreamEnable(i2cp->dmatx);
 800236e:	6813      	ldr	r3, [r2, #0]
 8002370:	f043 0301 	orr.w	r3, r3, #1
 8002374:	6013      	str	r3, [r2, #0]
 8002376:	e7d4      	b.n	8002322 <VectorBC+0x52>
  /* Interrupts are disabled just before dmaStreamEnable() because there
     is no need of interrupts until next transaction begin. All the work is
     done by the DMA.*/
  switch (I2C_EV_MASK & (event | (regSR2 << 16))) {
  case I2C_EV5_MASTER_MODE_SELECT:
    if ((i2cp->addr >> 8) > 0) { 
 8002378:	8c2b      	ldrh	r3, [r5, #32]
 800237a:	0a1a      	lsrs	r2, r3, #8
 800237c:	d00b      	beq.n	8002396 <VectorBC+0xc6>
      /* 10-bit address: 1 1 1 1 0 X X R/W */
      dp->DR = 0xF0 | (0x6 & (i2cp->addr >> 8)) | (0x1 & i2cp->addr);
 800237e:	f003 0301 	and.w	r3, r3, #1
 8002382:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8002386:	f002 0206 	and.w	r2, r2, #6
 800238a:	4313      	orrs	r3, r2
 800238c:	6123      	str	r3, [r4, #16]
 800238e:	e7c8      	b.n	8002322 <VectorBC+0x52>
      dp->DR = i2cp->addr;
    }
    break;
  case I2C_EV9_MASTER_ADD10:
    /* Set second addr byte (10-bit addressing)*/
    dp->DR = (0xFF & (i2cp->addr >> 1));
 8002390:	8c2b      	ldrh	r3, [r5, #32]
 8002392:	f3c3 0347 	ubfx	r3, r3, #1, #8
 8002396:	6123      	str	r3, [r4, #16]
 8002398:	e7c3      	b.n	8002322 <VectorBC+0x52>
      /* Starts "read after write" operation, LSB = 1 -> receive.*/
      i2cp->addr |= 0x01;
      dp->CR1 |= I2C_CR1_START | I2C_CR1_ACK;
      return;
    }
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
 800239a:	6863      	ldr	r3, [r4, #4]
 800239c:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 80023a0:	6063      	str	r3, [r4, #4]
    dp->CR1 |= I2C_CR1_STOP;
 80023a2:	6823      	ldr	r3, [r4, #0]
 80023a4:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80023a8:	6023      	str	r3, [r4, #0]
 80023aa:	2320      	movs	r3, #32
 80023ac:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80023b0:	f000 feb6 	bl	8003120 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 80023b4:	f105 001c 	add.w	r0, r5, #28
 80023b8:	4639      	mov	r1, r7
 80023ba:	f000 fe51 	bl	8003060 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80023be:	f000 fe97 	bl	80030f0 <_dbg_check_unlock_from_isr>
 80023c2:	f387 8811 	msr	BASEPRI, r7
 80023c6:	e7ac      	b.n	8002322 <VectorBC+0x52>
  case I2C_EV6_MASTER_REC_MODE_SELECTED:
    dp->CR2 &= ~I2C_CR2_ITEVTEN;
    dmaStreamEnable(i2cp->dmarx);
    dp->CR2 |= I2C_CR2_LAST;                 /* Needed in receiver mode. */
    if (dmaStreamGetTransactionSize(i2cp->dmarx) < 2)
      dp->CR1 &= ~I2C_CR1_ACK;
 80023c8:	6823      	ldr	r3, [r4, #0]
 80023ca:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80023ce:	6023      	str	r3, [r4, #0]
 80023d0:	e7a7      	b.n	8002322 <VectorBC+0x52>
 80023d2:	bf00      	nop
 80023d4:	20001c2c 	.word	0x20001c2c
 80023d8:	08004f94 	.word	0x08004f94
 80023dc:	00030008 	.word	0x00030008
 80023e0:	00070082 	.word	0x00070082
	...

080023f0 <i2c_lld_serve_tx_end_irq.lto_priv.58>:
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80023f0:	f011 0f0c 	tst.w	r1, #12
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_serve_tx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 80023f4:	b510      	push	{r4, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 80023f6:	6b44      	ldr	r4, [r0, #52]	; 0x34

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80023f8:	d112      	bne.n	8002420 <i2c_lld_serve_tx_end_irq.lto_priv.58+0x30>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmatx);
 80023fa:	6b01      	ldr	r1, [r0, #48]	; 0x30
 80023fc:	680a      	ldr	r2, [r1, #0]
 80023fe:	6813      	ldr	r3, [r2, #0]
 8002400:	f023 031f 	bic.w	r3, r3, #31
 8002404:	6013      	str	r3, [r2, #0]
 8002406:	6813      	ldr	r3, [r2, #0]
 8002408:	07db      	lsls	r3, r3, #31
 800240a:	d4fc      	bmi.n	8002406 <i2c_lld_serve_tx_end_irq.lto_priv.58+0x16>
 800240c:	7a08      	ldrb	r0, [r1, #8]
 800240e:	684a      	ldr	r2, [r1, #4]
 8002410:	233d      	movs	r3, #61	; 0x3d
 8002412:	4083      	lsls	r3, r0
 8002414:	6013      	str	r3, [r2, #0]
  /* Enables interrupts to catch BTF event meaning transmission part complete.
     Interrupt handler will decide to generate STOP or to begin receiving part
     of R/W transaction itself.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 8002416:	6863      	ldr	r3, [r4, #4]
 8002418:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800241c:	6063      	str	r3, [r4, #4]
 800241e:	bd10      	pop	{r4, pc}
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 8002420:	4801      	ldr	r0, [pc, #4]	; (8002428 <i2c_lld_serve_tx_end_irq.lto_priv.58+0x38>)
 8002422:	f000 fbfd 	bl	8002c20 <chSysHalt>
 8002426:	bf00      	nop
 8002428:	08004ec8 	.word	0x08004ec8
 800242c:	00000000 	.word	0x00000000

08002430 <i2c_lld_serve_rx_end_irq.lto_priv.57>:
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8002430:	f011 0f0c 	tst.w	r1, #12
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 *
 * @notapi
 */
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8002434:	b570      	push	{r4, r5, r6, lr}
  I2C_TypeDef *dp = i2cp->i2c;
 8002436:	6b42      	ldr	r2, [r0, #52]	; 0x34
 * @param[in] i2cp      pointer to the @p I2CDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 *
 * @notapi
 */
static void i2c_lld_serve_rx_end_irq(I2CDriver *i2cp, uint32_t flags) {
 8002438:	4605      	mov	r5, r0
  I2C_TypeDef *dp = i2cp->i2c;

  /* DMA errors handling.*/
#if defined(STM32_I2C_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800243a:	d129      	bne.n	8002490 <i2c_lld_serve_rx_end_irq.lto_priv.57+0x60>
  }
#else
  (void)flags;
#endif

  dmaStreamDisable(i2cp->dmarx);
 800243c:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 800243e:	6803      	ldr	r3, [r0, #0]
 8002440:	6819      	ldr	r1, [r3, #0]
 8002442:	f021 011f 	bic.w	r1, r1, #31
 8002446:	6019      	str	r1, [r3, #0]
 8002448:	6819      	ldr	r1, [r3, #0]
 800244a:	f011 0401 	ands.w	r4, r1, #1
 800244e:	d1fb      	bne.n	8002448 <i2c_lld_serve_rx_end_irq.lto_priv.57+0x18>
 8002450:	7a06      	ldrb	r6, [r0, #8]
 8002452:	6841      	ldr	r1, [r0, #4]
 8002454:	233d      	movs	r3, #61	; 0x3d
 8002456:	40b3      	lsls	r3, r6
 8002458:	600b      	str	r3, [r1, #0]

  dp->CR2 &= ~I2C_CR2_LAST;
 800245a:	6853      	ldr	r3, [r2, #4]
 800245c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8002460:	6053      	str	r3, [r2, #4]
  dp->CR1 &= ~I2C_CR1_ACK;
 8002462:	6813      	ldr	r3, [r2, #0]
 8002464:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8002468:	6013      	str	r3, [r2, #0]
  dp->CR1 |= I2C_CR1_STOP;
 800246a:	6813      	ldr	r3, [r2, #0]
 800246c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8002470:	6013      	str	r3, [r2, #0]
 8002472:	2320      	movs	r3, #32
 8002474:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8002478:	f000 fe52 	bl	8003120 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 800247c:	f105 001c 	add.w	r0, r5, #28
 8002480:	4621      	mov	r1, r4
 8002482:	f000 fded 	bl	8003060 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8002486:	f000 fe33 	bl	80030f0 <_dbg_check_unlock_from_isr>
 800248a:	f384 8811 	msr	BASEPRI, r4
 800248e:	bd70      	pop	{r4, r5, r6, pc}
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {

  chSysHalt(reason);
 8002490:	4801      	ldr	r0, [pc, #4]	; (8002498 <i2c_lld_serve_rx_end_irq.lto_priv.57+0x68>)
 8002492:	f000 fbc5 	bl	8002c20 <chSysHalt>
 8002496:	bf00      	nop
 8002498:	08004ec8 	.word	0x08004ec8
 800249c:	00000000 	.word	0x00000000

080024a0 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 80024a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80024a4:	4605      	mov	r5, r0
 80024a6:	460e      	mov	r6, r1
 80024a8:	4690      	mov	r8, r2
 80024aa:	4699      	mov	r9, r3
  USBInEndpointState *isp;

  osalDbgCheckClassI();
 80024ac:	f000 fc10 	bl	8002cd0 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 80024b0:	b1cd      	cbz	r5, 80024e6 <usbStartTransmitI+0x46>
 80024b2:	2e03      	cmp	r6, #3
 80024b4:	d817      	bhi.n	80024e6 <usbStartTransmitI+0x46>
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");
 80024b6:	2401      	movs	r4, #1
 80024b8:	40b4      	lsls	r4, r6
 80024ba:	8928      	ldrh	r0, [r5, #8]
 80024bc:	b2a4      	uxth	r4, r4
 80024be:	ea14 0700 	ands.w	r7, r4, r0
 80024c2:	d110      	bne.n	80024e6 <usbStartTransmitI+0x46>
  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 80024c4:	eb05 0386 	add.w	r3, r5, r6, lsl #2
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80024c8:	4304      	orrs	r4, r0

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 80024ca:	68db      	ldr	r3, [r3, #12]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80024cc:	812c      	strh	r4, [r5, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 80024ce:	6959      	ldr	r1, [r3, #20]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 80024d0:	4628      	mov	r0, r5

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
  /*lint -restore*/
  isp->txbuf  = buf;
 80024d2:	f8c1 8008 	str.w	r8, [r1, #8]
  isp->txsize = n;
 80024d6:	f8c1 9000 	str.w	r9, [r1]
  isp->txcnt  = 0;
 80024da:	604f      	str	r7, [r1, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 80024dc:	4631      	mov	r1, r6
}
 80024de:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 80024e2:	f001 bdcd 	b.w	8004080 <usb_lld_start_in>
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
  USBInEndpointState *isp;

  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 80024e6:	4801      	ldr	r0, [pc, #4]	; (80024ec <usbStartTransmitI+0x4c>)
 80024e8:	f000 fb9a 	bl	8002c20 <chSysHalt>
 80024ec:	08004eb4 	.word	0x08004eb4

080024f0 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 80024f0:	b538      	push	{r3, r4, r5, lr}

  (void)ep;
  switch (usbp->ep0state) {
 80024f2:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 80024f6:	4604      	mov	r4, r0

  (void)ep;
  switch (usbp->ep0state) {
 80024f8:	2b06      	cmp	r3, #6
 80024fa:	d805      	bhi.n	8002508 <_usb_ep0out+0x18>
 80024fc:	e8df f003 	tbb	[pc, r3]
 8002500:	1b040404 	.word	0x1b040404
 8002504:	0407      	.short	0x0407
 8002506:	26          	.byte	0x26
 8002507:	00          	.byte	0x00
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 8002508:	481c      	ldr	r0, [pc, #112]	; (800257c <_usb_ep0out+0x8c>)
 800250a:	f000 fb89 	bl	8002c20 <chSysHalt>

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 800250e:	2305      	movs	r3, #5
 8002510:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
 8002514:	2320      	movs	r3, #32
 8002516:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800251a:	f000 fe01 	bl	8003120 <_dbg_check_lock_from_isr>
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartTransmitI(usbp, 0, NULL, 0);
 800251e:	2100      	movs	r1, #0
 8002520:	460b      	mov	r3, r1
 8002522:	4620      	mov	r0, r4
 8002524:	460a      	mov	r2, r1
 8002526:	f7ff ffbb 	bl	80024a0 <usbStartTransmitI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800252a:	f000 fde1 	bl	80030f0 <_dbg_check_unlock_from_isr>
 800252e:	2300      	movs	r3, #0
 8002530:	f383 8811 	msr	BASEPRI, r3
 8002534:	bd38      	pop	{r3, r4, r5, pc}
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 8002536:	68c3      	ldr	r3, [r0, #12]
 8002538:	699b      	ldr	r3, [r3, #24]
 800253a:	685b      	ldr	r3, [r3, #4]
 800253c:	b9e3      	cbnz	r3, 8002578 <_usb_ep0out+0x88>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 800253e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8002540:	b103      	cbz	r3, 8002544 <_usb_ep0out+0x54>
      usbp->ep0endcb(usbp);
 8002542:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8002544:	2300      	movs	r3, #0
 8002546:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800254a:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 800254c:	6d43      	ldr	r3, [r0, #84]	; 0x54
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800254e:	6841      	ldr	r1, [r0, #4]
 8002550:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8002554:	680d      	ldr	r5, [r1, #0]
 8002556:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800255a:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800255e:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 8002562:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8002566:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 800256a:	b10d      	cbz	r5, 8002570 <_usb_ep0out+0x80>
 800256c:	2106      	movs	r1, #6
 800256e:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 8002570:	2306      	movs	r3, #6
 8002572:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8002576:	bd38      	pop	{r3, r4, r5, pc}
 8002578:	bd38      	pop	{r3, r4, r5, pc}
 800257a:	bf00      	nop
 800257c:	08004f70 	.word	0x08004f70

08002580 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 8002580:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002584:	4605      	mov	r5, r0
 8002586:	460e      	mov	r6, r1
 8002588:	4690      	mov	r8, r2
 800258a:	4699      	mov	r9, r3
  USBOutEndpointState *osp;

  osalDbgCheckClassI();
 800258c:	f000 fba0 	bl	8002cd0 <chDbgCheckClassI>
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 8002590:	b1cd      	cbz	r5, 80025c6 <usbStartReceiveI+0x46>
 8002592:	2e03      	cmp	r6, #3
 8002594:	d817      	bhi.n	80025c6 <usbStartReceiveI+0x46>
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");
 8002596:	2401      	movs	r4, #1
 8002598:	40b4      	lsls	r4, r6
 800259a:	8968      	ldrh	r0, [r5, #10]
 800259c:	b2a4      	uxth	r4, r4
 800259e:	ea14 0700 	ands.w	r7, r4, r0
 80025a2:	d110      	bne.n	80025c6 <usbStartReceiveI+0x46>
  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 80025a4:	eb05 0386 	add.w	r3, r5, r6, lsl #2
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80025a8:	4304      	orrs	r4, r0

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 80025aa:	68db      	ldr	r3, [r3, #12]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80025ac:	816c      	strh	r4, [r5, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 80025ae:	6999      	ldr	r1, [r3, #24]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 80025b0:	4628      	mov	r0, r5

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
  /*lint -restore*/
  osp->rxbuf  = buf;
 80025b2:	f8c1 8008 	str.w	r8, [r1, #8]
  osp->rxsize = n;
 80025b6:	f8c1 9000 	str.w	r9, [r1]
  osp->rxcnt  = 0;
 80025ba:	604f      	str	r7, [r1, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 80025bc:	4631      	mov	r1, r6
}
 80025be:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 80025c2:	f001 bdb5 	b.w	8004130 <usb_lld_start_out>
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
  USBOutEndpointState *osp;

  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
 80025c6:	4801      	ldr	r0, [pc, #4]	; (80025cc <usbStartReceiveI+0x4c>)
 80025c8:	f000 fb2a 	bl	8002c20 <chSysHalt>
 80025cc:	08004f04 	.word	0x08004f04

080025d0 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 80025d0:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 80025d2:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 80025d6:	4604      	mov	r4, r0
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 80025d8:	2b06      	cmp	r3, #6
 80025da:	d805      	bhi.n	80025e8 <_usb_ep0in+0x18>
 80025dc:	e8df f003 	tbb	[pc, r3]
 80025e0:	04170704 	.word	0x04170704
 80025e4:	2b04      	.short	0x2b04
 80025e6:	32          	.byte	0x32
 80025e7:	00          	.byte	0x00
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
 80025e8:	482b      	ldr	r0, [pc, #172]	; (8002698 <_usb_ep0in+0xc8>)
 80025ea:	f000 fb19 	bl	8002c20 <chSysHalt>

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 80025ee:	f890 104b 	ldrb.w	r1, [r0, #75]	; 0x4b
 80025f2:	f890 304a 	ldrb.w	r3, [r0, #74]	; 0x4a
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80025f6:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 80025f8:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80025fc:	4293      	cmp	r3, r2
 80025fe:	d906      	bls.n	800260e <_usb_ep0in+0x3e>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8002600:	68c3      	ldr	r3, [r0, #12]
 8002602:	8a1d      	ldrh	r5, [r3, #16]
 8002604:	fbb2 f3f5 	udiv	r3, r2, r5
 8002608:	fb05 2513 	mls	r5, r5, r3, r2
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 800260c:	b385      	cbz	r5, 8002670 <_usb_ep0in+0xa0>
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 800260e:	2303      	movs	r3, #3
 8002610:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8002614:	2320      	movs	r3, #32
 8002616:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800261a:	f000 fd81 	bl	8003120 <_dbg_check_lock_from_isr>
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
    usbStartReceiveI(usbp, 0, NULL, 0);
 800261e:	2100      	movs	r1, #0
 8002620:	460b      	mov	r3, r1
 8002622:	4620      	mov	r0, r4
 8002624:	460a      	mov	r2, r1
 8002626:	f7ff ffab 	bl	8002580 <usbStartReceiveI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800262a:	f000 fd61 	bl	80030f0 <_dbg_check_unlock_from_isr>
 800262e:	2300      	movs	r3, #0
 8002630:	f383 8811 	msr	BASEPRI, r3
 8002634:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 8002636:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8002638:	b103      	cbz	r3, 800263c <_usb_ep0in+0x6c>
      usbp->ep0endcb(usbp);
 800263a:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 800263c:	2300      	movs	r3, #0
 800263e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8002642:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8002644:	6d43      	ldr	r3, [r0, #84]	; 0x54
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8002646:	6841      	ldr	r1, [r0, #4]
 8002648:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800264c:	680d      	ldr	r5, [r1, #0]
 800264e:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8002652:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8002656:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800265a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800265e:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8002662:	b10d      	cbz	r5, 8002668 <_usb_ep0in+0x98>
 8002664:	2106      	movs	r1, #6
 8002666:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 8002668:	2306      	movs	r3, #6
 800266a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800266e:	bd38      	pop	{r3, r4, r5, pc}
 8002670:	2320      	movs	r3, #32
 8002672:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8002676:	f000 fd53 	bl	8003120 <_dbg_check_lock_from_isr>
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, NULL, 0);
 800267a:	4620      	mov	r0, r4
 800267c:	4629      	mov	r1, r5
 800267e:	462a      	mov	r2, r5
 8002680:	462b      	mov	r3, r5
 8002682:	f7ff ff0d 	bl	80024a0 <usbStartTransmitI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8002686:	f000 fd33 	bl	80030f0 <_dbg_check_unlock_from_isr>
 800268a:	f385 8811 	msr	BASEPRI, r5
      osalSysUnlockFromISR();
      usbp->ep0state = USB_EP0_WAITING_TX0;
 800268e:	2302      	movs	r3, #2
 8002690:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8002694:	bd38      	pop	{r3, r4, r5, pc}
 8002696:	bf00      	nop
 8002698:	08004f48 	.word	0x08004f48
 800269c:	00000000 	.word	0x00000000

080026a0 <_usb_ep0setup>:
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 80026a0:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 80026a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80026a6:	68cb      	ldr	r3, [r1, #12]
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 80026a8:	2200      	movs	r2, #0
 80026aa:	6a1b      	ldr	r3, [r3, #32]
 80026ac:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
 80026b0:	6819      	ldr	r1, [r3, #0]
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 80026b2:	6842      	ldr	r2, [r0, #4]
 80026b4:	685b      	ldr	r3, [r3, #4]
 80026b6:	6483      	str	r3, [r0, #72]	; 0x48
 80026b8:	6441      	str	r1, [r0, #68]	; 0x44
 80026ba:	6893      	ldr	r3, [r2, #8]
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 80026bc:	4604      	mov	r4, r0
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 80026be:	b333      	cbz	r3, 800270e <_usb_ep0setup+0x6e>
      !(usbp->config->requests_hook_cb(usbp))) {
 80026c0:	4798      	blx	r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 80026c2:	b320      	cbz	r0, 800270e <_usb_ep0setup+0x6e>
 80026c4:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 80026c6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 80026ca:	f894 104b 	ldrb.w	r1, [r4, #75]	; 0x4b
 80026ce:	f894 204a 	ldrb.w	r2, [r4, #74]	; 0x4a
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 80026d2:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 80026d6:	42aa      	cmp	r2, r5
    usbp->ep0n = max;
 80026d8:	bf3c      	itt	cc
 80026da:	63e2      	strcc	r2, [r4, #60]	; 0x3c
 80026dc:	4615      	movcc	r5, r2
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80026de:	061b      	lsls	r3, r3, #24
 80026e0:	f100 808c 	bmi.w	80027fc <_usb_ep0setup+0x15c>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 80026e4:	2d00      	cmp	r5, #0
 80026e6:	d175      	bne.n	80027d4 <_usb_ep0setup+0x134>
      osalSysUnlockFromISR();
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 80026e8:	2305      	movs	r3, #5
 80026ea:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 80026ee:	2320      	movs	r3, #32
 80026f0:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80026f4:	f000 fd14 	bl	8003120 <_dbg_check_lock_from_isr>
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, NULL, 0);
 80026f8:	4620      	mov	r0, r4
 80026fa:	4629      	mov	r1, r5
 80026fc:	462a      	mov	r2, r5
 80026fe:	462b      	mov	r3, r5
 8002700:	f7ff fece 	bl	80024a0 <usbStartTransmitI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8002704:	f000 fcf4 	bl	80030f0 <_dbg_check_unlock_from_isr>
 8002708:	f385 8811 	msr	BASEPRI, r5
 800270c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 800270e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8002712:	f013 0660 	ands.w	r6, r3, #96	; 0x60
 8002716:	d016      	beq.n	8002746 <_usb_ep0setup+0xa6>
 8002718:	6d62      	ldr	r2, [r4, #84]	; 0x54
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 800271a:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
      usb_lld_stall_out(usbp, 0);
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800271e:	6861      	ldr	r1, [r4, #4]
 8002720:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8002724:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8002728:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 800272c:	680d      	ldr	r5, [r1, #0]
 800272e:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8002732:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 8002736:	b115      	cbz	r5, 800273e <_usb_ep0setup+0x9e>
 8002738:	4620      	mov	r0, r4
 800273a:	2106      	movs	r1, #6
 800273c:	47a8      	blx	r5
      usbp->ep0state = USB_EP0_ERROR;
 800273e:	2306      	movs	r3, #6
 8002740:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8002744:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 8002746:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800274a:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 800274e:	ea42 2505 	orr.w	r5, r2, r5, lsl #8
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8002752:	f5b5 7f40 	cmp.w	r5, #768	; 0x300
 8002756:	f000 811a 	beq.w	800298e <_usb_ep0setup+0x2ee>
 800275a:	d917      	bls.n	800278c <_usb_ep0setup+0xec>
 800275c:	f5b5 6fc0 	cmp.w	r5, #1536	; 0x600
 8002760:	f000 80fc 	beq.w	800295c <_usb_ep0setup+0x2bc>
 8002764:	d972      	bls.n	800284c <_usb_ep0setup+0x1ac>
 8002766:	f5b5 6f10 	cmp.w	r5, #2304	; 0x900
 800276a:	f000 8082 	beq.w	8002872 <_usb_ep0setup+0x1d2>
 800276e:	f640 4202 	movw	r2, #3074	; 0xc02
 8002772:	4295      	cmp	r5, r2
 8002774:	f000 80d5 	beq.w	8002922 <_usb_ep0setup+0x282>
 8002778:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 800277c:	d1cc      	bne.n	8002718 <_usb_ep0setup+0x78>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 800277e:	f104 024f 	add.w	r2, r4, #79	; 0x4f
 8002782:	2501      	movs	r5, #1
 8002784:	6426      	str	r6, [r4, #64]	; 0x40
 8002786:	63a2      	str	r2, [r4, #56]	; 0x38
 8002788:	63e5      	str	r5, [r4, #60]	; 0x3c
 800278a:	e79e      	b.n	80026ca <_usb_ep0setup+0x2a>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800278c:	2d02      	cmp	r5, #2
 800278e:	f000 80cf 	beq.w	8002930 <_usb_ep0setup+0x290>
 8002792:	f240 80ba 	bls.w	800290a <_usb_ep0setup+0x26a>
 8002796:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 800279a:	f000 8098 	beq.w	80028ce <_usb_ep0setup+0x22e>
 800279e:	f5b5 7f81 	cmp.w	r5, #258	; 0x102
 80027a2:	d1b9      	bne.n	8002718 <_usb_ep0setup+0x78>
        return false;
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80027a4:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 80027a8:	2a00      	cmp	r2, #0
 80027aa:	d1b5      	bne.n	8002718 <_usb_ep0setup+0x78>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80027ac:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
 80027b0:	f012 010f 	ands.w	r1, r2, #15
 80027b4:	d058      	beq.n	8002868 <_usb_ep0setup+0x1c8>
 80027b6:	6d63      	ldr	r3, [r4, #84]	; 0x54
 80027b8:	eb03 1341 	add.w	r3, r3, r1, lsl #5
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80027bc:	0611      	lsls	r1, r2, #24
 80027be:	f100 8113 	bmi.w	80029e8 <_usb_ep0setup+0x348>
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 80027c2:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 80027c6:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80027ca:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 80027ce:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80027d2:	e049      	b.n	8002868 <_usb_ep0setup+0x1c8>
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 80027d4:	2304      	movs	r3, #4
 80027d6:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 80027da:	2320      	movs	r3, #32
 80027dc:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80027e0:	f000 fc9e 	bl	8003120 <_dbg_check_lock_from_isr>
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 80027e4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80027e6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80027e8:	4620      	mov	r0, r4
 80027ea:	2100      	movs	r1, #0
 80027ec:	f7ff fec8 	bl	8002580 <usbStartReceiveI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80027f0:	f000 fc7e 	bl	80030f0 <_dbg_check_unlock_from_isr>
 80027f4:	2300      	movs	r3, #0
 80027f6:	f383 8811 	msr	BASEPRI, r3
 80027fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 80027fc:	b19d      	cbz	r5, 8002826 <_usb_ep0setup+0x186>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 80027fe:	2301      	movs	r3, #1
 8002800:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8002804:	2320      	movs	r3, #32
 8002806:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800280a:	f000 fc89 	bl	8003120 <_dbg_check_lock_from_isr>
      osalSysLockFromISR();
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 800280e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002810:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002812:	4620      	mov	r0, r4
 8002814:	2100      	movs	r1, #0
 8002816:	f7ff fe43 	bl	80024a0 <usbStartTransmitI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800281a:	f000 fc69 	bl	80030f0 <_dbg_check_unlock_from_isr>
 800281e:	2300      	movs	r3, #0
 8002820:	f383 8811 	msr	BASEPRI, r3
 8002824:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      osalSysUnlockFromISR();
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 8002826:	2303      	movs	r3, #3
 8002828:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800282c:	2320      	movs	r3, #32
 800282e:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8002832:	f000 fc75 	bl	8003120 <_dbg_check_lock_from_isr>
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
      usbStartReceiveI(usbp, 0, NULL, 0);
 8002836:	4620      	mov	r0, r4
 8002838:	4629      	mov	r1, r5
 800283a:	462a      	mov	r2, r5
 800283c:	462b      	mov	r3, r5
 800283e:	f7ff fe9f 	bl	8002580 <usbStartReceiveI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8002842:	f000 fc55 	bl	80030f0 <_dbg_check_unlock_from_isr>
 8002846:	f385 8811 	msr	BASEPRI, r5
 800284a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800284c:	f240 3202 	movw	r2, #770	; 0x302
 8002850:	4295      	cmp	r5, r2
 8002852:	d023      	beq.n	800289c <_usb_ep0setup+0x1fc>
 8002854:	f5b5 6fa0 	cmp.w	r5, #1280	; 0x500
 8002858:	f47f af5e 	bne.w	8002718 <_usb_ep0setup+0x78>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800285c:	f8b4 2044 	ldrh.w	r2, [r4, #68]	; 0x44
 8002860:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 8002864:	f000 80a8 	beq.w	80029b8 <_usb_ep0setup+0x318>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8002868:	2500      	movs	r5, #0
 800286a:	63a5      	str	r5, [r4, #56]	; 0x38
 800286c:	63e5      	str	r5, [r4, #60]	; 0x3c
 800286e:	6425      	str	r5, [r4, #64]	; 0x40
 8002870:	e72b      	b.n	80026ca <_usb_ep0setup+0x2a>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host only if it is different
       from the current configuration.*/
    if (usbp->configuration != usbp->setup[2]) {
 8002872:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 8002876:	f894 104f 	ldrb.w	r1, [r4, #79]	; 0x4f
 800287a:	4291      	cmp	r1, r2
 800287c:	d0f4      	beq.n	8002868 <_usb_ep0setup+0x1c8>
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
 800287e:	7823      	ldrb	r3, [r4, #0]
 8002880:	2b04      	cmp	r3, #4
 8002882:	d034      	beq.n	80028ee <_usb_ep0setup+0x24e>
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
 8002884:	b302      	cbz	r2, 80028c8 <_usb_ep0setup+0x228>
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
        usbp->state = USB_ACTIVE;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8002886:	6863      	ldr	r3, [r4, #4]
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
 8002888:	f884 204f 	strb.w	r2, [r4, #79]	; 0x4f
        usbp->state = USB_ACTIVE;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 800288c:	681b      	ldr	r3, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
      }
      if (usbp->setup[2] != 0U) {
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
        usbp->state = USB_ACTIVE;
 800288e:	2204      	movs	r2, #4
 8002890:	7022      	strb	r2, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8002892:	b1cb      	cbz	r3, 80028c8 <_usb_ep0setup+0x228>
 8002894:	4620      	mov	r0, r4
 8002896:	2102      	movs	r1, #2
 8002898:	4798      	blx	r3
 800289a:	e015      	b.n	80028c8 <_usb_ep0setup+0x228>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 800289c:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 80028a0:	2a00      	cmp	r2, #0
 80028a2:	f47f af39 	bne.w	8002718 <_usb_ep0setup+0x78>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80028a6:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
 80028aa:	f012 010f 	ands.w	r1, r2, #15
 80028ae:	d0db      	beq.n	8002868 <_usb_ep0setup+0x1c8>
 80028b0:	6d63      	ldr	r3, [r4, #84]	; 0x54
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80028b2:	0612      	lsls	r2, r2, #24
 80028b4:	eb03 1341 	add.w	r3, r3, r1, lsl #5
 80028b8:	f100 809f 	bmi.w	80029fa <_usb_ep0setup+0x35a>
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 80028bc:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 80028c0:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80028c4:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 80028c8:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80028cc:	e7cc      	b.n	8002868 <_usb_ep0setup+0x1c8>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80028ce:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 80028d2:	2a01      	cmp	r2, #1
 80028d4:	f47f af20 	bne.w	8002718 <_usb_ep0setup+0x78>
      usbp->status &= ~2U;
 80028d8:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80028dc:	63a6      	str	r6, [r4, #56]	; 0x38
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 80028de:	f022 0202 	bic.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80028e2:	63e6      	str	r6, [r4, #60]	; 0x3c
 80028e4:	6426      	str	r6, [r4, #64]	; 0x40
 80028e6:	4635      	mov	r5, r6
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 80028e8:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
 80028ec:	e6ed      	b.n	80026ca <_usb_ep0setup+0x2a>
 80028ee:	2320      	movs	r3, #32
 80028f0:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80028f4:	f000 fc14 	bl	8003120 <_dbg_check_lock_from_isr>
 * @iclass
 */
void usbDisableEndpointsI(USBDriver *usbp) {
  unsigned i;

  osalDbgCheckClassI();
 80028f8:	f000 f9ea 	bl	8002cd0 <chDbgCheckClassI>
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");
 80028fc:	7823      	ldrb	r3, [r4, #0]
 80028fe:	2b04      	cmp	r3, #4
 8002900:	f000 8084 	beq.w	8002a0c <_usb_ep0setup+0x36c>
 8002904:	485f      	ldr	r0, [pc, #380]	; (8002a84 <_usb_ep0setup+0x3e4>)
 8002906:	f000 f98b 	bl	8002c20 <chSysHalt>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800290a:	b93d      	cbnz	r5, 800291c <_usb_ep0setup+0x27c>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 800290c:	2202      	movs	r2, #2
 800290e:	f104 014c 	add.w	r1, r4, #76	; 0x4c
 8002912:	6425      	str	r5, [r4, #64]	; 0x40
 8002914:	63a1      	str	r1, [r4, #56]	; 0x38
 8002916:	63e2      	str	r2, [r4, #60]	; 0x3c
 8002918:	4615      	mov	r5, r2
 800291a:	e6d6      	b.n	80026ca <_usb_ep0setup+0x2a>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800291c:	2d01      	cmp	r5, #1
 800291e:	f47f aefb 	bne.w	8002718 <_usb_ep0setup+0x78>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8002922:	4a59      	ldr	r2, [pc, #356]	; (8002a88 <_usb_ep0setup+0x3e8>)
 8002924:	63a2      	str	r2, [r4, #56]	; 0x38
 8002926:	2502      	movs	r5, #2
 8002928:	2200      	movs	r2, #0
 800292a:	63e5      	str	r5, [r4, #60]	; 0x3c
 800292c:	6422      	str	r2, [r4, #64]	; 0x40
 800292e:	e6cc      	b.n	80026ca <_usb_ep0setup+0x2a>
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8002930:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 8002934:	f002 010f 	and.w	r1, r2, #15
 8002938:	0617      	lsls	r7, r2, #24
 800293a:	bf4c      	ite	mi
 800293c:	3148      	addmi	r1, #72	; 0x48
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 800293e:	3158      	addpl	r1, #88	; 0x58
 8002940:	0149      	lsls	r1, r1, #5
 8002942:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8002944:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 8002946:	0408      	lsls	r0, r1, #16
 8002948:	f57f aee7 	bpl.w	800271a <_usb_ep0setup+0x7a>
    return EP_STATUS_DISABLED;
  if (ctl & DOEPCTL_STALL)
 800294c:	f411 1100 	ands.w	r1, r1, #2097152	; 0x200000
 8002950:	d12d      	bne.n	80029ae <_usb_ep0setup+0x30e>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
        /*lint -restore*/
        return true;
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8002952:	4a4e      	ldr	r2, [pc, #312]	; (8002a8c <_usb_ep0setup+0x3ec>)
 8002954:	63e5      	str	r5, [r4, #60]	; 0x3c
 8002956:	6421      	str	r1, [r4, #64]	; 0x40
 8002958:	63a2      	str	r2, [r4, #56]	; 0x38
 800295a:	e6b6      	b.n	80026ca <_usb_ep0setup+0x2a>
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 800295c:	6862      	ldr	r2, [r4, #4]

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 800295e:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 8002962:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8002966:	6855      	ldr	r5, [r2, #4]
 8002968:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
 800296c:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 8002970:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8002974:	4620      	mov	r0, r4
 8002976:	47a8      	blx	r5
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 8002978:	2800      	cmp	r0, #0
 800297a:	f43f aecd 	beq.w	8002718 <_usb_ep0setup+0x78>
      return false;
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 800297e:	6843      	ldr	r3, [r0, #4]
 8002980:	6805      	ldr	r5, [r0, #0]
 8002982:	63e5      	str	r5, [r4, #60]	; 0x3c
 8002984:	63a3      	str	r3, [r4, #56]	; 0x38
 8002986:	6426      	str	r6, [r4, #64]	; 0x40
 8002988:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800298c:	e69d      	b.n	80026ca <_usb_ep0setup+0x2a>
    }
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800298e:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 8002992:	2a01      	cmp	r2, #1
 8002994:	f47f aec0 	bne.w	8002718 <_usb_ep0setup+0x78>
      usbp->status |= 2U;
 8002998:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800299c:	63a6      	str	r6, [r4, #56]	; 0x38
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 800299e:	f042 0202 	orr.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 80029a2:	63e6      	str	r6, [r4, #60]	; 0x3c
 80029a4:	6426      	str	r6, [r4, #64]	; 0x40
 80029a6:	4635      	mov	r5, r6
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 80029a8:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
 80029ac:	e68d      	b.n	80026ca <_usb_ep0setup+0x2a>
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 80029ae:	4a38      	ldr	r2, [pc, #224]	; (8002a90 <_usb_ep0setup+0x3f0>)
 80029b0:	63e5      	str	r5, [r4, #60]	; 0x3c
 80029b2:	6426      	str	r6, [r4, #64]	; 0x40
 80029b4:	63a2      	str	r2, [r4, #56]	; 0x38
 80029b6:	e688      	b.n	80026ca <_usb_ep0setup+0x2a>
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {

  usbp->address = usbp->setup[2];
 80029b8:	f894 1046 	ldrb.w	r1, [r4, #70]	; 0x46
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 80029bc:	6d62      	ldr	r2, [r4, #84]	; 0x54
 80029be:	f884 104e 	strb.w	r1, [r4, #78]	; 0x4e

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 80029c2:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
  usb_lld_set_address(usbp);
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 80029c6:	6860      	ldr	r0, [r4, #4]
 80029c8:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80029cc:	6805      	ldr	r5, [r0, #0]
 80029ce:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 80029d2:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
 80029d6:	b115      	cbz	r5, 80029de <_usb_ep0setup+0x33e>
 80029d8:	4620      	mov	r0, r4
 80029da:	2101      	movs	r1, #1
 80029dc:	47a8      	blx	r5
  usbp->state = USB_SELECTED;
 80029de:	2203      	movs	r2, #3
 80029e0:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80029e4:	7022      	strb	r2, [r4, #0]
 80029e6:	e73f      	b.n	8002868 <_usb_ep0setup+0x1c8>
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 80029e8:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 80029ec:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80029f0:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 80029f4:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80029f8:	e736      	b.n	8002868 <_usb_ep0setup+0x1c8>
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 80029fa:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 80029fe:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8002a02:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
 8002a06:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8002a0a:	e72d      	b.n	8002868 <_usb_ep0setup+0x1c8>
 8002a0c:	6da0      	ldr	r0, [r4, #88]	; 0x58

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8002a0e:	8921      	ldrh	r1, [r4, #8]
  usbp->receiving    &= 1U;
 8002a10:	8963      	ldrh	r3, [r4, #10]
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8002a12:	6802      	ldr	r2, [r0, #0]
 8002a14:	65e2      	str	r2, [r4, #92]	; 0x5c

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8002a16:	f001 0101 	and.w	r1, r1, #1
  usbp->receiving    &= 1U;
 8002a1a:	f003 0301 	and.w	r3, r3, #1
 8002a1e:	6d67      	ldr	r7, [r4, #84]	; 0x54
 8002a20:	f8d0 e008 	ldr.w	lr, [r0, #8]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8002a24:	8121      	strh	r1, [r4, #8]

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8002a26:	4632      	mov	r2, r6
      if (usbp->epc[i]->out_state != NULL) {
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
    }
#endif
    usbp->epc[i] = NULL;
 8002a28:	6126      	str	r6, [r4, #16]
 8002a2a:	6166      	str	r6, [r4, #20]
 8002a2c:	61a6      	str	r6, [r4, #24]
  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
  usbp->receiving    &= 1U;
 8002a2e:	8163      	strh	r3, [r4, #10]
    otgp->ie[i].DIEPCTL = 0;
 8002a30:	4631      	mov	r1, r6
    otgp->ie[i].DIEPTSIZ = 0;
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8002a32:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8002a36:	eb07 1342 	add.w	r3, r7, r2, lsl #5

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8002a3a:	3201      	adds	r2, #1
 8002a3c:	4572      	cmp	r2, lr
    otgp->ie[i].DIEPCTL = 0;
 8002a3e:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
 8002a42:	f04f 0500 	mov.w	r5, #0
    otgp->ie[i].DIEPTSIZ = 0;
 8002a46:	f8c3 1910 	str.w	r1, [r3, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8002a4a:	f8c3 0908 	str.w	r0, [r3, #2312]	; 0x908

    otgp->oe[i].DOEPCTL = 0;
 8002a4e:	f8c3 1b00 	str.w	r1, [r3, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
 8002a52:	f8c3 1b10 	str.w	r1, [r3, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8002a56:	f8c3 0b08 	str.w	r0, [r3, #2824]	; 0xb08

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8002a5a:	d9ec      	bls.n	8002a36 <_usb_ep0setup+0x396>

    otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8002a5c:	f04f 1301 	mov.w	r3, #65537	; 0x10001
 8002a60:	f8c7 381c 	str.w	r3, [r7, #2076]	; 0x81c
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8002a64:	f000 fb44 	bl	80030f0 <_dbg_check_unlock_from_isr>
 8002a68:	f385 8811 	msr	BASEPRI, r5
        osalSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8002a6c:	6863      	ldr	r3, [r4, #4]
      if (usbp->state == USB_ACTIVE) {
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
 8002a6e:	f884 504f 	strb.w	r5, [r4, #79]	; 0x4f
        usbp->state = USB_SELECTED;
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8002a72:	681b      	ldr	r3, [r3, #0]
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
        usbDisableEndpointsI(usbp);
        osalSysUnlockFromISR ();
        usbp->configuration = 0U;
        usbp->state = USB_SELECTED;
 8002a74:	2103      	movs	r1, #3
 8002a76:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8002a78:	b10b      	cbz	r3, 8002a7e <_usb_ep0setup+0x3de>
 8002a7a:	4620      	mov	r0, r4
 8002a7c:	4798      	blx	r3
 8002a7e:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 8002a82:	e6ff      	b.n	8002884 <_usb_ep0setup+0x1e4>
 8002a84:	08004ed4 	.word	0x08004ed4
 8002a88:	08004ea0 	.word	0x08004ea0
 8002a8c:	08004f6c 	.word	0x08004f6c
 8002a90:	08004ea4 	.word	0x08004ea4
	...

08002aa0 <trace_next>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {
 8002aa0:	b410      	push	{r4}

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8002aa2:	4a0b      	ldr	r2, [pc, #44]	; (8002ad0 <trace_next+0x30>)
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8002aa4:	480b      	ldr	r0, [pc, #44]	; (8002ad4 <trace_next+0x34>)
 8002aa6:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8002aa8:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8002aac:	6819      	ldr	r1, [r3, #0]
 8002aae:	6a64      	ldr	r4, [r4, #36]	; 0x24
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8002ab0:	605c      	str	r4, [r3, #4]
 8002ab2:	6840      	ldr	r0, [r0, #4]
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8002ab4:	f360 211f 	bfi	r1, r0, #8, #24
 8002ab8:	f843 1b10 	str.w	r1, [r3], #16
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 8002abc:	f502 6104 	add.w	r1, r2, #2112	; 0x840
 8002ac0:	428b      	cmp	r3, r1
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 8002ac2:	bf28      	it	cs
 8002ac4:	f102 0340 	addcs.w	r3, r2, #64	; 0x40
 8002ac8:	63d3      	str	r3, [r2, #60]	; 0x3c
  }
}
 8002aca:	f85d 4b04 	ldr.w	r4, [sp], #4
 8002ace:	4770      	bx	lr
 8002ad0:	20001320 	.word	0x20001320
 8002ad4:	e0001000 	.word	0xe0001000
	...

08002ae0 <_idle_thread.lto_priv.77>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8002ae0:	e7fe      	b.n	8002ae0 <_idle_thread.lto_priv.77>
 8002ae2:	bf00      	nop
	...

08002af0 <chTMStopMeasurementX>:
 8002af0:	4b0f      	ldr	r3, [pc, #60]	; (8002b30 <chTMStopMeasurementX+0x40>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8002af2:	4910      	ldr	r1, [pc, #64]	; (8002b34 <chTMStopMeasurementX+0x44>)
 8002af4:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8002af6:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8002af8:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8002afa:	f8d1 7884 	ldr.w	r7, [r1, #2180]	; 0x884
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8002afe:	6841      	ldr	r1, [r0, #4]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8002b00:	68c6      	ldr	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8002b02:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8002b06:	1ad3      	subs	r3, r2, r3
 8002b08:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 8002b0a:	18e4      	adds	r4, r4, r3
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 8002b0c:	6802      	ldr	r2, [r0, #0]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8002b0e:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8002b10:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8002b14:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8002b16:	f106 0601 	add.w	r6, r6, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 8002b1a:	bf88      	it	hi
 8002b1c:	6043      	strhi	r3, [r0, #4]
  }
  if (tmp->last < tmp->best) {
 8002b1e:	4293      	cmp	r3, r2

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8002b20:	60c6      	str	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8002b22:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 8002b26:	bf38      	it	cc
 8002b28:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8002b2a:	bcf0      	pop	{r4, r5, r6, r7}
 8002b2c:	4770      	bx	lr
 8002b2e:	bf00      	nop
 8002b30:	e0001000 	.word	0xe0001000
 8002b34:	20001320 	.word	0x20001320
	...

08002b40 <_trace_isr_leave>:
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002b40:	4b0b      	ldr	r3, [pc, #44]	; (8002b70 <_trace_isr_leave+0x30>)
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {
 8002b42:	b510      	push	{r4, lr}

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002b44:	8f1c      	ldrh	r4, [r3, #56]	; 0x38
 8002b46:	f004 0402 	and.w	r4, r4, #2
 8002b4a:	b2a4      	uxth	r4, r4
 8002b4c:	b97c      	cbnz	r4, 8002b6e <_trace_isr_leave+0x2e>
 8002b4e:	2220      	movs	r2, #32
 8002b50:	f382 8811 	msr	BASEPRI, r2
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002b54:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8002b56:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8002b58:	6090      	str	r0, [r2, #8]
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002b5a:	2103      	movs	r1, #3
 8002b5c:	f361 0302 	bfi	r3, r1, #0, #3
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8002b60:	f364 03c7 	bfi	r3, r4, #3, #5
 8002b64:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
    trace_next();
 8002b66:	f7ff ff9b 	bl	8002aa0 <trace_next>
 8002b6a:	f384 8811 	msr	BASEPRI, r4
 8002b6e:	bd10      	pop	{r4, pc}
 8002b70:	20001320 	.word	0x20001320
	...

08002b80 <_trace_isr_enter>:
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002b80:	4b0b      	ldr	r3, [pc, #44]	; (8002bb0 <_trace_isr_enter+0x30>)
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {
 8002b82:	b510      	push	{r4, lr}

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002b84:	8f1c      	ldrh	r4, [r3, #56]	; 0x38
 8002b86:	f004 0402 	and.w	r4, r4, #2
 8002b8a:	b2a4      	uxth	r4, r4
 8002b8c:	b97c      	cbnz	r4, 8002bae <_trace_isr_enter+0x2e>
 8002b8e:	2220      	movs	r2, #32
 8002b90:	f382 8811 	msr	BASEPRI, r2
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002b94:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8002b96:	7813      	ldrb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8002b98:	6090      	str	r0, [r2, #8]
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002b9a:	2102      	movs	r1, #2
 8002b9c:	f361 0302 	bfi	r3, r1, #0, #3
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8002ba0:	f364 03c7 	bfi	r3, r4, #3, #5
 8002ba4:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
    trace_next();
 8002ba6:	f7ff ff7b 	bl	8002aa0 <trace_next>
 8002baa:	f384 8811 	msr	BASEPRI, r4
 8002bae:	bd10      	pop	{r4, pc}
 8002bb0:	20001320 	.word	0x20001320
	...

08002bc0 <_trace_switch>:
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8002bc0:	4b0c      	ldr	r3, [pc, #48]	; (8002bf4 <_trace_switch+0x34>)
 8002bc2:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 8002bc4:	07d2      	lsls	r2, r2, #31
 8002bc6:	d500      	bpl.n	8002bca <_trace_switch+0xa>
 8002bc8:	4770      	bx	lr
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002bca:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 * @param[in] ntp       the thread being switched in
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {
 8002bcc:	b410      	push	{r4}
  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8002bce:	699c      	ldr	r4, [r3, #24]
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002bd0:	7813      	ldrb	r3, [r2, #0]
 8002bd2:	2001      	movs	r0, #1
 8002bd4:	f360 0302 	bfi	r3, r0, #0, #3
 8002bd8:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8002bda:	f891 0020 	ldrb.w	r0, [r1, #32]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8002bde:	6094      	str	r4, [r2, #8]

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8002be0:	f360 03c7 	bfi	r3, r0, #3, #5
 8002be4:	7013      	strb	r3, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8002be6:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8002be8:	60d3      	str	r3, [r2, #12]
    trace_next();
  }
}
 8002bea:	f85d 4b04 	ldr.w	r4, [sp], #4
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
    trace_next();
 8002bee:	f7ff bf57 	b.w	8002aa0 <trace_next>
 8002bf2:	bf00      	nop
 8002bf4:	20001320 	.word	0x20001320
	...

08002c00 <chSysPolledDelayX>:
 8002c00:	4a03      	ldr	r2, [pc, #12]	; (8002c10 <chSysPolledDelayX+0x10>)
 8002c02:	6851      	ldr	r1, [r2, #4]
 8002c04:	6853      	ldr	r3, [r2, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)((cnt - start) < (end - start));
 8002c06:	1a5b      	subs	r3, r3, r1
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8002c08:	4298      	cmp	r0, r3
 8002c0a:	d8fb      	bhi.n	8002c04 <chSysPolledDelayX+0x4>
  }
}
 8002c0c:	4770      	bx	lr
 8002c0e:	bf00      	nop
 8002c10:	e0001000 	.word	0xe0001000
	...

08002c20 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8002c20:	b508      	push	{r3, lr}
 8002c22:	4605      	mov	r5, r0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002c24:	b672      	cpsid	i
 *
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 8002c26:	4c0a      	ldr	r4, [pc, #40]	; (8002c50 <chSysHalt+0x30>)
 8002c28:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8002c2a:	f003 0304 	and.w	r3, r3, #4
 8002c2e:	b29b      	uxth	r3, r3
 8002c30:	b10b      	cbz	r3, 8002c36 <chSysHalt+0x16>

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8002c32:	62e5      	str	r5, [r4, #44]	; 0x2c
 8002c34:	e7fe      	b.n	8002c34 <chSysHalt+0x14>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8002c36:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8002c38:	780a      	ldrb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->state         = 0;
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 8002c3a:	6088      	str	r0, [r1, #8]
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8002c3c:	2004      	movs	r0, #4
 8002c3e:	f360 0202 	bfi	r2, r0, #0, #3
    ch.dbg.trace_buffer.ptr->state         = 0;
 8002c42:	f363 02c7 	bfi	r2, r3, #3, #5
 8002c46:	700a      	strb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
    trace_next();
 8002c48:	f7ff ff2a 	bl	8002aa0 <trace_next>
 8002c4c:	e7f1      	b.n	8002c32 <chSysHalt+0x12>
 8002c4e:	bf00      	nop
 8002c50:	20001320 	.word	0x20001320
	...

08002c60 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8002c60:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002c62:	4b05      	ldr	r3, [pc, #20]	; (8002c78 <chDbgCheckClassS+0x18>)
 8002c64:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002c66:	b91a      	cbnz	r2, 8002c70 <chDbgCheckClassS+0x10>
 8002c68:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002c6a:	2b00      	cmp	r3, #0
 8002c6c:	dd00      	ble.n	8002c70 <chDbgCheckClassS+0x10>
 8002c6e:	bd08      	pop	{r3, pc}
    chSysHalt("SV#11");
 8002c70:	4802      	ldr	r0, [pc, #8]	; (8002c7c <chDbgCheckClassS+0x1c>)
 8002c72:	f7ff ffd5 	bl	8002c20 <chSysHalt>
 8002c76:	bf00      	nop
 8002c78:	20001320 	.word	0x20001320
 8002c7c:	08005040 	.word	0x08005040

08002c80 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8002c80:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8002c82:	4c11      	ldr	r4, [pc, #68]	; (8002cc8 <chSchGoSleepS+0x48>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8002c84:	4606      	mov	r6, r0
  thread_t *otp = currp;

  chDbgCheckClassS();
 8002c86:	f7ff ffeb 	bl	8002c60 <chDbgCheckClassS>
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8002c8a:	6823      	ldr	r3, [r4, #0]
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 8002c8c:	69a5      	ldr	r5, [r4, #24]

  tqp->next             = tp->queue.next;
 8002c8e:	681a      	ldr	r2, [r3, #0]

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8002c90:	f885 6020 	strb.w	r6, [r5, #32]
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8002c94:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8002c96:	6054      	str	r4, [r2, #4]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002c98:	4618      	mov	r0, r3
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8002c9a:	f883 1020 	strb.w	r1, [r3, #32]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002c9e:	4629      	mov	r1, r5
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8002ca0:	6022      	str	r2, [r4, #0]
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8002ca2:	61a3      	str	r3, [r4, #24]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002ca4:	f7ff ff8c 	bl	8002bc0 <_trace_switch>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8002ca8:	f3ef 8309 	mrs	r3, PSP
 8002cac:	69ea      	ldr	r2, [r5, #28]
 8002cae:	3b64      	subs	r3, #100	; 0x64
 8002cb0:	429a      	cmp	r2, r3
 8002cb2:	d805      	bhi.n	8002cc0 <chSchGoSleepS+0x40>
 8002cb4:	69a0      	ldr	r0, [r4, #24]
 8002cb6:	4629      	mov	r1, r5
}
 8002cb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002cbc:	f7fd bb0e 	b.w	80002dc <_port_switch>
 8002cc0:	4802      	ldr	r0, [pc, #8]	; (8002ccc <chSchGoSleepS+0x4c>)
 8002cc2:	f7ff ffad 	bl	8002c20 <chSysHalt>
 8002cc6:	bf00      	nop
 8002cc8:	20001320 	.word	0x20001320
 8002ccc:	08005048 	.word	0x08005048

08002cd0 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8002cd0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002cd2:	4b05      	ldr	r3, [pc, #20]	; (8002ce8 <chDbgCheckClassI+0x18>)
 8002cd4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002cd6:	2a00      	cmp	r2, #0
 8002cd8:	db03      	blt.n	8002ce2 <chDbgCheckClassI+0x12>
 8002cda:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002cdc:	2b00      	cmp	r3, #0
 8002cde:	dd00      	ble.n	8002ce2 <chDbgCheckClassI+0x12>
 8002ce0:	bd08      	pop	{r3, pc}
    chSysHalt("SV#10");
 8002ce2:	4802      	ldr	r0, [pc, #8]	; (8002cec <chDbgCheckClassI+0x1c>)
 8002ce4:	f7ff ff9c 	bl	8002c20 <chSysHalt>
 8002ce8:	20001320 	.word	0x20001320
 8002cec:	08005058 	.word	0x08005058

08002cf0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8002cf0:	e92d 46f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r9, sl, lr}
 8002cf4:	4604      	mov	r4, r0
  thread_t *tp;

  chDbgCheckClassI();
 8002cf6:	f7ff ffeb 	bl	8002cd0 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 8002cfa:	b134      	cbz	r4, 8002d0a <chThdCreateSuspendedI+0x1a>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8002cfc:	6861      	ldr	r1, [r4, #4]
 8002cfe:	074b      	lsls	r3, r1, #29
 8002d00:	d103      	bne.n	8002d0a <chThdCreateSuspendedI+0x1a>
 8002d02:	68a3      	ldr	r3, [r4, #8]
 8002d04:	f013 0507 	ands.w	r5, r3, #7
 8002d08:	d002      	beq.n	8002d10 <chThdCreateSuspendedI+0x20>
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
  thread_t *tp;

  chDbgCheckClassI();
  chDbgCheck(tdp != NULL);
 8002d0a:	4825      	ldr	r0, [pc, #148]	; (8002da0 <chThdCreateSuspendedI+0xb0>)
 8002d0c:	f7ff ff88 	bl	8002c20 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8002d10:	4299      	cmp	r1, r3
 8002d12:	d2fa      	bcs.n	8002d0a <chThdCreateSuspendedI+0x1a>
 8002d14:	1a5a      	subs	r2, r3, r1
 8002d16:	f5b2 7fa8 	cmp.w	r2, #336	; 0x150
 8002d1a:	d3f6      	bcc.n	8002d0a <chThdCreateSuspendedI+0x1a>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8002d1c:	68e0      	ldr	r0, [r4, #12]
 8002d1e:	28ff      	cmp	r0, #255	; 0xff
 8002d20:	d8f3      	bhi.n	8002d0a <chThdCreateSuspendedI+0x1a>
 8002d22:	f8d4 c010 	ldr.w	ip, [r4, #16]
 8002d26:	f1bc 0f00 	cmp.w	ip, #0
 8002d2a:	d0ee      	beq.n	8002d0a <chThdCreateSuspendedI+0x1a>
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8002d2c:	4a1d      	ldr	r2, [pc, #116]	; (8002da4 <chThdCreateSuspendedI+0xb4>)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002d2e:	6966      	ldr	r6, [r4, #20]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8002d30:	6824      	ldr	r4, [r4, #0]
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8002d32:	f803 5c27 	strb.w	r5, [r3, #-39]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8002d36:	f04f 0e02 	mov.w	lr, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8002d3a:	2701      	movs	r7, #1
 8002d3c:	f803 7c26 	strb.w	r7, [r3, #-38]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8002d40:	f803 ec28 	strb.w	lr, [r3, #-40]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002d44:	f843 6c68 	str.w	r6, [r3, #-104]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8002d48:	6956      	ldr	r6, [r2, #20]

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8002d4a:	f843 4c30 	str.w	r4, [r3, #-48]
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8002d4e:	f843 1c2c 	str.w	r1, [r3, #-44]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8002d52:	f1a3 071c 	sub.w	r7, r3, #28
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8002d56:	f1a3 0148 	sub.w	r1, r3, #72	; 0x48
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002d5a:	f8df 904c 	ldr.w	r9, [pc, #76]	; 8002da8 <chThdCreateSuspendedI+0xb8>
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8002d5e:	f843 0c40 	str.w	r0, [r3, #-64]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002d62:	f1a3 0aac 	sub.w	sl, r3, #172	; 0xac
  REG_INSERT(tp);
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 8002d66:	f1a3 0420 	sub.w	r4, r3, #32
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8002d6a:	f843 0c0c 	str.w	r0, [r3, #-12]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002d6e:	f843 cc6c 	str.w	ip, [r3, #-108]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8002d72:	f843 5c10 	str.w	r5, [r3, #-16]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8002d76:	f843 5c14 	str.w	r5, [r3, #-20]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8002d7a:	f843 2c38 	str.w	r2, [r3, #-56]
 8002d7e:	f843 6c34 	str.w	r6, [r3, #-52]
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8002d82:	f843 ac3c 	str.w	sl, [r3, #-60]
 8002d86:	f843 9c4c 	str.w	r9, [r3, #-76]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 8002d8a:	4608      	mov	r0, r1
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8002d8c:	6131      	str	r1, [r6, #16]
 8002d8e:	6151      	str	r1, [r2, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8002d90:	f843 4c20 	str.w	r4, [r3, #-32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002d94:	f843 7c1c 	str.w	r7, [r3, #-28]
  tqp->prev = (thread_t *)tqp;
 8002d98:	f843 7c18 	str.w	r7, [r3, #-24]
  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 8002d9c:	e8bd 86f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r9, sl, pc}
 8002da0:	08004fc4 	.word	0x08004fc4
 8002da4:	20001320 	.word	0x20001320
 8002da8:	080002f5 	.word	0x080002f5
 8002dac:	00000000 	.word	0x00000000

08002db0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8002db0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002db4:	460d      	mov	r5, r1
 8002db6:	b086      	sub	sp, #24
 8002db8:	4680      	mov	r8, r0

  chDbgCheckClassS();
 8002dba:	f7ff ff51 	bl	8002c60 <chDbgCheckClassS>

  if (TIME_INFINITE != time) {
 8002dbe:	1c6b      	adds	r3, r5, #1
 8002dc0:	d053      	beq.n	8002e6a <chSchGoSleepTimeoutS+0xba>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8002dc2:	4f4e      	ldr	r7, [pc, #312]	; (8002efc <chSchGoSleepTimeoutS+0x14c>)
 8002dc4:	69bc      	ldr	r4, [r7, #24]
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
 8002dc6:	f7ff ff83 	bl	8002cd0 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8002dca:	2d00      	cmp	r5, #0
 8002dcc:	d04a      	beq.n	8002e64 <chSchGoSleepTimeoutS+0xb4>
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002dce:	46b9      	mov	r9, r7
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8002dd0:	2d01      	cmp	r5, #1
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002dd2:	f859 6f1c 	ldr.w	r6, [r9, #28]!

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 8002dd6:	4a4a      	ldr	r2, [pc, #296]	; (8002f00 <chSchGoSleepTimeoutS+0x150>)
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 8002dd8:	9405      	str	r4, [sp, #20]
 8002dda:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8002dde:	bf08      	it	eq
 8002de0:	2502      	moveq	r5, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002de2:	454e      	cmp	r6, r9
 8002de4:	6a5c      	ldr	r4, [r3, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 8002de6:	9204      	str	r2, [sp, #16]
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002de8:	d06c      	beq.n	8002ec4 <chSchGoSleepTimeoutS+0x114>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 8002dea:	6ab8      	ldr	r0, [r7, #40]	; 0x28

    if (delta < now - ch.vtlist.lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8002dec:	68b3      	ldr	r3, [r6, #8]
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 8002dee:	1a24      	subs	r4, r4, r0

    if (delta < now - ch.vtlist.lasttime) {
 8002df0:	192c      	adds	r4, r5, r4
 8002df2:	d243      	bcs.n	8002e7c <chSchGoSleepTimeoutS+0xcc>
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
 8002df4:	429c      	cmp	r4, r3
 8002df6:	d345      	bcc.n	8002e84 <chSchGoSleepTimeoutS+0xd4>
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8002df8:	429c      	cmp	r4, r3
 8002dfa:	d904      	bls.n	8002e06 <chSchGoSleepTimeoutS+0x56>
    delta -= p->delta;
    p = p->next;
 8002dfc:	6836      	ldr	r6, [r6, #0]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
 8002dfe:	1ae4      	subs	r4, r4, r3
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8002e00:	68b3      	ldr	r3, [r6, #8]
 8002e02:	42a3      	cmp	r3, r4
 8002e04:	d3fa      	bcc.n	8002dfc <chSchGoSleepTimeoutS+0x4c>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8002e06:	6873      	ldr	r3, [r6, #4]
 8002e08:	9302      	str	r3, [sp, #8]
  vtp->prev->next = vtp;
 8002e0a:	f10d 0a04 	add.w	sl, sp, #4
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 8002e0e:	9601      	str	r6, [sp, #4]
  vtp->prev = vtp->next->prev;
  vtp->prev->next = vtp;
 8002e10:	f8c3 a000 	str.w	sl, [r3]
  p->prev = vtp;
 8002e14:	f8c6 a004 	str.w	sl, [r6, #4]
  vtp->delta = delta
 8002e18:	9403      	str	r4, [sp, #12]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8002e1a:	68b1      	ldr	r1, [r6, #8]
  ch.vtlist.delta = (systime_t)-1;
 8002e1c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  p->prev = vtp;
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8002e20:	1b09      	subs	r1, r1, r4
 8002e22:	60b1      	str	r1, [r6, #8]
  ch.vtlist.delta = (systime_t)-1;
 8002e24:	627b      	str	r3, [r7, #36]	; 0x24
    chSchGoSleepS(newstate);
 8002e26:	4640      	mov	r0, r8
 8002e28:	f7ff ff2a 	bl	8002c80 <chSchGoSleepS>
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8002e2c:	f7ff ff50 	bl	8002cd0 <chDbgCheckClassI>
    if (chVTIsArmedI(&vt)) {
 8002e30:	9b04      	ldr	r3, [sp, #16]
 8002e32:	b1f3      	cbz	r3, 8002e72 <chSchGoSleepTimeoutS+0xc2>
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {

  chDbgCheckClassI();
 8002e34:	f7ff ff4c 	bl	8002cd0 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8002e38:	69fb      	ldr	r3, [r7, #28]
 8002e3a:	4930      	ldr	r1, [pc, #192]	; (8002efc <chSchGoSleepTimeoutS+0x14c>)
 8002e3c:	4553      	cmp	r3, sl
 8002e3e:	d026      	beq.n	8002e8e <chSchGoSleepTimeoutS+0xde>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8002e40:	9a02      	ldr	r2, [sp, #8]
 8002e42:	9b01      	ldr	r3, [sp, #4]
 8002e44:	6013      	str	r3, [r2, #0]
    vtp->next->prev = vtp->prev;
 8002e46:	9b01      	ldr	r3, [sp, #4]
    vtp->func = NULL;
 8002e48:	2100      	movs	r1, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8002e4a:	454b      	cmp	r3, r9
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
    vtp->next->prev = vtp->prev;
 8002e4c:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8002e4e:	9104      	str	r1, [sp, #16]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8002e50:	d00f      	beq.n	8002e72 <chSchGoSleepTimeoutS+0xc2>
      vtp->next->delta += vtp->delta;
 8002e52:	6899      	ldr	r1, [r3, #8]
 8002e54:	9a03      	ldr	r2, [sp, #12]
 8002e56:	440a      	add	r2, r1
 8002e58:	609a      	str	r2, [r3, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 8002e5a:	69bb      	ldr	r3, [r7, #24]
 8002e5c:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 8002e5e:	b006      	add	sp, #24
 8002e60:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8002e64:	4827      	ldr	r0, [pc, #156]	; (8002f04 <chSchGoSleepTimeoutS+0x154>)
 8002e66:	f7ff fedb 	bl	8002c20 <chSysHalt>
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8002e6a:	4640      	mov	r0, r8
 8002e6c:	f7ff ff08 	bl	8002c80 <chSchGoSleepS>
 8002e70:	4f22      	ldr	r7, [pc, #136]	; (8002efc <chSchGoSleepTimeoutS+0x14c>)
  }

  return currp->u.rdymsg;
 8002e72:	69bb      	ldr	r3, [r7, #24]
 8002e74:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 8002e76:	b006      	add	sp, #24
 8002e78:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (delta < now - ch.vtlist.lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
 8002e7c:	6836      	ldr	r6, [r6, #0]

    if (delta < now - ch.vtlist.lasttime) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8002e7e:	1ae4      	subs	r4, r4, r3
 8002e80:	68b3      	ldr	r3, [r6, #8]
 8002e82:	e7b9      	b.n	8002df8 <chSchGoSleepTimeoutS+0x48>
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8002e84:	4420      	add	r0, r4
 8002e86:	f7fe fbf3 	bl	8001670 <stSetAlarm>
 8002e8a:	68b3      	ldr	r3, [r6, #8]
 8002e8c:	e7b4      	b.n	8002df8 <chSchGoSleepTimeoutS+0x48>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8002e8e:	9a01      	ldr	r2, [sp, #4]
 8002e90:	61ca      	str	r2, [r1, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 8002e92:	2300      	movs	r3, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002e94:	454a      	cmp	r2, r9
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8002e96:	f8c2 9004 	str.w	r9, [r2, #4]
  vtp->func = NULL;
 8002e9a:	9304      	str	r3, [sp, #16]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002e9c:	d029      	beq.n	8002ef2 <chSchGoSleepTimeoutS+0x142>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8002e9e:	9803      	ldr	r0, [sp, #12]
 8002ea0:	6893      	ldr	r3, [r2, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8002ea2:	6a89      	ldr	r1, [r1, #40]	; 0x28

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8002ea4:	4403      	add	r3, r0
 8002ea6:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8002eaa:	6093      	str	r3, [r2, #8]
 8002eac:	6a40      	ldr	r0, [r0, #36]	; 0x24
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8002eae:	1a42      	subs	r2, r0, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8002eb0:	4293      	cmp	r3, r2
 8002eb2:	d9de      	bls.n	8002e72 <chSchGoSleepTimeoutS+0xc2>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8002eb4:	1a9b      	subs	r3, r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8002eb6:	2b01      	cmp	r3, #1
 8002eb8:	bf98      	it	ls
 8002eba:	2302      	movls	r3, #2
 8002ebc:	4418      	add	r0, r3
 8002ebe:	f7fe fbd7 	bl	8001670 <stSetAlarm>
 8002ec2:	e7d6      	b.n	8002e72 <chSchGoSleepTimeoutS+0xc2>
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 8002ec4:	62bc      	str	r4, [r7, #40]	; 0x28
      ch.vtlist.next = vtp;
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;
 8002ec6:	9503      	str	r5, [sp, #12]
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8002ec8:	68da      	ldr	r2, [r3, #12]
      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8002eca:	9601      	str	r6, [sp, #4]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
 8002ecc:	f10d 0a04 	add.w	sl, sp, #4
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8002ed0:	f012 0202 	ands.w	r2, r2, #2
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8002ed4:	9602      	str	r6, [sp, #8]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
 8002ed6:	f8c7 a01c 	str.w	sl, [r7, #28]
      ch.vtlist.prev = vtp;
 8002eda:	f8c7 a020 	str.w	sl, [r7, #32]
 8002ede:	d105      	bne.n	8002eec <chSchGoSleepTimeoutS+0x13c>
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 8002ee0:	442c      	add	r4, r5
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  STM32_ST_TIM->SR     = 0;
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8002ee2:	2102      	movs	r1, #2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8002ee4:	635c      	str	r4, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8002ee6:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8002ee8:	60d9      	str	r1, [r3, #12]
 8002eea:	e79c      	b.n	8002e26 <chSchGoSleepTimeoutS+0x76>
 8002eec:	4806      	ldr	r0, [pc, #24]	; (8002f08 <chSchGoSleepTimeoutS+0x158>)
 8002eee:	f7ff fe97 	bl	8002c20 <chSysHalt>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8002ef2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8002ef6:	60d3      	str	r3, [r2, #12]
 8002ef8:	e7bb      	b.n	8002e72 <chSchGoSleepTimeoutS+0xc2>
 8002efa:	bf00      	nop
 8002efc:	20001320 	.word	0x20001320
 8002f00:	08003151 	.word	0x08003151
 8002f04:	08005034 	.word	0x08005034
 8002f08:	08004ffc 	.word	0x08004ffc
 8002f0c:	00000000 	.word	0x00000000

08002f10 <chSchReadyAheadI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
 8002f10:	b510      	push	{r4, lr}
 8002f12:	4604      	mov	r4, r0
  thread_t *cp;

  chDbgCheckClassI();
 8002f14:	f7ff fedc 	bl	8002cd0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8002f18:	b1a4      	cbz	r4, 8002f44 <chSchReadyAheadI+0x34>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8002f1a:	f894 3020 	ldrb.w	r3, [r4, #32]
 8002f1e:	b18b      	cbz	r3, 8002f44 <chSchReadyAheadI+0x34>
 8002f20:	2b0f      	cmp	r3, #15
 8002f22:	d00f      	beq.n	8002f44 <chSchReadyAheadI+0x34>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8002f24:	2200      	movs	r2, #0
 8002f26:	68a1      	ldr	r1, [r4, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8002f28:	4b08      	ldr	r3, [pc, #32]	; (8002f4c <chSchReadyAheadI+0x3c>)
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8002f2a:	f884 2020 	strb.w	r2, [r4, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 8002f2e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8002f30:	689a      	ldr	r2, [r3, #8]
 8002f32:	428a      	cmp	r2, r1
 8002f34:	d8fb      	bhi.n	8002f2e <chSchReadyAheadI+0x1e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8002f36:	685a      	ldr	r2, [r3, #4]
 8002f38:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8002f3a:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
 8002f3c:	4620      	mov	r0, r4
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8002f3e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8002f40:	605c      	str	r4, [r3, #4]

  return tp;
}
 8002f42:	bd10      	pop	{r4, pc}
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 8002f44:	4802      	ldr	r0, [pc, #8]	; (8002f50 <chSchReadyAheadI+0x40>)
 8002f46:	f7ff fe6b 	bl	8002c20 <chSysHalt>
 8002f4a:	bf00      	nop
 8002f4c:	20001320 	.word	0x20001320
 8002f50:	08004fdc 	.word	0x08004fdc
	...

08002f60 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8002f60:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
 8002f62:	4c10      	ldr	r4, [pc, #64]	; (8002fa4 <chSchDoReschedule+0x44>)
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8002f64:	6823      	ldr	r3, [r4, #0]
 8002f66:	69a0      	ldr	r0, [r4, #24]

  tqp->next             = tp->queue.next;
 8002f68:	681a      	ldr	r2, [r3, #0]
 8002f6a:	6022      	str	r2, [r4, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8002f6c:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8002f6e:	6054      	str	r4, [r2, #4]
 8002f70:	f883 1020 	strb.w	r1, [r3, #32]
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8002f74:	61a3      	str	r3, [r4, #24]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 8002f76:	f7ff ffcb 	bl	8002f10 <chSchReadyAheadI>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002f7a:	4601      	mov	r1, r0
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 8002f7c:	4605      	mov	r5, r0
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002f7e:	69a0      	ldr	r0, [r4, #24]
 8002f80:	f7ff fe1e 	bl	8002bc0 <_trace_switch>
 8002f84:	f3ef 8309 	mrs	r3, PSP
 8002f88:	69ea      	ldr	r2, [r5, #28]
 8002f8a:	3b64      	subs	r3, #100	; 0x64
 8002f8c:	429a      	cmp	r2, r3
 8002f8e:	d805      	bhi.n	8002f9c <chSchDoReschedule+0x3c>
 8002f90:	69a0      	ldr	r0, [r4, #24]
 8002f92:	4629      	mov	r1, r5
}
 8002f94:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002f98:	f7fd b9a0 	b.w	80002dc <_port_switch>
 8002f9c:	4802      	ldr	r0, [pc, #8]	; (8002fa8 <chSchDoReschedule+0x48>)
 8002f9e:	f7ff fe3f 	bl	8002c20 <chSysHalt>
 8002fa2:	bf00      	nop
 8002fa4:	20001320 	.word	0x20001320
 8002fa8:	08005048 	.word	0x08005048
 8002fac:	00000000 	.word	0x00000000

08002fb0 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8002fb0:	b538      	push	{r3, r4, r5, lr}
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 8002fb2:	4c14      	ldr	r4, [pc, #80]	; (8003004 <chSchRescheduleS+0x54>)

  chDbgCheckClassS();
 8002fb4:	f7ff fe54 	bl	8002c60 <chDbgCheckClassS>
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();
 8002fb8:	f7ff fe8a 	bl	8002cd0 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 8002fbc:	6823      	ldr	r3, [r4, #0]
 8002fbe:	69a0      	ldr	r0, [r4, #24]

  if (chSchIsRescRequiredI()) {
 8002fc0:	6899      	ldr	r1, [r3, #8]
 8002fc2:	6882      	ldr	r2, [r0, #8]
 8002fc4:	4291      	cmp	r1, r2
 8002fc6:	d800      	bhi.n	8002fca <chSchRescheduleS+0x1a>
 8002fc8:	bd38      	pop	{r3, r4, r5, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8002fca:	681a      	ldr	r2, [r3, #0]
 8002fcc:	6022      	str	r2, [r4, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8002fce:	2101      	movs	r1, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8002fd0:	6054      	str	r4, [r2, #4]
 8002fd2:	f883 1020 	strb.w	r1, [r3, #32]
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8002fd6:	61a3      	str	r3, [r4, #24]
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 8002fd8:	f7ff ff9a 	bl	8002f10 <chSchReadyAheadI>

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002fdc:	4601      	mov	r1, r0
  if (otp->prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);
 8002fde:	4605      	mov	r5, r0

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002fe0:	69a0      	ldr	r0, [r4, #24]
 8002fe2:	f7ff fded 	bl	8002bc0 <_trace_switch>
 8002fe6:	f3ef 8309 	mrs	r3, PSP
 8002fea:	69ea      	ldr	r2, [r5, #28]
 8002fec:	3b64      	subs	r3, #100	; 0x64
 8002fee:	429a      	cmp	r2, r3
 8002ff0:	d805      	bhi.n	8002ffe <chSchRescheduleS+0x4e>
 8002ff2:	69a0      	ldr	r0, [r4, #24]
 8002ff4:	4629      	mov	r1, r5
  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
    chSchDoRescheduleAhead();
  }
}
 8002ff6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002ffa:	f7fd b96f 	b.w	80002dc <_port_switch>
 8002ffe:	4802      	ldr	r0, [pc, #8]	; (8003008 <chSchRescheduleS+0x58>)
 8003000:	f7ff fe0e 	bl	8002c20 <chSysHalt>
 8003004:	20001320 	.word	0x20001320
 8003008:	08005048 	.word	0x08005048
 800300c:	00000000 	.word	0x00000000

08003010 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8003010:	b510      	push	{r4, lr}
 8003012:	4604      	mov	r4, r0
  thread_t *cp;

  chDbgCheckClassI();
 8003014:	f7ff fe5c 	bl	8002cd0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8003018:	b1a4      	cbz	r4, 8003044 <chSchReadyI+0x34>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800301a:	f894 3020 	ldrb.w	r3, [r4, #32]
 800301e:	b18b      	cbz	r3, 8003044 <chSchReadyI+0x34>
 8003020:	2b0f      	cmp	r3, #15
 8003022:	d00f      	beq.n	8003044 <chSchReadyI+0x34>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8003024:	2200      	movs	r2, #0
 8003026:	68a1      	ldr	r1, [r4, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8003028:	4b08      	ldr	r3, [pc, #32]	; (800304c <chSchReadyI+0x3c>)
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800302a:	f884 2020 	strb.w	r2, [r4, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 800302e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8003030:	689a      	ldr	r2, [r3, #8]
 8003032:	428a      	cmp	r2, r1
 8003034:	d2fb      	bcs.n	800302e <chSchReadyI+0x1e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8003036:	685a      	ldr	r2, [r3, #4]
 8003038:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800303a:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
 800303c:	4620      	mov	r0, r4
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800303e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8003040:	605c      	str	r4, [r3, #4]

  return tp;
}
 8003042:	bd10      	pop	{r4, pc}
 */
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 8003044:	4802      	ldr	r0, [pc, #8]	; (8003050 <chSchReadyI+0x40>)
 8003046:	f7ff fdeb 	bl	8002c20 <chSysHalt>
 800304a:	bf00      	nop
 800304c:	20001320 	.word	0x20001320
 8003050:	08005178 	.word	0x08005178
	...

08003060 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8003060:	b508      	push	{r3, lr}

  if (*trp != NULL) {
 8003062:	6803      	ldr	r3, [r0, #0]
 8003064:	b173      	cbz	r3, 8003084 <chThdResumeI+0x24>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8003066:	f893 2020 	ldrb.w	r2, [r3, #32]
 800306a:	2a03      	cmp	r2, #3
 800306c:	d002      	beq.n	8003074 <chThdResumeI+0x14>
 800306e:	4806      	ldr	r0, [pc, #24]	; (8003088 <chThdResumeI+0x28>)
 8003070:	f7ff fdd6 	bl	8002c20 <chSysHalt>

    *trp = NULL;
 8003074:	2200      	movs	r2, #0
 8003076:	6002      	str	r2, [r0, #0]
    tp->u.rdymsg = msg;
 8003078:	6259      	str	r1, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800307a:	4618      	mov	r0, r3
  }
}
 800307c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8003080:	f7ff bfc6 	b.w	8003010 <chSchReadyI>
 8003084:	bd08      	pop	{r3, pc}
 8003086:	bf00      	nop
 8003088:	08005150 	.word	0x08005150
 800308c:	00000000 	.word	0x00000000

08003090 <_dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {
 8003090:	b508      	push	{r3, lr}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003092:	2320      	movs	r3, #32
 8003094:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003098:	4a06      	ldr	r2, [pc, #24]	; (80030b4 <_dbg_check_leave_isr+0x24>)
 800309a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800309c:	2b00      	cmp	r3, #0
 800309e:	dd01      	ble.n	80030a4 <_dbg_check_leave_isr+0x14>
 80030a0:	6b51      	ldr	r1, [r2, #52]	; 0x34
 80030a2:	b111      	cbz	r1, 80030aa <_dbg_check_leave_isr+0x1a>
    chSysHalt("SV#9");
 80030a4:	4804      	ldr	r0, [pc, #16]	; (80030b8 <_dbg_check_leave_isr+0x28>)
 80030a6:	f7ff fdbb 	bl	8002c20 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 80030aa:	3b01      	subs	r3, #1
 80030ac:	6313      	str	r3, [r2, #48]	; 0x30
 80030ae:	f381 8811 	msr	BASEPRI, r1
 80030b2:	bd08      	pop	{r3, pc}
 80030b4:	20001320 	.word	0x20001320
 80030b8:	08005060 	.word	0x08005060
 80030bc:	00000000 	.word	0x00000000

080030c0 <_dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {
 80030c0:	b508      	push	{r3, lr}
 80030c2:	2320      	movs	r3, #32
 80030c4:	f383 8811 	msr	BASEPRI, r3

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80030c8:	4a06      	ldr	r2, [pc, #24]	; (80030e4 <_dbg_check_enter_isr+0x24>)
 80030ca:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80030cc:	2b00      	cmp	r3, #0
 80030ce:	db01      	blt.n	80030d4 <_dbg_check_enter_isr+0x14>
 80030d0:	6b51      	ldr	r1, [r2, #52]	; 0x34
 80030d2:	b111      	cbz	r1, 80030da <_dbg_check_enter_isr+0x1a>
    chSysHalt("SV#8");
 80030d4:	4804      	ldr	r0, [pc, #16]	; (80030e8 <_dbg_check_enter_isr+0x28>)
 80030d6:	f7ff fda3 	bl	8002c20 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 80030da:	3301      	adds	r3, #1
 80030dc:	6313      	str	r3, [r2, #48]	; 0x30
 80030de:	f381 8811 	msr	BASEPRI, r1
 80030e2:	bd08      	pop	{r3, pc}
 80030e4:	20001320 	.word	0x20001320
 80030e8:	08005068 	.word	0x08005068
 80030ec:	00000000 	.word	0x00000000

080030f0 <_dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {
 80030f0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80030f2:	4b06      	ldr	r3, [pc, #24]	; (800310c <_dbg_check_unlock_from_isr+0x1c>)
 80030f4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80030f6:	2a00      	cmp	r2, #0
 80030f8:	dd05      	ble.n	8003106 <_dbg_check_unlock_from_isr+0x16>
 80030fa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80030fc:	2a00      	cmp	r2, #0
 80030fe:	dd02      	ble.n	8003106 <_dbg_check_unlock_from_isr+0x16>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8003100:	2200      	movs	r2, #0
 8003102:	635a      	str	r2, [r3, #52]	; 0x34
 8003104:	bd08      	pop	{r3, pc}
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
 8003106:	4802      	ldr	r0, [pc, #8]	; (8003110 <_dbg_check_unlock_from_isr+0x20>)
 8003108:	f7ff fd8a 	bl	8002c20 <chSysHalt>
 800310c:	20001320 	.word	0x20001320
 8003110:	08005070 	.word	0x08005070
	...

08003120 <_dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {
 8003120:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003122:	4b06      	ldr	r3, [pc, #24]	; (800313c <_dbg_check_lock_from_isr+0x1c>)
 8003124:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003126:	2a00      	cmp	r2, #0
 8003128:	dd01      	ble.n	800312e <_dbg_check_lock_from_isr+0xe>
 800312a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800312c:	b112      	cbz	r2, 8003134 <_dbg_check_lock_from_isr+0x14>
    chSysHalt("SV#6");
 800312e:	4804      	ldr	r0, [pc, #16]	; (8003140 <_dbg_check_lock_from_isr+0x20>)
 8003130:	f7ff fd76 	bl	8002c20 <chSysHalt>
  }
  _dbg_enter_lock();
 8003134:	2201      	movs	r2, #1
 8003136:	635a      	str	r2, [r3, #52]	; 0x34
 8003138:	bd08      	pop	{r3, pc}
 800313a:	bf00      	nop
 800313c:	20001320 	.word	0x20001320
 8003140:	08005078 	.word	0x08005078
	...

08003150 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8003150:	b538      	push	{r3, r4, r5, lr}
 8003152:	4604      	mov	r4, r0
 8003154:	2320      	movs	r3, #32
 8003156:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800315a:	f7ff ffe1 	bl	8003120 <_dbg_check_lock_from_isr>
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 800315e:	f894 3020 	ldrb.w	r3, [r4, #32]
 8003162:	2b07      	cmp	r3, #7
 8003164:	d810      	bhi.n	8003188 <wakeup+0x38>
 8003166:	e8df f003 	tbb	[pc, r3]
 800316a:	0f15      	.short	0x0f15
 800316c:	040a1b0f 	.word	0x040a1b0f
 8003170:	0a0f      	.short	0x0a0f
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8003172:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 8003174:	f7ff fdac 	bl	8002cd0 <chDbgCheckClassI>

  sp->cnt++;
 8003178:	68ab      	ldr	r3, [r5, #8]
 800317a:	3301      	adds	r3, #1
 800317c:	60ab      	str	r3, [r5, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800317e:	e894 000c 	ldmia.w	r4, {r2, r3}
 8003182:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8003184:	6822      	ldr	r2, [r4, #0]
 8003186:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8003188:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800318c:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 800318e:	4620      	mov	r0, r4
 8003190:	f7ff ff3e 	bl	8003010 <chSchReadyI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8003194:	f7ff ffac 	bl	80030f0 <_dbg_check_unlock_from_isr>
 8003198:	2300      	movs	r3, #0
 800319a:	f383 8811 	msr	BASEPRI, r3
 800319e:	bd38      	pop	{r3, r4, r5, pc}
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 80031a0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80031a2:	2200      	movs	r2, #0
 80031a4:	601a      	str	r2, [r3, #0]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 80031a6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80031aa:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 80031ac:	4620      	mov	r0, r4
 80031ae:	f7ff ff2f 	bl	8003010 <chSchReadyI>
 80031b2:	e7ef      	b.n	8003194 <wakeup+0x44>
	...

080031c0 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 80031c0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80031c2:	4b05      	ldr	r3, [pc, #20]	; (80031d8 <_dbg_check_unlock+0x18>)
 80031c4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80031c6:	b922      	cbnz	r2, 80031d2 <_dbg_check_unlock+0x12>
 80031c8:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80031ca:	2900      	cmp	r1, #0
 80031cc:	dd01      	ble.n	80031d2 <_dbg_check_unlock+0x12>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80031ce:	635a      	str	r2, [r3, #52]	; 0x34
 80031d0:	bd08      	pop	{r3, pc}
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 80031d2:	4802      	ldr	r0, [pc, #8]	; (80031dc <_dbg_check_unlock+0x1c>)
 80031d4:	f7ff fd24 	bl	8002c20 <chSysHalt>
 80031d8:	20001320 	.word	0x20001320
 80031dc:	08005080 	.word	0x08005080

080031e0 <chSysUnlock.lto_priv.59>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80031e0:	b508      	push	{r3, lr}

  _dbg_check_unlock();
 80031e2:	f7ff ffed 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80031e6:	4b08      	ldr	r3, [pc, #32]	; (8003208 <chSysUnlock.lto_priv.59+0x28>)
 80031e8:	681a      	ldr	r2, [r3, #0]
 80031ea:	429a      	cmp	r2, r3
 80031ec:	d004      	beq.n	80031f8 <chSysUnlock.lto_priv.59+0x18>
 80031ee:	6999      	ldr	r1, [r3, #24]
 80031f0:	6893      	ldr	r3, [r2, #8]
 80031f2:	688a      	ldr	r2, [r1, #8]
 80031f4:	429a      	cmp	r2, r3
 80031f6:	d303      	bcc.n	8003200 <chSysUnlock.lto_priv.59+0x20>
 80031f8:	2300      	movs	r3, #0
 80031fa:	f383 8811 	msr	BASEPRI, r3
 80031fe:	bd08      	pop	{r3, pc}
 8003200:	4802      	ldr	r0, [pc, #8]	; (800320c <chSysUnlock.lto_priv.59+0x2c>)
 8003202:	f7ff fd0d 	bl	8002c20 <chSysHalt>
 8003206:	bf00      	nop
 8003208:	20001320 	.word	0x20001320
 800320c:	08005128 	.word	0x08005128

08003210 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 8003210:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003212:	4b05      	ldr	r3, [pc, #20]	; (8003228 <_dbg_check_lock+0x18>)
 8003214:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003216:	b90a      	cbnz	r2, 800321c <_dbg_check_lock+0xc>
 8003218:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800321a:	b112      	cbz	r2, 8003222 <_dbg_check_lock+0x12>
    chSysHalt("SV#4");
 800321c:	4803      	ldr	r0, [pc, #12]	; (800322c <_dbg_check_lock+0x1c>)
 800321e:	f7ff fcff 	bl	8002c20 <chSysHalt>
  }
  _dbg_enter_lock();
 8003222:	2201      	movs	r2, #1
 8003224:	635a      	str	r2, [r3, #52]	; 0x34
 8003226:	bd08      	pop	{r3, pc}
 8003228:	20001320 	.word	0x20001320
 800322c:	08005088 	.word	0x08005088

08003230 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8003230:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  thread_t *ctp = currp;
 8003234:	4e28      	ldr	r6, [pc, #160]	; (80032d8 <chMtxUnlock+0xa8>)
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 8003236:	4605      	mov	r5, r0
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8003238:	69b4      	ldr	r4, [r6, #24]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800323a:	b148      	cbz	r0, 8003250 <chMtxUnlock+0x20>
 800323c:	2320      	movs	r3, #32
 800323e:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003242:	f7ff ffe5 	bl	8003210 <_dbg_check_lock>

  chSysLock();

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8003246:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003248:	b113      	cbz	r3, 8003250 <chMtxUnlock+0x20>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 800324a:	689f      	ldr	r7, [r3, #8]
 800324c:	42a7      	cmp	r7, r4
 800324e:	d002      	beq.n	8003256 <chMtxUnlock+0x26>
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 8003250:	4822      	ldr	r0, [pc, #136]	; (80032dc <chMtxUnlock+0xac>)
 8003252:	f7ff fce5 	bl	8002c20 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8003256:	429d      	cmp	r5, r3
 8003258:	d1fa      	bne.n	8003250 <chMtxUnlock+0x20>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 800325a:	68ec      	ldr	r4, [r5, #12]
 800325c:	63bc      	str	r4, [r7, #56]	; 0x38
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {

  chDbgCheckClassS();
 800325e:	f7ff fcff 	bl	8002c60 <chDbgCheckClassS>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8003262:	f8d5 9000 	ldr.w	r9, [r5]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8003266:	454d      	cmp	r5, r9
 8003268:	d033      	beq.n	80032d2 <chMtxUnlock+0xa2>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 800326a:	f8d7 803c 	ldr.w	r8, [r7, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 800326e:	b15c      	cbz	r4, 8003288 <chMtxUnlock+0x58>
 8003270:	f7ff fcf6 	bl	8002c60 <chDbgCheckClassS>
 8003274:	6823      	ldr	r3, [r4, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8003276:	429c      	cmp	r4, r3
 8003278:	d003      	beq.n	8003282 <chMtxUnlock+0x52>
            (lmp->queue.next->prio > newprio)) {
 800327a:	689b      	ldr	r3, [r3, #8]
 800327c:	4598      	cmp	r8, r3
 800327e:	bf38      	it	cc
 8003280:	4698      	movcc	r8, r3
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8003282:	68e4      	ldr	r4, [r4, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8003284:	2c00      	cmp	r4, #0
 8003286:	d1f3      	bne.n	8003270 <chMtxUnlock+0x40>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8003288:	f8d9 3000 	ldr.w	r3, [r9]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 800328c:	f8d9 2038 	ldr.w	r2, [r9, #56]	; 0x38
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8003290:	f8c7 8008 	str.w	r8, [r7, #8]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8003294:	4648      	mov	r0, r9
 8003296:	602b      	str	r3, [r5, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003298:	605d      	str	r5, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 800329a:	60ea      	str	r2, [r5, #12]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 800329c:	f8c5 9008 	str.w	r9, [r5, #8]
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
 80032a0:	f8c9 5038 	str.w	r5, [r9, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80032a4:	f7ff feb4 	bl	8003010 <chSchReadyI>
      chSchRescheduleS();
 80032a8:	f7ff fe82 	bl	8002fb0 <chSchRescheduleS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80032ac:	f7ff ff88 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80032b0:	6833      	ldr	r3, [r6, #0]
 80032b2:	4a09      	ldr	r2, [pc, #36]	; (80032d8 <chMtxUnlock+0xa8>)
 80032b4:	42b3      	cmp	r3, r6
 80032b6:	d004      	beq.n	80032c2 <chMtxUnlock+0x92>
 80032b8:	6992      	ldr	r2, [r2, #24]
 80032ba:	689b      	ldr	r3, [r3, #8]
 80032bc:	6892      	ldr	r2, [r2, #8]
 80032be:	429a      	cmp	r2, r3
 80032c0:	d304      	bcc.n	80032cc <chMtxUnlock+0x9c>
 80032c2:	2300      	movs	r3, #0
 80032c4:	f383 8811 	msr	BASEPRI, r3
 80032c8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80032cc:	4804      	ldr	r0, [pc, #16]	; (80032e0 <chMtxUnlock+0xb0>)
 80032ce:	f7ff fca7 	bl	8002c20 <chSysHalt>
    }
    else {
      mp->owner = NULL;
 80032d2:	2300      	movs	r3, #0
 80032d4:	60ab      	str	r3, [r5, #8]
 80032d6:	e7e9      	b.n	80032ac <chMtxUnlock+0x7c>
 80032d8:	20001320 	.word	0x20001320
 80032dc:	08005028 	.word	0x08005028
 80032e0:	08004fb8 	.word	0x08004fb8
	...

080032f0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 80032f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80032f2:	4605      	mov	r5, r0
 80032f4:	2320      	movs	r3, #32
 80032f6:	f383 8811 	msr	BASEPRI, r3
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 80032fa:	4e43      	ldr	r6, [pc, #268]	; (8003408 <chMtxLock+0x118>)
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80032fc:	f7ff ff88 	bl	8003210 <_dbg_check_lock>
 8003300:	69b4      	ldr	r4, [r6, #24]

  chDbgCheckClassS();
 8003302:	f7ff fcad 	bl	8002c60 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 8003306:	b31d      	cbz	r5, 8003350 <chMtxLock+0x60>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8003308:	68a8      	ldr	r0, [r5, #8]
 800330a:	2800      	cmp	r0, #0
 800330c:	d06d      	beq.n	80033ea <chMtxLock+0xfa>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 800330e:	68a2      	ldr	r2, [r4, #8]
 8003310:	6883      	ldr	r3, [r0, #8]
 8003312:	429a      	cmp	r2, r3
 8003314:	d907      	bls.n	8003326 <chMtxLock+0x36>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8003316:	f890 3020 	ldrb.w	r3, [r0, #32]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 800331a:	6082      	str	r2, [r0, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800331c:	2b06      	cmp	r3, #6
 800331e:	d039      	beq.n	8003394 <chMtxLock+0xa4>
 8003320:	2b07      	cmp	r3, #7
 8003322:	d023      	beq.n	800336c <chMtxLock+0x7c>
 8003324:	b1bb      	cbz	r3, 8003356 <chMtxLock+0x66>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8003326:	462b      	mov	r3, r5
 8003328:	e003      	b.n	8003332 <chMtxLock+0x42>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800332a:	6899      	ldr	r1, [r3, #8]
 800332c:	68a2      	ldr	r2, [r4, #8]
 800332e:	4291      	cmp	r1, r2
 8003330:	d302      	bcc.n	8003338 <chMtxLock+0x48>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8003332:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8003334:	429d      	cmp	r5, r3
 8003336:	d1f8      	bne.n	800332a <chMtxLock+0x3a>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8003338:	685a      	ldr	r2, [r3, #4]
 800333a:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800333c:	6023      	str	r3, [r4, #0]
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 800333e:	2006      	movs	r0, #6
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8003340:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8003342:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 8003344:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8003346:	f7ff fc9b 	bl	8002c80 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 800334a:	68ab      	ldr	r3, [r5, #8]
 800334c:	429c      	cmp	r4, r3
 800334e:	d03a      	beq.n	80033c6 <chMtxLock+0xd6>
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);
 8003350:	482e      	ldr	r0, [pc, #184]	; (800340c <chMtxLock+0x11c>)
 8003352:	f7ff fc65 	bl	8002c20 <chSysHalt>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8003356:	e890 000c 	ldmia.w	r0, {r2, r3}
          break;
#endif
        case CH_STATE_READY:
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
 800335a:	2101      	movs	r1, #1
 800335c:	f880 1020 	strb.w	r1, [r0, #32]
 8003360:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8003362:	6802      	ldr	r2, [r0, #0]
 8003364:	6053      	str	r3, [r2, #4]
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8003366:	f7ff fe53 	bl	8003010 <chSchReadyI>
 800336a:	e7dc      	b.n	8003326 <chMtxLock+0x36>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800336c:	e890 000a 	ldmia.w	r0, {r1, r3}
 8003370:	6019      	str	r1, [r3, #0]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8003372:	6a47      	ldr	r7, [r0, #36]	; 0x24
  tp->queue.next->queue.prev = tp->queue.prev;
 8003374:	6801      	ldr	r1, [r0, #0]
 8003376:	604b      	str	r3, [r1, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8003378:	463b      	mov	r3, r7
 800337a:	e002      	b.n	8003382 <chMtxLock+0x92>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800337c:	6899      	ldr	r1, [r3, #8]
 800337e:	4291      	cmp	r1, r2
 8003380:	d302      	bcc.n	8003388 <chMtxLock+0x98>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8003382:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8003384:	429f      	cmp	r7, r3
 8003386:	d1f9      	bne.n	800337c <chMtxLock+0x8c>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8003388:	685a      	ldr	r2, [r3, #4]
 800338a:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800338c:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800338e:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8003390:	6058      	str	r0, [r3, #4]
 8003392:	e7c8      	b.n	8003326 <chMtxLock+0x36>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8003394:	e890 000a 	ldmia.w	r0, {r1, r3}
 8003398:	6019      	str	r1, [r3, #0]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800339a:	6a47      	ldr	r7, [r0, #36]	; 0x24
  tp->queue.next->queue.prev = tp->queue.prev;
 800339c:	6801      	ldr	r1, [r0, #0]
 800339e:	604b      	str	r3, [r1, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80033a0:	463b      	mov	r3, r7
 80033a2:	e002      	b.n	80033aa <chMtxLock+0xba>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80033a4:	6899      	ldr	r1, [r3, #8]
 80033a6:	4291      	cmp	r1, r2
 80033a8:	d302      	bcc.n	80033b0 <chMtxLock+0xc0>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 80033aa:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80033ac:	429f      	cmp	r7, r3
 80033ae:	d1f9      	bne.n	80033a4 <chMtxLock+0xb4>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80033b0:	685a      	ldr	r2, [r3, #4]
 80033b2:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 80033b4:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 80033b6:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 80033b8:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 80033ba:	68b8      	ldr	r0, [r7, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 80033bc:	68a2      	ldr	r2, [r4, #8]
 80033be:	6883      	ldr	r3, [r0, #8]
 80033c0:	429a      	cmp	r2, r3
 80033c2:	d8a8      	bhi.n	8003316 <chMtxLock+0x26>
 80033c4:	e7af      	b.n	8003326 <chMtxLock+0x36>
      chSchGoSleepS(CH_STATE_WTMTX);

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 80033c6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80033c8:	429d      	cmp	r5, r3
 80033ca:	d1c1      	bne.n	8003350 <chMtxLock+0x60>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80033cc:	f7ff fef8 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80033d0:	6833      	ldr	r3, [r6, #0]
 80033d2:	4a0d      	ldr	r2, [pc, #52]	; (8003408 <chMtxLock+0x118>)
 80033d4:	42b3      	cmp	r3, r6
 80033d6:	d004      	beq.n	80033e2 <chMtxLock+0xf2>
 80033d8:	6992      	ldr	r2, [r2, #24]
 80033da:	689b      	ldr	r3, [r3, #8]
 80033dc:	6892      	ldr	r2, [r2, #8]
 80033de:	429a      	cmp	r2, r3
 80033e0:	d30e      	bcc.n	8003400 <chMtxLock+0x110>
 80033e2:	2300      	movs	r3, #0
 80033e4:	f383 8811 	msr	BASEPRI, r3
 80033e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
 80033ea:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80033ec:	60eb      	str	r3, [r5, #12]
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 80033ee:	60ac      	str	r4, [r5, #8]
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
 80033f0:	63a5      	str	r5, [r4, #56]	; 0x38
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80033f2:	f7ff fee5 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80033f6:	6833      	ldr	r3, [r6, #0]
 80033f8:	4a03      	ldr	r2, [pc, #12]	; (8003408 <chMtxLock+0x118>)
 80033fa:	42b3      	cmp	r3, r6
 80033fc:	d1ec      	bne.n	80033d8 <chMtxLock+0xe8>
 80033fe:	e7f0      	b.n	80033e2 <chMtxLock+0xf2>
 8003400:	4803      	ldr	r0, [pc, #12]	; (8003410 <chMtxLock+0x120>)
 8003402:	f7ff fc0d 	bl	8002c20 <chSysHalt>
 8003406:	bf00      	nop
 8003408:	20001320 	.word	0x20001320
 800340c:	0800516c 	.word	0x0800516c
 8003410:	08004fb8 	.word	0x08004fb8
	...

08003420 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8003420:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003424:	2320      	movs	r3, #32
 8003426:	b083      	sub	sp, #12
 8003428:	4607      	mov	r7, r0
 800342a:	f383 8811 	msr	BASEPRI, r3
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
 800342e:	4c86      	ldr	r4, [pc, #536]	; (8003648 <chRegFindThreadByWorkingArea+0x228>)
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8003430:	f7ff feee 	bl	8003210 <_dbg_check_lock>
 8003434:	6925      	ldr	r5, [r4, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8003436:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
 800343a:	3301      	adds	r3, #1
 800343c:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003440:	f7ff febe 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003444:	6823      	ldr	r3, [r4, #0]
 8003446:	42a3      	cmp	r3, r4
 8003448:	d004      	beq.n	8003454 <chRegFindThreadByWorkingArea+0x34>
 800344a:	69a2      	ldr	r2, [r4, #24]
 800344c:	689b      	ldr	r3, [r3, #8]
 800344e:	6892      	ldr	r2, [r2, #8]
 8003450:	429a      	cmp	r2, r3
 8003452:	d349      	bcc.n	80034e8 <chRegFindThreadByWorkingArea+0xc8>
 8003454:	2600      	movs	r6, #0
 8003456:	f386 8811 	msr	BASEPRI, r6
 800345a:	f8df 91ec 	ldr.w	r9, [pc, #492]	; 8003648 <chRegFindThreadByWorkingArea+0x228>
 800345e:	f04f 0820 	mov.w	r8, #32
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8003462:	69eb      	ldr	r3, [r5, #28]
 8003464:	42bb      	cmp	r3, r7
 8003466:	f000 80cb 	beq.w	8003600 <chRegFindThreadByWorkingArea+0x1e0>
 800346a:	f388 8811 	msr	BASEPRI, r8
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800346e:	f7ff fecf 	bl	8003210 <_dbg_check_lock>
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
 8003472:	f8d5 a010 	ldr.w	sl, [r5, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8003476:	45a2      	cmp	sl, r4
 8003478:	f000 80c9 	beq.w	800360e <chRegFindThreadByWorkingArea+0x1ee>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 800347c:	f89a 3022 	ldrb.w	r3, [sl, #34]	; 0x22
 8003480:	2bff      	cmp	r3, #255	; 0xff
 8003482:	d04a      	beq.n	800351a <chRegFindThreadByWorkingArea+0xfa>
    ntp->refs++;
 8003484:	3301      	adds	r3, #1
 8003486:	f88a 3022 	strb.w	r3, [sl, #34]	; 0x22
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800348a:	f7ff fe99 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800348e:	6822      	ldr	r2, [r4, #0]
 8003490:	42a2      	cmp	r2, r4
 8003492:	d005      	beq.n	80034a0 <chRegFindThreadByWorkingArea+0x80>
 8003494:	f8d9 3018 	ldr.w	r3, [r9, #24]
 8003498:	6892      	ldr	r2, [r2, #8]
 800349a:	689b      	ldr	r3, [r3, #8]
 800349c:	4293      	cmp	r3, r2
 800349e:	d323      	bcc.n	80034e8 <chRegFindThreadByWorkingArea+0xc8>
 80034a0:	f386 8811 	msr	BASEPRI, r6
 80034a4:	f388 8811 	msr	BASEPRI, r8
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80034a8:	f7ff feb2 	bl	8003210 <_dbg_check_lock>
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 80034ac:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
 80034b0:	b383      	cbz	r3, 8003514 <chRegFindThreadByWorkingArea+0xf4>
  tp->refs--;
 80034b2:	3b01      	subs	r3, #1
 80034b4:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 80034b8:	6a2b      	ldr	r3, [r5, #32]
 80034ba:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 80034be:	2b0f      	cmp	r3, #15
 80034c0:	d015      	beq.n	80034ee <chRegFindThreadByWorkingArea+0xce>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80034c2:	f7ff fe7d 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80034c6:	6823      	ldr	r3, [r4, #0]
 80034c8:	42a3      	cmp	r3, r4
 80034ca:	d005      	beq.n	80034d8 <chRegFindThreadByWorkingArea+0xb8>
 80034cc:	f8d9 2018 	ldr.w	r2, [r9, #24]
 80034d0:	689b      	ldr	r3, [r3, #8]
 80034d2:	6892      	ldr	r2, [r2, #8]
 80034d4:	429a      	cmp	r2, r3
 80034d6:	d31a      	bcc.n	800350e <chRegFindThreadByWorkingArea+0xee>
 80034d8:	f386 8811 	msr	BASEPRI, r6
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);
 80034dc:	f1ba 0f00 	cmp.w	sl, #0
 80034e0:	f000 8098 	beq.w	8003614 <chRegFindThreadByWorkingArea+0x1f4>
 80034e4:	4655      	mov	r5, sl
 80034e6:	e7bc      	b.n	8003462 <chRegFindThreadByWorkingArea+0x42>
 80034e8:	4858      	ldr	r0, [pc, #352]	; (800364c <chRegFindThreadByWorkingArea+0x22c>)
 80034ea:	f7ff fb99 	bl	8002c20 <chSysHalt>
    REG_REMOVE(tp);
 80034ee:	696a      	ldr	r2, [r5, #20]
 80034f0:	692b      	ldr	r3, [r5, #16]
 80034f2:	6113      	str	r3, [r2, #16]
 80034f4:	692b      	ldr	r3, [r5, #16]
 80034f6:	615a      	str	r2, [r3, #20]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80034f8:	f7ff fe62 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80034fc:	6822      	ldr	r2, [r4, #0]
 80034fe:	42a2      	cmp	r2, r4
 8003500:	d00e      	beq.n	8003520 <chRegFindThreadByWorkingArea+0x100>
 8003502:	f8d9 3018 	ldr.w	r3, [r9, #24]
 8003506:	6892      	ldr	r2, [r2, #8]
 8003508:	689b      	ldr	r3, [r3, #8]
 800350a:	4293      	cmp	r3, r2
 800350c:	d208      	bcs.n	8003520 <chRegFindThreadByWorkingArea+0x100>
 800350e:	4850      	ldr	r0, [pc, #320]	; (8003650 <chRegFindThreadByWorkingArea+0x230>)
 8003510:	f7ff fb86 	bl	8002c20 <chSysHalt>
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8003514:	484f      	ldr	r0, [pc, #316]	; (8003654 <chRegFindThreadByWorkingArea+0x234>)
 8003516:	f7ff fb83 	bl	8002c20 <chSysHalt>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 800351a:	484f      	ldr	r0, [pc, #316]	; (8003658 <chRegFindThreadByWorkingArea+0x238>)
 800351c:	f7ff fb80 	bl	8002c20 <chSysHalt>
 8003520:	f386 8811 	msr	BASEPRI, r6
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
    REG_REMOVE(tp);
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8003524:	f895 3021 	ldrb.w	r3, [r5, #33]	; 0x21
 8003528:	f003 0303 	and.w	r3, r3, #3
 800352c:	2b01      	cmp	r3, #1
 800352e:	d022      	beq.n	8003576 <chRegFindThreadByWorkingArea+0x156>
 8003530:	2b02      	cmp	r3, #2
 8003532:	d1d3      	bne.n	80034dc <chRegFindThreadByWorkingArea+0xbc>
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8003534:	f8d5 b040 	ldr.w	fp, [r5, #64]	; 0x40
 8003538:	69ed      	ldr	r5, [r5, #28]
 800353a:	f388 8811 	msr	BASEPRI, r8
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800353e:	f7ff fe67 	bl	8003210 <_dbg_check_lock>
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  struct pool_header *php = objp;

  chDbgCheckClassI();
 8003542:	f7ff fbc5 	bl	8002cd0 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) && (objp != NULL));
 8003546:	f1bb 0f00 	cmp.w	fp, #0
 800354a:	d065      	beq.n	8003618 <chRegFindThreadByWorkingArea+0x1f8>
 800354c:	2d00      	cmp	r5, #0
 800354e:	d063      	beq.n	8003618 <chRegFindThreadByWorkingArea+0x1f8>

  php->next = mp->next;
 8003550:	f8db 3000 	ldr.w	r3, [fp]
 8003554:	602b      	str	r3, [r5, #0]
  mp->next = php;
 8003556:	f8cb 5000 	str.w	r5, [fp]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800355a:	f7ff fe31 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800355e:	6823      	ldr	r3, [r4, #0]
 8003560:	42a3      	cmp	r3, r4
 8003562:	d0b9      	beq.n	80034d8 <chRegFindThreadByWorkingArea+0xb8>
 8003564:	f8d9 2018 	ldr.w	r2, [r9, #24]
 8003568:	689b      	ldr	r3, [r3, #8]
 800356a:	6892      	ldr	r2, [r2, #8]
 800356c:	429a      	cmp	r2, r3
 800356e:	d2b3      	bcs.n	80034d8 <chRegFindThreadByWorkingArea+0xb8>
 8003570:	483a      	ldr	r0, [pc, #232]	; (800365c <chRegFindThreadByWorkingArea+0x23c>)
 8003572:	f7ff fb55 	bl	8002c20 <chSysHalt>
 8003576:	f8d5 b01c 	ldr.w	fp, [r5, #28]
 */
void chHeapFree(void *p) {
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 800357a:	f1bb 0f00 	cmp.w	fp, #0
 800357e:	d043      	beq.n	8003608 <chRegFindThreadByWorkingArea+0x1e8>
 8003580:	f01b 0f07 	tst.w	fp, #7
 8003584:	d140      	bne.n	8003608 <chRegFindThreadByWorkingArea+0x1e8>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8003586:	e91b 000c 	ldmdb	fp, {r2, r3}
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800358a:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 800358c:	08db      	lsrs	r3, r3, #3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800358e:	f102 0510 	add.w	r5, r2, #16

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8003592:	f102 0c08 	add.w	ip, r2, #8

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8003596:	f84b 3c04 	str.w	r3, [fp, #-4]
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800359a:	4628      	mov	r0, r5

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 800359c:	f8cd c004 	str.w	ip, [sp, #4]
  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 80035a0:	f7ff fea6 	bl	80032f0 <chMtxLock>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 80035a4:	f8dd c004 	ldr.w	ip, [sp, #4]
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 80035a8:	f1ab 0108 	sub.w	r1, fp, #8
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 80035ac:	4663      	mov	r3, ip

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 80035ae:	4299      	cmp	r1, r3
 80035b0:	d305      	bcc.n	80035be <chRegFindThreadByWorkingArea+0x19e>
 80035b2:	685a      	ldr	r2, [r3, #4]
 80035b4:	3201      	adds	r2, #1
 80035b6:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 80035ba:	4291      	cmp	r1, r2
 80035bc:	d324      	bcc.n	8003608 <chRegFindThreadByWorkingArea+0x1e8>

    if (((qp == &heapp->header) || (hp > qp)) &&
 80035be:	459c      	cmp	ip, r3
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80035c0:	681a      	ldr	r2, [r3, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 80035c2:	d001      	beq.n	80035c8 <chRegFindThreadByWorkingArea+0x1a8>
 80035c4:	4299      	cmp	r1, r3
 80035c6:	d919      	bls.n	80035fc <chRegFindThreadByWorkingArea+0x1dc>
 80035c8:	b10a      	cbz	r2, 80035ce <chRegFindThreadByWorkingArea+0x1ae>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80035ca:	4291      	cmp	r1, r2
 80035cc:	d216      	bcs.n	80035fc <chRegFindThreadByWorkingArea+0x1dc>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80035ce:	f85b 0c04 	ldr.w	r0, [fp, #-4]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 80035d2:	f84b 2c08 	str.w	r2, [fp, #-8]
      H_NEXT(qp) = hp;
 80035d6:	6019      	str	r1, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80035d8:	f100 0c01 	add.w	ip, r0, #1
 80035dc:	f85b 2c08 	ldr.w	r2, [fp, #-8]
 80035e0:	eb01 0ecc 	add.w	lr, r1, ip, lsl #3
 80035e4:	4596      	cmp	lr, r2
 80035e6:	d023      	beq.n	8003630 <chRegFindThreadByWorkingArea+0x210>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
 80035e8:	6858      	ldr	r0, [r3, #4]
 80035ea:	1c42      	adds	r2, r0, #1
 80035ec:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 80035f0:	4291      	cmp	r1, r2
 80035f2:	d014      	beq.n	800361e <chRegFindThreadByWorkingArea+0x1fe>
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80035f4:	4628      	mov	r0, r5
 80035f6:	f7ff fe1b 	bl	8003230 <chMtxUnlock>
 80035fa:	e76f      	b.n	80034dc <chRegFindThreadByWorkingArea+0xbc>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
      }
      break;
    }
    qp = H_NEXT(qp);
 80035fc:	4613      	mov	r3, r2
 80035fe:	e7d6      	b.n	80035ae <chRegFindThreadByWorkingArea+0x18e>
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8003600:	4628      	mov	r0, r5
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);

  return NULL;
}
 8003602:	b003      	add	sp, #12
 8003604:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 */
void chHeapFree(void *p) {
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8003608:	4815      	ldr	r0, [pc, #84]	; (8003660 <chRegFindThreadByWorkingArea+0x240>)
 800360a:	f7ff fb09 	bl	8002c20 <chSysHalt>
  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 800360e:	f04f 0a00 	mov.w	sl, #0
 8003612:	e73a      	b.n	800348a <chRegFindThreadByWorkingArea+0x6a>
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);

  return NULL;
 8003614:	4650      	mov	r0, sl
 8003616:	e7f4      	b.n	8003602 <chRegFindThreadByWorkingArea+0x1e2>
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));
 8003618:	4812      	ldr	r0, [pc, #72]	; (8003664 <chRegFindThreadByWorkingArea+0x244>)
 800361a:	f7ff fb01 	bl	8002c20 <chSysHalt>
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 800361e:	f85b 1c04 	ldr.w	r1, [fp, #-4]
        H_NEXT(qp) = H_NEXT(hp);
 8003622:	f85b 2c08 	ldr.w	r2, [fp, #-8]
 8003626:	601a      	str	r2, [r3, #0]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8003628:	1842      	adds	r2, r0, r1
 800362a:	3201      	adds	r2, #1
 800362c:	605a      	str	r2, [r3, #4]
 800362e:	e7e1      	b.n	80035f4 <chRegFindThreadByWorkingArea+0x1d4>
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8003630:	f8de e004 	ldr.w	lr, [lr, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8003634:	f851 203c 	ldr.w	r2, [r1, ip, lsl #3]
 8003638:	f84b 2c08 	str.w	r2, [fp, #-8]
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 800363c:	eb0e 0200 	add.w	r2, lr, r0
 8003640:	3201      	adds	r2, #1
 8003642:	f84b 2c04 	str.w	r2, [fp, #-4]
 8003646:	e7cf      	b.n	80035e8 <chRegFindThreadByWorkingArea+0x1c8>
 8003648:	20001320 	.word	0x20001320
 800364c:	0800509c 	.word	0x0800509c
 8003650:	08005128 	.word	0x08005128
 8003654:	08005134 	.word	0x08005134
 8003658:	0800500c 	.word	0x0800500c
 800365c:	08005160 	.word	0x08005160
 8003660:	0800501c 	.word	0x0800501c
 8003664:	08004ff0 	.word	0x08004ff0
	...

08003670 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8003670:	b510      	push	{r4, lr}
 8003672:	2320      	movs	r3, #32
 8003674:	4604      	mov	r4, r0
 8003676:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800367a:	f7ff fdc9 	bl	8003210 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
 800367e:	b1ac      	cbz	r4, 80036ac <chThdSleep+0x3c>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8003680:	4621      	mov	r1, r4
 8003682:	2008      	movs	r0, #8
 8003684:	f7ff fb94 	bl	8002db0 <chSchGoSleepTimeoutS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8003688:	f7ff fd9a 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800368c:	4b09      	ldr	r3, [pc, #36]	; (80036b4 <chThdSleep+0x44>)
 800368e:	681a      	ldr	r2, [r3, #0]
 8003690:	429a      	cmp	r2, r3
 8003692:	d004      	beq.n	800369e <chThdSleep+0x2e>
 8003694:	6999      	ldr	r1, [r3, #24]
 8003696:	6893      	ldr	r3, [r2, #8]
 8003698:	688a      	ldr	r2, [r1, #8]
 800369a:	429a      	cmp	r2, r3
 800369c:	d303      	bcc.n	80036a6 <chThdSleep+0x36>
 800369e:	2300      	movs	r3, #0
 80036a0:	f383 8811 	msr	BASEPRI, r3
 80036a4:	bd10      	pop	{r4, pc}
 80036a6:	4804      	ldr	r0, [pc, #16]	; (80036b8 <chThdSleep+0x48>)
 80036a8:	f7ff faba 	bl	8002c20 <chSysHalt>
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);
 80036ac:	4803      	ldr	r0, [pc, #12]	; (80036bc <chThdSleep+0x4c>)
 80036ae:	f7ff fab7 	bl	8002c20 <chSysHalt>
 80036b2:	bf00      	nop
 80036b4:	20001320 	.word	0x20001320
 80036b8:	08005128 	.word	0x08005128
 80036bc:	08005090 	.word	0x08005090

080036c0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80036c0:	b508      	push	{r3, lr}
 80036c2:	4605      	mov	r5, r0
 80036c4:	2320      	movs	r3, #32
 80036c6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80036ca:	f7ff fda1 	bl	8003210 <_dbg_check_lock>
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 80036ce:	4b10      	ldr	r3, [pc, #64]	; (8003710 <chThdExit+0x50>)
 80036d0:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 80036d2:	6aa0      	ldr	r0, [r4, #40]	; 0x28

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 80036d4:	6265      	str	r5, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 80036d6:	f104 0528 	add.w	r5, r4, #40	; 0x28
 80036da:	42a8      	cmp	r0, r5
 80036dc:	d006      	beq.n	80036ec <chThdExit+0x2c>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 80036de:	6803      	ldr	r3, [r0, #0]
 80036e0:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 80036e2:	f7ff fc95 	bl	8003010 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 80036e6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 80036e8:	42a8      	cmp	r0, r5
 80036ea:	d1f8      	bne.n	80036de <chThdExit+0x1e>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80036ec:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 80036f0:	b943      	cbnz	r3, 8003704 <chThdExit+0x44>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 80036f2:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80036f6:	079b      	lsls	r3, r3, #30
 80036f8:	d104      	bne.n	8003704 <chThdExit+0x44>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 80036fa:	6963      	ldr	r3, [r4, #20]
 80036fc:	6922      	ldr	r2, [r4, #16]
 80036fe:	611a      	str	r2, [r3, #16]
 8003700:	6922      	ldr	r2, [r4, #16]
 8003702:	6153      	str	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8003704:	200f      	movs	r0, #15
 8003706:	f7ff fabb 	bl	8002c80 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 800370a:	4802      	ldr	r0, [pc, #8]	; (8003714 <chThdExit+0x54>)
 800370c:	f7ff fa88 	bl	8002c20 <chSysHalt>
 8003710:	20001320 	.word	0x20001320
 8003714:	08005144 	.word	0x08005144
	...

08003720 <BusFault_Handler>:
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
__attribute__((weak))
void _unhandled_exception(void) {
 8003720:	e7fe      	b.n	8003720 <BusFault_Handler>
 8003722:	bf00      	nop
	...

08003730 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8003730:	b4f0      	push	{r4, r5, r6, r7}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8003732:	4e11      	ldr	r6, [pc, #68]	; (8003778 <__init_ram_areas+0x48>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8003734:	2500      	movs	r5, #0
 8003736:	f106 0780 	add.w	r7, r6, #128	; 0x80
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 800373a:	e896 001a 	ldmia.w	r6, {r1, r3, r4}
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800373e:	42a3      	cmp	r3, r4
 8003740:	d20d      	bcs.n	800375e <__init_ram_areas+0x2e>
 8003742:	3904      	subs	r1, #4
 8003744:	461a      	mov	r2, r3
      *p = *tp;
 8003746:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800374a:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800374e:	42a2      	cmp	r2, r4
 8003750:	d3f9      	bcc.n	8003746 <__init_ram_areas+0x16>
 8003752:	43da      	mvns	r2, r3
 8003754:	4414      	add	r4, r2
 8003756:	f024 0403 	bic.w	r4, r4, #3
 800375a:	3404      	adds	r4, #4
 800375c:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800375e:	68f2      	ldr	r2, [r6, #12]
 8003760:	4293      	cmp	r3, r2
 8003762:	d203      	bcs.n	800376c <__init_ram_areas+0x3c>
      *p = 0;
 8003764:	f843 5b04 	str.w	r5, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8003768:	4293      	cmp	r3, r2
 800376a:	d3fb      	bcc.n	8003764 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 800376c:	3610      	adds	r6, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800376e:	42be      	cmp	r6, r7
 8003770:	d3e3      	bcc.n	800373a <__init_ram_areas+0xa>
#endif
}
 8003772:	bcf0      	pop	{r4, r5, r6, r7}
 8003774:	4770      	bx	lr
 8003776:	bf00      	nop
 8003778:	080050a8 	.word	0x080050a8
 800377c:	00000000 	.word	0x00000000

08003780 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8003780:	e7fe      	b.n	8003780 <__default_exit>
 8003782:	bf00      	nop
	...

08003790 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8003790:	4770      	bx	lr
 8003792:	bf00      	nop
	...

080037a0 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 80037a0:	4770      	bx	lr
 80037a2:	bf00      	nop
	...

080037b0 <get_descriptor.lto_priv.67>:
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
 80037b0:	2902      	cmp	r1, #2
 80037b2:	d006      	beq.n	80037c2 <get_descriptor.lto_priv.67+0x12>
 80037b4:	2903      	cmp	r1, #3
 80037b6:	d006      	beq.n	80037c6 <get_descriptor.lto_priv.67+0x16>
 80037b8:	2901      	cmp	r1, #1
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
      return &vcom_strings[dindex];
  }
  return NULL;
 80037ba:	4806      	ldr	r0, [pc, #24]	; (80037d4 <get_descriptor.lto_priv.67+0x24>)
 80037bc:	bf18      	it	ne
 80037be:	2000      	movne	r0, #0
 80037c0:	4770      	bx	lr
  (void)lang;
  switch (dtype) {
  case USB_DESCRIPTOR_DEVICE:
    return &vcom_device_descriptor;
  case USB_DESCRIPTOR_CONFIGURATION:
    return &vcom_configuration_descriptor;
 80037c2:	4805      	ldr	r0, [pc, #20]	; (80037d8 <get_descriptor.lto_priv.67+0x28>)
 80037c4:	4770      	bx	lr
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
 80037c6:	2a03      	cmp	r2, #3
      return &vcom_strings[dindex];
 80037c8:	bf9a      	itte	ls
 80037ca:	4b04      	ldrls	r3, [pc, #16]	; (80037dc <get_descriptor.lto_priv.67+0x2c>)
 80037cc:	eb03 00c2 	addls.w	r0, r3, r2, lsl #3
  }
  return NULL;
 80037d0:	2000      	movhi	r0, #0
}
 80037d2:	4770      	bx	lr
 80037d4:	0800526c 	.word	0x0800526c
 80037d8:	08005288 	.word	0x08005288
 80037dc:	080052d4 	.word	0x080052d4

080037e0 <blinker_thread.lto_priv.56>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 80037e0:	4b0f      	ldr	r3, [pc, #60]	; (8003820 <blinker_thread.lto_priv.56+0x40>)
 80037e2:	4a10      	ldr	r2, [pc, #64]	; (8003824 <blinker_thread.lto_priv.56+0x44>)
 80037e4:	699b      	ldr	r3, [r3, #24]
 80037e6:	f8df 8044 	ldr.w	r8, [pc, #68]	; 800382c <blinker_thread.lto_priv.56+0x4c>
  chRegSetThreadName("blinker");
  while (true) {
    systime_t time;

    time = serusbcfg.usbp->state == USB_ACTIVE ? 250 : 500;
    palClearLine(LINE_LED6);
 80037ea:	4d0f      	ldr	r5, [pc, #60]	; (8003828 <blinker_thread.lto_priv.56+0x48>)
static bool initSensors(void);
/*
 * LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(blinker_thread_wa, 128);
static THD_FUNCTION(blinker_thread, arg) {
 80037ec:	b580      	push	{r7, lr}
  chRegSetThreadName("blinker");
  while (true) {
    systime_t time;

    time = serusbcfg.usbp->state == USB_ACTIVE ? 250 : 500;
    palClearLine(LINE_LED6);
 80037ee:	f248 0600 	movw	r6, #32768	; 0x8000
 80037f2:	619a      	str	r2, [r3, #24]
 80037f4:	f44f 4700 	mov.w	r7, #32768	; 0x8000
  (void)arg;
  chRegSetThreadName("blinker");
  while (true) {
    systime_t time;

    time = serusbcfg.usbp->state == USB_ACTIVE ? 250 : 500;
 80037f8:	f898 4000 	ldrb.w	r4, [r8]
    palClearLine(LINE_LED6);
 80037fc:	836e      	strh	r6, [r5, #26]
  (void)arg;
  chRegSetThreadName("blinker");
  while (true) {
    systime_t time;

    time = serusbcfg.usbp->state == USB_ACTIVE ? 250 : 500;
 80037fe:	f640 13c4 	movw	r3, #2500	; 0x9c4
 8003802:	f241 3288 	movw	r2, #5000	; 0x1388
 8003806:	2c04      	cmp	r4, #4
 8003808:	bf0c      	ite	eq
 800380a:	461c      	moveq	r4, r3
 800380c:	4614      	movne	r4, r2
    palClearLine(LINE_LED6);
    chThdSleepMilliseconds(time);
 800380e:	4620      	mov	r0, r4
 8003810:	f7ff ff2e 	bl	8003670 <chThdSleep>
    palSetLine(LINE_LED6);
    chThdSleepMilliseconds(time);
 8003814:	4620      	mov	r0, r4
    systime_t time;

    time = serusbcfg.usbp->state == USB_ACTIVE ? 250 : 500;
    palClearLine(LINE_LED6);
    chThdSleepMilliseconds(time);
    palSetLine(LINE_LED6);
 8003816:	832f      	strh	r7, [r5, #24]
    chThdSleepMilliseconds(time);
 8003818:	f7ff ff2a 	bl	8003670 <chThdSleep>
 800381c:	e7ec      	b.n	80037f8 <blinker_thread.lto_priv.56+0x18>
 800381e:	bf00      	nop
 8003820:	20001320 	.word	0x20001320
 8003824:	08005290 	.word	0x08005290
 8003828:	40020c00 	.word	0x40020c00
 800382c:	200010e0 	.word	0x200010e0

08003830 <sof_handler.lto_priv.68>:
}

/*
 * Handles the USB driver global events.
 */
static void sof_handler(USBDriver *usbp) {
 8003830:	b530      	push	{r4, r5, lr}
 8003832:	2320      	movs	r3, #32
 8003834:	b083      	sub	sp, #12
 8003836:	f383 8811 	msr	BASEPRI, r3
 */
void sduSOFHookI(SerialUSBDriver *sdup) {

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 800383a:	4c25      	ldr	r4, [pc, #148]	; (80038d0 <sof_handler.lto_priv.68+0xa0>)
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800383c:	f7ff fc70 	bl	8003120 <_dbg_check_lock_from_isr>
 8003840:	f8d4 248c 	ldr.w	r2, [r4, #1164]	; 0x48c
 8003844:	6813      	ldr	r3, [r2, #0]
 8003846:	7819      	ldrb	r1, [r3, #0]
 8003848:	2904      	cmp	r1, #4
 800384a:	d006      	beq.n	800385a <sof_handler.lto_priv.68+0x2a>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800384c:	f7ff fc50 	bl	80030f0 <_dbg_check_unlock_from_isr>
 8003850:	2300      	movs	r3, #0
 8003852:	f383 8811 	msr	BASEPRI, r3
  (void)usbp;

  osalSysLockFromISR();
  sduSOFHookI(&SDU1);
  osalSysUnlockFromISR();
}
 8003856:	b003      	add	sp, #12
 8003858:	bd30      	pop	{r4, r5, pc}
 800385a:	7a21      	ldrb	r1, [r4, #8]
 800385c:	2902      	cmp	r1, #2
 800385e:	d1f5      	bne.n	800384c <sof_handler.lto_priv.68+0x1c>
    return;
  }

  /* If there is already a transaction ongoing then another one cannot be
     started.*/
  if (usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8003860:	7911      	ldrb	r1, [r2, #4]
 8003862:	891a      	ldrh	r2, [r3, #8]
 8003864:	2301      	movs	r3, #1
 8003866:	408b      	lsls	r3, r1
 8003868:	4213      	tst	r3, r2
 800386a:	d1ef      	bne.n	800384c <sof_handler.lto_priv.68+0x1c>
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();
 800386c:	f7ff fa30 	bl	8002cd0 <chDbgCheckClassI>

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 8003870:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8003872:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8003874:	4293      	cmp	r3, r2
 8003876:	d1e9      	bne.n	800384c <sof_handler.lto_priv.68+0x1c>
 8003878:	6d22      	ldr	r2, [r4, #80]	; 0x50
 800387a:	2a00      	cmp	r2, #0
 800387c:	d0e6      	beq.n	800384c <sof_handler.lto_priv.68+0x1c>
 800387e:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 8003880:	2a00      	cmp	r2, #0
 8003882:	d0e3      	beq.n	800384c <sof_handler.lto_priv.68+0x1c>
 8003884:	3a04      	subs	r2, #4
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));

    if (size > 0U) {
 8003886:	1ad2      	subs	r2, r2, r3
 8003888:	d0e0      	beq.n	800384c <sof_handler.lto_priv.68+0x1c>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 800388a:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
      obqp->bwrptr += obqp->bsize;
 800388c:	6e22      	ldr	r2, [r4, #96]	; 0x60
      if (obqp->bwrptr >= obqp->btop) {
 800388e:	6de0      	ldr	r0, [r4, #92]	; 0x5c

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 8003890:	6d21      	ldr	r1, [r4, #80]	; 0x50
      if (obqp->bwrptr >= obqp->btop) {
        obqp->bwrptr = obqp->buffers;
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 8003892:	4d0f      	ldr	r5, [pc, #60]	; (80038d0 <sof_handler.lto_priv.68+0xa0>)
      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
      obqp->bwrptr += obqp->bsize;
 8003894:	4413      	add	r3, r2
      if (obqp->bwrptr >= obqp->btop) {
 8003896:	4283      	cmp	r3, r0
      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
      obqp->bwrptr += obqp->bsize;
 8003898:	6563      	str	r3, [r4, #84]	; 0x54

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 800389a:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
      obqp->bwrptr += obqp->bsize;
      if (obqp->bwrptr >= obqp->btop) {
        obqp->bwrptr = obqp->buffers;
 800389e:	bf28      	it	cs
 80038a0:	6ea3      	ldrcs	r3, [r4, #104]	; 0x68

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 80038a2:	6521      	str	r1, [r4, #80]	; 0x50
      obqp->bwrptr += obqp->bsize;
      if (obqp->bwrptr >= obqp->btop) {
        obqp->bwrptr = obqp->buffers;
 80038a4:	bf28      	it	cs
 80038a6:	6563      	strcs	r3, [r4, #84]	; 0x54

  /* Checking if there only a buffer partially filled, if so then it is
     enforced in the queue and transmitted.*/
  if (obqTryFlushI(&sdup->obqueue)) {
    size_t n;
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);
 80038a8:	f105 0044 	add.w	r0, r5, #68	; 0x44
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 80038ac:	2300      	movs	r3, #0
 80038ae:	a901      	add	r1, sp, #4
 80038b0:	66e3      	str	r3, [r4, #108]	; 0x6c
 80038b2:	f7fd fe9d 	bl	80015f0 <obqGetFullBufferI>

    osalDbgAssert(buf != NULL, "queue is empty");
 80038b6:	4602      	mov	r2, r0
 80038b8:	b138      	cbz	r0, 80038ca <sof_handler.lto_priv.68+0x9a>

    usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in, buf, n);
 80038ba:	f8d5 148c 	ldr.w	r1, [r5, #1164]	; 0x48c
 80038be:	9b01      	ldr	r3, [sp, #4]
 80038c0:	6808      	ldr	r0, [r1, #0]
 80038c2:	7909      	ldrb	r1, [r1, #4]
 80038c4:	f7fe fdec 	bl	80024a0 <usbStartTransmitI>
 80038c8:	e7c0      	b.n	800384c <sof_handler.lto_priv.68+0x1c>
     enforced in the queue and transmitted.*/
  if (obqTryFlushI(&sdup->obqueue)) {
    size_t n;
    uint8_t *buf = obqGetFullBufferI(&sdup->obqueue, &n);

    osalDbgAssert(buf != NULL, "queue is empty");
 80038ca:	4802      	ldr	r0, [pc, #8]	; (80038d4 <sof_handler.lto_priv.68+0xa4>)
 80038cc:	f7ff f9a8 	bl	8002c20 <chSysHalt>
 80038d0:	200008cc 	.word	0x200008cc
 80038d4:	08005358 	.word	0x08005358
	...

080038e0 <usb_event.lto_priv.66>:
};

/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
 80038e0:	b538      	push	{r3, r4, r5, lr}
  extern SerialUSBDriver SDU1;

  switch (event) {
 80038e2:	2905      	cmp	r1, #5
 80038e4:	d816      	bhi.n	8003914 <usb_event.lto_priv.66+0x34>
 80038e6:	e8df f001 	tbb	[pc, r1]
 80038ea:	1550      	.short	0x1550
 80038ec:	03505016 	.word	0x03505016
 80038f0:	2320      	movs	r3, #32
 80038f2:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80038f6:	f7ff fc13 	bl	8003120 <_dbg_check_lock_from_isr>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80038fa:	4832      	ldr	r0, [pc, #200]	; (80039c4 <usb_event.lto_priv.66+0xe4>)
 80038fc:	2101      	movs	r1, #1
 80038fe:	f7fd feff 	bl	8001700 <chEvtBroadcastFlagsI>
 * @iclass
 */
void sduWakeupHookI(SerialUSBDriver *sdup) {

  chnAddFlagsI(sdup, CHN_CONNECTED);
  bqResumeX(&sdup->ibqueue);
 8003902:	4b31      	ldr	r3, [pc, #196]	; (80039c8 <usb_event.lto_priv.66+0xe8>)
 8003904:	2400      	movs	r4, #0
 8003906:	751c      	strb	r4, [r3, #20]
  bqResumeX(&sdup->obqueue);
 8003908:	f883 404c 	strb.w	r4, [r3, #76]	; 0x4c
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 800390c:	f7ff fbf0 	bl	80030f0 <_dbg_check_unlock_from_isr>
 8003910:	f384 8811 	msr	BASEPRI, r4
 8003914:	bd38      	pop	{r3, r4, r5, pc}
 8003916:	4605      	mov	r5, r0
 8003918:	2320      	movs	r3, #32
 800391a:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800391e:	f7ff fbff 	bl	8003120 <_dbg_check_lock_from_isr>
 */
void ibqResetI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();

  ibqp->bcounter  = 0;
 8003922:	4c2a      	ldr	r4, [pc, #168]	; (80039cc <usb_event.lto_priv.66+0xec>)
    chSysLockFromISR();

    /* Enables the endpoints specified into the configuration.
       Note, this callback is invoked from an ISR so I-Class functions
       must be used.*/
    usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 8003924:	4a2a      	ldr	r2, [pc, #168]	; (80039d0 <usb_event.lto_priv.66+0xf0>)
 8003926:	4628      	mov	r0, r5
 8003928:	2101      	movs	r1, #1
 800392a:	f7fd fd59 	bl	80013e0 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 800392e:	2102      	movs	r1, #2
 8003930:	4a28      	ldr	r2, [pc, #160]	; (80039d4 <usb_event.lto_priv.66+0xf4>)
 8003932:	4628      	mov	r0, r5
 8003934:	f7fd fd54 	bl	80013e0 <usbInitEndpointI>
 8003938:	2500      	movs	r5, #0
 *
 * @iclass
 */
void ibqResetI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();
 800393a:	f7ff f9c9 	bl	8002cd0 <chDbgCheckClassI>

  ibqp->bcounter  = 0;
  ibqp->brdptr    = ibqp->buffers;
 800393e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003940:	6223      	str	r3, [r4, #32]
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8003942:	f104 000c 	add.w	r0, r4, #12
  ibqp->bwrptr    = ibqp->buffers;
 8003946:	61e3      	str	r3, [r4, #28]
 */
void ibqResetI(input_buffers_queue_t *ibqp) {

  osalDbgCheckClassI();

  ibqp->bcounter  = 0;
 8003948:	61a5      	str	r5, [r4, #24]
  ibqp->brdptr    = ibqp->buffers;
  ibqp->bwrptr    = ibqp->buffers;
  ibqp->ptr       = NULL;
 800394a:	6365      	str	r5, [r4, #52]	; 0x34
  ibqp->top       = NULL;
 800394c:	63a5      	str	r5, [r4, #56]	; 0x38
 800394e:	f000 fdb7 	bl	80044c0 <chThdDequeueAllI.constprop.42>
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {

  ibqResetI(&sdup->ibqueue);
  bqResumeX(&sdup->ibqueue);
 8003952:	7525      	strb	r5, [r4, #20]
 *
 * @iclass
 */
void obqResetI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();
 8003954:	f7ff f9bc 	bl	8002cd0 <chDbgCheckClassI>

  obqp->bcounter  = bqSizeX(obqp);
  obqp->brdptr    = obqp->buffers;
 8003958:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 */
void obqResetI(output_buffers_queue_t *obqp) {

  osalDbgCheckClassI();

  obqp->bcounter  = bqSizeX(obqp);
 800395a:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800395c:	6522      	str	r2, [r4, #80]	; 0x50
  obqp->brdptr    = obqp->buffers;
 800395e:	65a3      	str	r3, [r4, #88]	; 0x58
  obqp->bwrptr    = obqp->buffers;
 8003960:	6563      	str	r3, [r4, #84]	; 0x54
 8003962:	f104 0044 	add.w	r0, r4, #68	; 0x44
  obqp->ptr       = NULL;
 8003966:	66e5      	str	r5, [r4, #108]	; 0x6c
  obqp->top       = NULL;
 8003968:	6725      	str	r5, [r4, #112]	; 0x70
 800396a:	f000 fda9 	bl	80044c0 <chThdDequeueAllI.constprop.42>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800396e:	2101      	movs	r1, #1
 8003970:	1d20      	adds	r0, r4, #4
  obqResetI(&sdup->obqueue);
  bqResumeX(&sdup->obqueue);
 8003972:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
 8003976:	f7fd fec3 	bl	8001700 <chEvtBroadcastFlagsI>
  chnAddFlagsI(sdup, CHN_CONNECTED);
  (void) sdu_start_receive(sdup);
 800397a:	4620      	mov	r0, r4
 800397c:	f7fd fe08 	bl	8001590 <sdu_start_receive.lto_priv.78>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8003980:	f7ff fbb6 	bl	80030f0 <_dbg_check_unlock_from_isr>
 8003984:	f385 8811 	msr	BASEPRI, r5
 8003988:	bd38      	pop	{r3, r4, r5, pc}
 800398a:	2320      	movs	r3, #32
 800398c:	f383 8811 	msr	BASEPRI, r3
 * @iclass
 */
void sduSuspendHookI(SerialUSBDriver *sdup) {

  chnAddFlagsI(sdup, CHN_DISCONNECTED);
  bqSuspendI(&sdup->ibqueue);
 8003990:	4c0d      	ldr	r4, [pc, #52]	; (80039c8 <usb_event.lto_priv.66+0xe8>)
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8003992:	f7ff fbc5 	bl	8003120 <_dbg_check_lock_from_isr>
 8003996:	2102      	movs	r1, #2
 8003998:	1d20      	adds	r0, r4, #4
 800399a:	f7fd feb1 	bl	8001700 <chEvtBroadcastFlagsI>
 800399e:	2501      	movs	r5, #1
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 80039a0:	f104 000c 	add.w	r0, r4, #12
 80039a4:	7525      	strb	r5, [r4, #20]
 80039a6:	f000 fd8b 	bl	80044c0 <chThdDequeueAllI.constprop.42>
 80039aa:	f104 0044 	add.w	r0, r4, #68	; 0x44
  bqSuspendI(&sdup->obqueue);
 80039ae:	f884 504c 	strb.w	r5, [r4, #76]	; 0x4c
 80039b2:	f000 fd85 	bl	80044c0 <chThdDequeueAllI.constprop.42>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80039b6:	f7ff fb9b 	bl	80030f0 <_dbg_check_unlock_from_isr>
 80039ba:	2300      	movs	r3, #0
 80039bc:	f383 8811 	msr	BASEPRI, r3
 80039c0:	bd38      	pop	{r3, r4, r5, pc}
 80039c2:	bf00      	nop
 80039c4:	200008d0 	.word	0x200008d0
 80039c8:	200008cc 	.word	0x200008cc
 80039cc:	200008cc 	.word	0x200008cc
 80039d0:	08005334 	.word	0x08005334
 80039d4:	08005304 	.word	0x08005304
	...

080039e0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80039e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80039e4:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 80039e8:	482f      	ldr	r0, [pc, #188]	; (8003aa8 <VectorB0+0xc8>)
 80039ea:	f7ff f8c9 	bl	8002b80 <_trace_isr_enter>
 80039ee:	f7ff fb67 	bl	80030c0 <_dbg_check_enter_isr>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80039f2:	693b      	ldr	r3, [r7, #16]
 80039f4:	079b      	lsls	r3, r3, #30
 80039f6:	d408      	bmi.n	8003a0a <VectorB0+0x2a>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 80039f8:	f7ff fb4a 	bl	8003090 <_dbg_check_leave_isr>
 80039fc:	482a      	ldr	r0, [pc, #168]	; (8003aa8 <VectorB0+0xc8>)
 80039fe:	f7ff f89f 	bl	8002b40 <_trace_isr_leave>
}
 8003a02:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8003a06:	f7fd be43 	b.w	8001690 <_port_irq_epilogue>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8003a0a:	2600      	movs	r6, #0
 8003a0c:	613e      	str	r6, [r7, #16]
 8003a0e:	f04f 0820 	mov.w	r8, #32
 8003a12:	f388 8811 	msr	BASEPRI, r8
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8003a16:	4d25      	ldr	r5, [pc, #148]	; (8003aac <VectorB0+0xcc>)
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8003a18:	f7ff fb82 	bl	8003120 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
 8003a1c:	f7ff f958 	bl	8002cd0 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();
 8003a20:	f7ff f956 	bl	8002cd0 <chDbgCheckClassI>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8003a24:	69ec      	ldr	r4, [r5, #28]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003a26:	6a78      	ldr	r0, [r7, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8003a28:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8003a2a:	68a3      	ldr	r3, [r4, #8]
 8003a2c:	1a42      	subs	r2, r0, r1
 8003a2e:	429a      	cmp	r2, r3
 8003a30:	f105 091c 	add.w	r9, r5, #28
 8003a34:	d31c      	bcc.n	8003a70 <VectorB0+0x90>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8003a36:	6822      	ldr	r2, [r4, #0]
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
 8003a38:	f8d4 a00c 	ldr.w	sl, [r4, #12]
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8003a3c:	440b      	add	r3, r1
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8003a3e:	454a      	cmp	r2, r9
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8003a40:	62ab      	str	r3, [r5, #40]	; 0x28

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8003a42:	f8c2 9004 	str.w	r9, [r2, #4]
    ch.vtlist.next = vtp->next;
 8003a46:	61ea      	str	r2, [r5, #28]
    fn = vtp->func;
    vtp->func = NULL;
 8003a48:	60e6      	str	r6, [r4, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8003a4a:	bf08      	it	eq
 8003a4c:	60fe      	streq	r6, [r7, #12]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8003a4e:	f7ff fb4f 	bl	80030f0 <_dbg_check_unlock_from_isr>
 8003a52:	f386 8811 	msr	BASEPRI, r6
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 8003a56:	6920      	ldr	r0, [r4, #16]
 8003a58:	47d0      	blx	sl
 8003a5a:	f388 8811 	msr	BASEPRI, r8
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8003a5e:	f7ff fb5f 	bl	8003120 <_dbg_check_lock_from_isr>
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 8003a62:	69ec      	ldr	r4, [r5, #28]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003a64:	6a78      	ldr	r0, [r7, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8003a66:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8003a68:	68a3      	ldr	r3, [r4, #8]
 8003a6a:	1a42      	subs	r2, r0, r1
 8003a6c:	4293      	cmp	r3, r2
 8003a6e:	d9e2      	bls.n	8003a36 <VectorB0+0x56>
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8003a70:	454c      	cmp	r4, r9
 8003a72:	d010      	beq.n	8003a96 <VectorB0+0xb6>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 8003a74:	440b      	add	r3, r1
 8003a76:	1a1b      	subs	r3, r3, r0
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8003a78:	2b01      	cmp	r3, #1
 8003a7a:	bf98      	it	ls
 8003a7c:	2302      	movls	r3, #2
  }
  port_timer_set_alarm(now + delta);
 8003a7e:	181c      	adds	r4, r3, r0
 8003a80:	4620      	mov	r0, r4
 8003a82:	f7fd fdf5 	bl	8001670 <stSetAlarm>
 8003a86:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.lasttime) <=
 8003a8a:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8003a8c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003a8e:	1a63      	subs	r3, r4, r1
 8003a90:	1a52      	subs	r2, r2, r1
 8003a92:	429a      	cmp	r2, r3
 8003a94:	d805      	bhi.n	8003aa2 <VectorB0+0xc2>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8003a96:	f7ff fb2b 	bl	80030f0 <_dbg_check_unlock_from_isr>
 8003a9a:	2300      	movs	r3, #0
 8003a9c:	f383 8811 	msr	BASEPRI, r3
 8003aa0:	e7aa      	b.n	80039f8 <VectorB0+0x18>
 8003aa2:	4803      	ldr	r0, [pc, #12]	; (8003ab0 <VectorB0+0xd0>)
 8003aa4:	f7ff f8bc 	bl	8002c20 <chSysHalt>
 8003aa8:	08005298 	.word	0x08005298
 8003aac:	20001320 	.word	0x20001320
 8003ab0:	08005328 	.word	0x08005328
	...

08003ac0 <VectorC0>:
}

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 8003ac0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint16_t sr = I2CD1.i2c->SR1;
 8003ac2:	4c3a      	ldr	r4, [pc, #232]	; (8003bac <VectorC0+0xec>)

  OSAL_IRQ_PROLOGUE();
 8003ac4:	483a      	ldr	r0, [pc, #232]	; (8003bb0 <VectorC0+0xf0>)

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;
 8003ac6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003ac8:	695e      	ldr	r6, [r3, #20]

  OSAL_IRQ_PROLOGUE();
 8003aca:	f7ff f859 	bl	8002b80 <_trace_isr_enter>

/**
 * @brief   I2C1 error interrupt handler.
 */
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;
 8003ace:	b2b5      	uxth	r5, r6

  OSAL_IRQ_PROLOGUE();
 8003ad0:	f7ff faf6 	bl	80030c0 <_dbg_check_enter_isr>
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8003ad4:	6b27      	ldr	r7, [r4, #48]	; 0x30
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;

  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8003ad6:	6b61      	ldr	r1, [r4, #52]	; 0x34
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8003ad8:	683a      	ldr	r2, [r7, #0]
OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
  uint16_t sr = I2CD1.i2c->SR1;

  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
 8003ada:	f405 435f 	and.w	r3, r5, #57088	; 0xdf00
 8003ade:	43db      	mvns	r3, r3
 8003ae0:	614b      	str	r3, [r1, #20]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8003ae2:	6813      	ldr	r3, [r2, #0]
 8003ae4:	f023 031f 	bic.w	r3, r3, #31
 8003ae8:	6013      	str	r3, [r2, #0]
 8003aea:	6813      	ldr	r3, [r2, #0]
 8003aec:	07d8      	lsls	r0, r3, #31
 8003aee:	d4fc      	bmi.n	8003aea <VectorC0+0x2a>
 8003af0:	f897 e008 	ldrb.w	lr, [r7, #8]
  dmaStreamDisable(i2cp->dmarx);
 8003af4:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8003af6:	687f      	ldr	r7, [r7, #4]
  dmaStreamDisable(i2cp->dmarx);
 8003af8:	6802      	ldr	r2, [r0, #0]
 * @notapi
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint16_t sr) {

  /* Clears interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8003afa:	233d      	movs	r3, #61	; 0x3d
 8003afc:	fa03 f30e 	lsl.w	r3, r3, lr
 8003b00:	603b      	str	r3, [r7, #0]
  dmaStreamDisable(i2cp->dmarx);
 8003b02:	6813      	ldr	r3, [r2, #0]
 8003b04:	f023 031f 	bic.w	r3, r3, #31
 8003b08:	6013      	str	r3, [r2, #0]
 8003b0a:	6813      	ldr	r3, [r2, #0]
 8003b0c:	f013 0301 	ands.w	r3, r3, #1
 8003b10:	d1fb      	bne.n	8003b0a <VectorC0+0x4a>
 8003b12:	7a07      	ldrb	r7, [r0, #8]
 8003b14:	6840      	ldr	r0, [r0, #4]
 8003b16:	223d      	movs	r2, #61	; 0x3d
 8003b18:	40ba      	lsls	r2, r7
 8003b1a:	6002      	str	r2, [r0, #0]

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
 8003b1c:	05ea      	lsls	r2, r5, #23
    i2cp->errors |= I2C_BUS_ERROR;
 8003b1e:	bf48      	it	mi
 8003b20:	2301      	movmi	r3, #1

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
 8003b22:	05af      	lsls	r7, r5, #22
  dmaStreamDisable(i2cp->dmarx);

  i2cp->errors = I2C_NO_ERROR;

  if (sr & I2C_SR1_BERR)                            /* Bus error.           */
    i2cp->errors |= I2C_BUS_ERROR;
 8003b24:	60a3      	str	r3, [r4, #8]

  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8003b26:	bf44      	itt	mi
 8003b28:	f043 0302 	orrmi.w	r3, r3, #2
 8003b2c:	60a3      	strmi	r3, [r4, #8]

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
 8003b2e:	0568      	lsls	r0, r5, #21
 8003b30:	d50a      	bpl.n	8003b48 <VectorC0+0x88>
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
 8003b32:	684a      	ldr	r2, [r1, #4]
 8003b34:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8003b38:	604a      	str	r2, [r1, #4]
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8003b3a:	680a      	ldr	r2, [r1, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8003b3c:	f043 0304 	orr.w	r3, r3, #4
  if (sr & I2C_SR1_ARLO)                            /* Arbitration lost.    */
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (sr & I2C_SR1_AF) {                            /* Acknowledge fail.    */
    i2cp->i2c->CR2 &= ~I2C_CR2_ITEVTEN;
    i2cp->i2c->CR1 |= I2C_CR1_STOP;                 /* Setting stop bit.    */
 8003b40:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8003b44:	600a      	str	r2, [r1, #0]
    i2cp->errors |= I2C_ACK_FAILURE;
 8003b46:	60a3      	str	r3, [r4, #8]
  }

  if (sr & I2C_SR1_OVR)                             /* Overrun.             */
 8003b48:	052a      	lsls	r2, r5, #20
    i2cp->errors |= I2C_OVERRUN;
 8003b4a:	bf44      	itt	mi
 8003b4c:	f043 0308 	orrmi.w	r3, r3, #8
 8003b50:	60a3      	strmi	r3, [r4, #8]

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
 8003b52:	046f      	lsls	r7, r5, #17
    i2cp->errors |= I2C_TIMEOUT;
 8003b54:	bf44      	itt	mi
 8003b56:	f043 0320 	orrmi.w	r3, r3, #32
 8003b5a:	60a3      	strmi	r3, [r4, #8]

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
 8003b5c:	04e8      	lsls	r0, r5, #19
 8003b5e:	d514      	bpl.n	8003b8a <VectorC0+0xca>
    i2cp->errors |= I2C_PEC_ERROR;
 8003b60:	f043 0310 	orr.w	r3, r3, #16

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8003b64:	0431      	lsls	r1, r6, #16

  if (sr & I2C_SR1_TIMEOUT)                         /* SMBus Timeout.       */
    i2cp->errors |= I2C_TIMEOUT;

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;
 8003b66:	60a3      	str	r3, [r4, #8]

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
 8003b68:	d41c      	bmi.n	8003ba4 <VectorC0+0xe4>
 8003b6a:	2320      	movs	r3, #32
 8003b6c:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8003b70:	f7ff fad6 	bl	8003120 <_dbg_check_lock_from_isr>
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 8003b74:	480f      	ldr	r0, [pc, #60]	; (8003bb4 <VectorC0+0xf4>)
 8003b76:	f06f 0101 	mvn.w	r1, #1
 8003b7a:	f7ff fa71 	bl	8003060 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8003b7e:	f7ff fab7 	bl	80030f0 <_dbg_check_unlock_from_isr>
 8003b82:	2300      	movs	r3, #0
 8003b84:	f383 8811 	msr	BASEPRI, r3
 8003b88:	e003      	b.n	8003b92 <VectorC0+0xd2>
 8003b8a:	0432      	lsls	r2, r6, #16
 8003b8c:	d40a      	bmi.n	8003ba4 <VectorC0+0xe4>
    i2cp->errors |= I2C_SMB_ALERT;

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 8003b8e:	2b00      	cmp	r3, #0
 8003b90:	d1eb      	bne.n	8003b6a <VectorC0+0xaa>
  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
 8003b92:	f7ff fa7d 	bl	8003090 <_dbg_check_leave_isr>
 8003b96:	4806      	ldr	r0, [pc, #24]	; (8003bb0 <VectorC0+0xf0>)
 8003b98:	f7fe ffd2 	bl	8002b40 <_trace_isr_leave>
}
 8003b9c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_PROLOGUE();

  I2CD1.i2c->SR1 = ~(sr & I2C_ERROR_MASK);
  i2c_lld_serve_error_interrupt(&I2CD1, sr);

  OSAL_IRQ_EPILOGUE();
 8003ba0:	f7fd bd76 	b.w	8001690 <_port_irq_epilogue>

  if (sr & I2C_SR1_PECERR)                          /* PEC error.           */
    i2cp->errors |= I2C_PEC_ERROR;

  if (sr & I2C_SR1_SMBALERT)                        /* SMBus alert.         */
    i2cp->errors |= I2C_SMB_ALERT;
 8003ba4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8003ba8:	60a3      	str	r3, [r4, #8]
 8003baa:	e7de      	b.n	8003b6a <VectorC0+0xaa>
 8003bac:	20001c2c 	.word	0x20001c2c
 8003bb0:	08005364 	.word	0x08005364
 8003bb4:	20001c48 	.word	0x20001c48
	...

08003bc0 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8003bc0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 8003bc4:	4e91      	ldr	r6, [pc, #580]	; (8003e0c <Vector14C+0x24c>)
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 8003bc6:	4892      	ldr	r0, [pc, #584]	; (8003e10 <Vector14C+0x250>)
 8003bc8:	f7fe ffda 	bl	8002b80 <_trace_isr_enter>
 8003bcc:	f7ff fa78 	bl	80030c0 <_dbg_check_enter_isr>
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 8003bd0:	6d75      	ldr	r5, [r6, #84]	; 0x54
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 8003bd2:	696b      	ldr	r3, [r5, #20]
  sts &= otgp->GINTMSK;
 8003bd4:	69af      	ldr	r7, [r5, #24]
 8003bd6:	401f      	ands	r7, r3
  otgp->GINTSTS = sts;

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 8003bd8:	f417 5980 	ands.w	r9, r7, #4096	; 0x1000
  stm32_otg_t *otgp = usbp->otg;
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
  sts &= otgp->GINTMSK;
  otgp->GINTSTS = sts;
 8003bdc:	616f      	str	r7, [r5, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 8003bde:	f040 811b 	bne.w	8003e18 <Vector14C+0x258>
    /* Preventing execution of more handlers, the core has been reset.*/
    return;
  }

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
 8003be2:	2f00      	cmp	r7, #0
 8003be4:	f2c0 80f5 	blt.w	8003dd2 <Vector14C+0x212>

    _usb_wakeup(usbp);
  }

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {
 8003be8:	053b      	lsls	r3, r7, #20
 8003bea:	f100 80e2 	bmi.w	8003db2 <Vector14C+0x1f2>
    /* Default suspend action.*/
    _usb_suspend(usbp);
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 8003bee:	04bc      	lsls	r4, r7, #18
 8003bf0:	d50c      	bpl.n	8003c0c <Vector14C+0x4c>
    /* Full or High speed timing selection.*/
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8003bf2:	f8d5 3808 	ldr.w	r3, [r5, #2056]	; 0x808
 8003bf6:	f013 0f06 	tst.w	r3, #6
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8003bfa:	68eb      	ldr	r3, [r5, #12]
 8003bfc:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8003c00:	bf0c      	ite	eq
 8003c02:	f443 5310 	orreq.w	r3, r3, #9216	; 0x2400
                      GUSBCFG_TRDT(TRDT_VALUE_HS);
    }
    else {
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8003c06:	f443 53a0 	orrne.w	r3, r3, #5120	; 0x1400
 8003c0a:	60eb      	str	r3, [r5, #12]
                      GUSBCFG_TRDT(TRDT_VALUE_FS);
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 8003c0c:	0738      	lsls	r0, r7, #28
 8003c0e:	d42e      	bmi.n	8003c6e <Vector14C+0xae>
    _usb_isr_invoke_sof_cb(usbp);
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 8003c10:	02fa      	lsls	r2, r7, #11
 8003c12:	d434      	bmi.n	8003c7e <Vector14C+0xbe>
    otg_isoc_in_failed_handler(usbp);
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 8003c14:	02bb      	lsls	r3, r7, #10
 8003c16:	f100 80a0 	bmi.w	8003d5a <Vector14C+0x19a>
    otg_isoc_out_failed_handler(usbp);
  }

  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
 8003c1a:	06fe      	lsls	r6, r7, #27
 8003c1c:	f100 808a 	bmi.w	8003d34 <Vector14C+0x174>
    osalThreadResumeI(&usbp->wait, MSG_OK);
    osalSysUnlockFromISR();
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 8003c20:	f8d5 4818 	ldr.w	r4, [r5, #2072]	; 0x818
  if (sts & GINTSTS_OEPINT) {
 8003c24:	033d      	lsls	r5, r7, #12
 8003c26:	d50b      	bpl.n	8003c40 <Vector14C+0x80>
    if (src & (1 << 16))
 8003c28:	03e0      	lsls	r0, r4, #15
 8003c2a:	f100 818f 	bmi.w	8003f4c <Vector14C+0x38c>
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
 8003c2e:	03a1      	lsls	r1, r4, #14
 8003c30:	f100 8188 	bmi.w	8003f44 <Vector14C+0x384>
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
 8003c34:	0362      	lsls	r2, r4, #13
 8003c36:	f100 8181 	bmi.w	8003f3c <Vector14C+0x37c>
      otg_epout_handler(usbp, 2);
    if (src & (1 << 19))
 8003c3a:	0323      	lsls	r3, r4, #12
 8003c3c:	f100 816b 	bmi.w	8003f16 <Vector14C+0x356>
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 24))
      otg_epout_handler(usbp, 8);
#endif
  }
  if (sts & GINTSTS_IEPINT) {
 8003c40:	037f      	lsls	r7, r7, #13
 8003c42:	d50b      	bpl.n	8003c5c <Vector14C+0x9c>
    if (src & (1 << 0))
 8003c44:	07e6      	lsls	r6, r4, #31
 8003c46:	f100 8175 	bmi.w	8003f34 <Vector14C+0x374>
      otg_epin_handler(usbp, 0);
    if (src & (1 << 1))
 8003c4a:	07a5      	lsls	r5, r4, #30
 8003c4c:	f100 816e 	bmi.w	8003f2c <Vector14C+0x36c>
      otg_epin_handler(usbp, 1);
    if (src & (1 << 2))
 8003c50:	0760      	lsls	r0, r4, #29
 8003c52:	f100 8167 	bmi.w	8003f24 <Vector14C+0x364>
      otg_epin_handler(usbp, 2);
    if (src & (1 << 3))
 8003c56:	0721      	lsls	r1, r4, #28
 8003c58:	f100 8159 	bmi.w	8003f0e <Vector14C+0x34e>

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
 8003c5c:	f7ff fa18 	bl	8003090 <_dbg_check_leave_isr>
 8003c60:	486b      	ldr	r0, [pc, #428]	; (8003e10 <Vector14C+0x250>)
 8003c62:	f7fe ff6d 	bl	8002b40 <_trace_isr_leave>
}
 8003c66:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
 8003c6a:	f7fd bd11 	b.w	8001690 <_port_irq_epilogue>
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
    _usb_isr_invoke_sof_cb(usbp);
 8003c6e:	6873      	ldr	r3, [r6, #4]
 8003c70:	68db      	ldr	r3, [r3, #12]
 8003c72:	2b00      	cmp	r3, #0
 8003c74:	d0cc      	beq.n	8003c10 <Vector14C+0x50>
 8003c76:	4865      	ldr	r0, [pc, #404]	; (8003e0c <Vector14C+0x24c>)
 8003c78:	4798      	blx	r3
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 8003c7a:	02fa      	lsls	r2, r7, #11
 8003c7c:	d5ca      	bpl.n	8003c14 <Vector14C+0x54>
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8003c7e:	f8d6 8054 	ldr.w	r8, [r6, #84]	; 0x54
 8003c82:	2400      	movs	r4, #0
 8003c84:	e008      	b.n	8003c98 <Vector14C+0xd8>

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8003c86:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8003c88:	4a60      	ldr	r2, [pc, #384]	; (8003e0c <Vector14C+0x24c>)
 8003c8a:	689b      	ldr	r3, [r3, #8]
 8003c8c:	3401      	adds	r4, #1
 8003c8e:	b2e4      	uxtb	r4, r4
 8003c90:	429c      	cmp	r4, r3
 8003c92:	46a1      	mov	r9, r4
 8003c94:	f200 8161 	bhi.w	8003f5a <Vector14C+0x39a>
 8003c98:	eb08 1244 	add.w	r2, r8, r4, lsl #5
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8003c9c:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 8003ca0:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8003ca4:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8003ca8:	d1ed      	bne.n	8003c86 <Vector14C+0xc6>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 8003caa:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8003cae:	2b00      	cmp	r3, #0
 8003cb0:	dae9      	bge.n	8003c86 <Vector14C+0xc6>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
      /* Endpoint enabled -> ISOC IN transfer failed */
      /* Disable endpoint */
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 8003cb2:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 8003cb6:	f043 4390 	orr.w	r3, r3, #1207959552	; 0x48000000
 8003cba:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 8003cbe:	f8d2 3900 	ldr.w	r3, [r2, #2304]	; 0x900
 8003cc2:	2b00      	cmp	r3, #0
 8003cc4:	dbfb      	blt.n	8003cbe <Vector14C+0xfe>
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8003cc6:	ea4f 1989 	mov.w	r9, r9, lsl #6
 8003cca:	6d72      	ldr	r2, [r6, #84]	; 0x54
 8003ccc:	f049 0320 	orr.w	r3, r9, #32
 8003cd0:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8003cd2:	6913      	ldr	r3, [r2, #16]
 8003cd4:	0699      	lsls	r1, r3, #26
 8003cd6:	d4fc      	bmi.n	8003cd2 <Vector14C+0x112>
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
 8003cd8:	2012      	movs	r0, #18
 8003cda:	f7fe ff91 	bl	8002c00 <chSysPolledDelayX>

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 8003cde:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 8003ce2:	f04f 0901 	mov.w	r9, #1
 8003ce6:	68da      	ldr	r2, [r3, #12]
 8003ce8:	8933      	ldrh	r3, [r6, #8]
 8003cea:	6892      	ldr	r2, [r2, #8]
 8003cec:	fa09 f904 	lsl.w	r9, r9, r4
 8003cf0:	ea6f 0a09 	mvn.w	sl, r9
 8003cf4:	ea0a 0303 	and.w	r3, sl, r3
 8003cf8:	8133      	strh	r3, [r6, #8]
 8003cfa:	b112      	cbz	r2, 8003d02 <Vector14C+0x142>
 8003cfc:	4843      	ldr	r0, [pc, #268]	; (8003e0c <Vector14C+0x24c>)
 8003cfe:	4621      	mov	r1, r4
 8003d00:	4790      	blx	r2
 8003d02:	2320      	movs	r3, #32
 8003d04:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8003d08:	f7ff fa0a 	bl	8003120 <_dbg_check_lock_from_isr>

      /* Pump out data for next frame */
      osalSysLockFromISR();
      otgp->DIEPEMPMSK &= ~(1 << ep);
 8003d0c:	f8d8 2834 	ldr.w	r2, [r8, #2100]	; 0x834
      usbp->txpending |= (1 << ep);
 8003d10:	6e33      	ldr	r3, [r6, #96]	; 0x60
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 8003d12:	4840      	ldr	r0, [pc, #256]	; (8003e14 <Vector14C+0x254>)
      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);

      /* Pump out data for next frame */
      osalSysLockFromISR();
      otgp->DIEPEMPMSK &= ~(1 << ep);
 8003d14:	ea0a 0202 	and.w	r2, sl, r2
      usbp->txpending |= (1 << ep);
 8003d18:	ea49 0303 	orr.w	r3, r9, r3
      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);

      /* Pump out data for next frame */
      osalSysLockFromISR();
      otgp->DIEPEMPMSK &= ~(1 << ep);
 8003d1c:	f8c8 2834 	str.w	r2, [r8, #2100]	; 0x834
 8003d20:	2100      	movs	r1, #0
      usbp->txpending |= (1 << ep);
 8003d22:	6633      	str	r3, [r6, #96]	; 0x60
 8003d24:	f7ff f99c 	bl	8003060 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8003d28:	f7ff f9e2 	bl	80030f0 <_dbg_check_unlock_from_isr>
 8003d2c:	2300      	movs	r3, #0
 8003d2e:	f383 8811 	msr	BASEPRI, r3
 8003d32:	e7a8      	b.n	8003c86 <Vector14C+0xc6>
 8003d34:	2320      	movs	r3, #32
 8003d36:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8003d3a:	f7ff f9f1 	bl	8003120 <_dbg_check_lock_from_isr>
  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
    /* The interrupt is masked while the thread has control or it would
       be triggered again.*/
    osalSysLockFromISR();
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 8003d3e:	69ab      	ldr	r3, [r5, #24]
 8003d40:	4834      	ldr	r0, [pc, #208]	; (8003e14 <Vector14C+0x254>)
 8003d42:	f023 0310 	bic.w	r3, r3, #16
 8003d46:	61ab      	str	r3, [r5, #24]
 8003d48:	2100      	movs	r1, #0
 8003d4a:	f7ff f989 	bl	8003060 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8003d4e:	f7ff f9cf 	bl	80030f0 <_dbg_check_unlock_from_isr>
 8003d52:	2300      	movs	r3, #0
 8003d54:	f383 8811 	msr	BASEPRI, r3
 8003d58:	e762      	b.n	8003c20 <Vector14C+0x60>
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8003d5a:	f8d6 8054 	ldr.w	r8, [r6, #84]	; 0x54
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8003d5e:	2400      	movs	r4, #0
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 8003d60:	f04f 0901 	mov.w	r9, #1
 8003d64:	e006      	b.n	8003d74 <Vector14C+0x1b4>
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8003d66:	6db3      	ldr	r3, [r6, #88]	; 0x58
 8003d68:	3401      	adds	r4, #1
 8003d6a:	689b      	ldr	r3, [r3, #8]
 8003d6c:	b2e4      	uxtb	r4, r4
 8003d6e:	429c      	cmp	r4, r3
 8003d70:	f63f af53 	bhi.w	8003c1a <Vector14C+0x5a>
 8003d74:	eb08 1244 	add.w	r2, r8, r4, lsl #5
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8003d78:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8003d7c:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8003d80:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8003d84:	d1ef      	bne.n	8003d66 <Vector14C+0x1a6>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 8003d86:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8003d8a:	2b00      	cmp	r3, #0
 8003d8c:	daeb      	bge.n	8003d66 <Vector14C+0x1a6>
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 8003d8e:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 8003d92:	8972      	ldrh	r2, [r6, #10]
 8003d94:	68d9      	ldr	r1, [r3, #12]
 8003d96:	fa09 f304 	lsl.w	r3, r9, r4
 8003d9a:	f8d1 c00c 	ldr.w	ip, [r1, #12]
 8003d9e:	ea22 0303 	bic.w	r3, r2, r3
 8003da2:	8173      	strh	r3, [r6, #10]
 8003da4:	f1bc 0f00 	cmp.w	ip, #0
 8003da8:	d0dd      	beq.n	8003d66 <Vector14C+0x1a6>
 8003daa:	4818      	ldr	r0, [pc, #96]	; (8003e0c <Vector14C+0x24c>)
 8003dac:	4621      	mov	r1, r4
 8003dae:	47e0      	blx	ip
 8003db0:	e7d9      	b.n	8003d66 <Vector14C+0x1a6>
  /* State transition.*/
  usbp->saved_state = usbp->state;
  usbp->state       = USB_SUSPENDED;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8003db2:	6873      	ldr	r3, [r6, #4]
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 8003db4:	7832      	ldrb	r2, [r6, #0]
  usbp->state       = USB_SUSPENDED;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8003db6:	681b      	ldr	r3, [r3, #0]
 */
void _usb_suspend(USBDriver *usbp) {
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 8003db8:	f886 2050 	strb.w	r2, [r6, #80]	; 0x50

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 8003dbc:	2100      	movs	r1, #0
  usbp->state       = USB_SUSPENDED;
 8003dbe:	2205      	movs	r2, #5
 8003dc0:	6631      	str	r1, [r6, #96]	; 0x60
 8003dc2:	7032      	strb	r2, [r6, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8003dc4:	2b00      	cmp	r3, #0
 8003dc6:	f43f af12 	beq.w	8003bee <Vector14C+0x2e>
 8003dca:	4810      	ldr	r0, [pc, #64]	; (8003e0c <Vector14C+0x24c>)
 8003dcc:	2104      	movs	r1, #4
 8003dce:	4798      	blx	r3
 8003dd0:	e70d      	b.n	8003bee <Vector14C+0x2e>

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
    /* If clocks are gated off, turn them back on (may be the case if
       coming out of suspend mode).*/
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8003dd2:	f8d5 3e00 	ldr.w	r3, [r5, #3584]	; 0xe00
 8003dd6:	079a      	lsls	r2, r3, #30
 8003dd8:	d005      	beq.n	8003de6 <Vector14C+0x226>
      /* Set to zero to un-gate the USB core clocks.*/
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 8003dda:	f8d5 3e00 	ldr.w	r3, [r5, #3584]	; 0xe00
 8003dde:	f023 0303 	bic.w	r3, r3, #3
 8003de2:	f8c5 3e00 	str.w	r3, [r5, #3584]	; 0xe00

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8003de6:	6872      	ldr	r2, [r6, #4]
    }

    /* Clear the Remote Wake-up Signaling.*/
    otgp->DCTL |= DCTL_RWUSIG;
 8003de8:	f8d5 3804 	ldr.w	r3, [r5, #2052]	; 0x804
 8003dec:	6812      	ldr	r2, [r2, #0]
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 8003dee:	f896 1050 	ldrb.w	r1, [r6, #80]	; 0x50
 8003df2:	7031      	strb	r1, [r6, #0]
 8003df4:	f043 0301 	orr.w	r3, r3, #1
 8003df8:	f8c5 3804 	str.w	r3, [r5, #2052]	; 0x804

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8003dfc:	2a00      	cmp	r2, #0
 8003dfe:	f43f aef3 	beq.w	8003be8 <Vector14C+0x28>
 8003e02:	4802      	ldr	r0, [pc, #8]	; (8003e0c <Vector14C+0x24c>)
 8003e04:	2105      	movs	r1, #5
 8003e06:	4790      	blx	r2
 8003e08:	e6ee      	b.n	8003be8 <Vector14C+0x28>
 8003e0a:	bf00      	nop
 8003e0c:	200010e0 	.word	0x200010e0
 8003e10:	080052a4 	.word	0x080052a4
 8003e14:	20001144 	.word	0x20001144

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 8003e18:	2300      	movs	r3, #0
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8003e1a:	2102      	movs	r1, #2
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8003e1c:	2220      	movs	r2, #32

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 8003e1e:	6633      	str	r3, [r6, #96]	; 0x60

  /* Resetting internal state.*/
  usbp->status        = 0;
 8003e20:	f8a6 304c 	strh.w	r3, [r6, #76]	; 0x4c
  usbp->address       = 0;
 8003e24:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
  usbp->configuration = 0;
 8003e28:	f886 304f 	strb.w	r3, [r6, #79]	; 0x4f
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8003e2c:	60f3      	str	r3, [r6, #12]
 8003e2e:	6133      	str	r3, [r6, #16]
 8003e30:	6173      	str	r3, [r6, #20]
 8003e32:	61b3      	str	r3, [r6, #24]
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8003e34:	f886 3034 	strb.w	r3, [r6, #52]	; 0x34

  /* Resetting internal state.*/
  usbp->status        = 0;
  usbp->address       = 0;
  usbp->configuration = 0;
  usbp->transmitting  = 0;
 8003e38:	8133      	strh	r3, [r6, #8]
  usbp->receiving     = 0;
 8003e3a:	8173      	strh	r3, [r6, #10]
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8003e3c:	7031      	strb	r1, [r6, #0]
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8003e3e:	612a      	str	r2, [r5, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8003e40:	692b      	ldr	r3, [r5, #16]
 8003e42:	f013 0420 	ands.w	r4, r3, #32
 8003e46:	d1fb      	bne.n	8003e40 <Vector14C+0x280>
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
 8003e48:	2012      	movs	r0, #18
 8003e4a:	f7fe fed9 	bl	8002c00 <chSysPolledDelayX>
 8003e4e:	f8d6 e058 	ldr.w	lr, [r6, #88]	; 0x58

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
 8003e52:	f8c5 4834 	str.w	r4, [r5, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8003e56:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8003e5a:	f8de 7008 	ldr.w	r7, [lr, #8]
 8003e5e:	f8c5 281c 	str.w	r2, [r5, #2076]	; 0x81c

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003e62:	4623      	mov	r3, r4
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8003e64:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8003e68:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8003e6c:	eb05 1243 	add.w	r2, r5, r3, lsl #5
  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003e70:	3301      	adds	r3, #1
 8003e72:	42bb      	cmp	r3, r7
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8003e74:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 8003e78:	f8c2 0b00 	str.w	r0, [r2, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8003e7c:	f8c2 1908 	str.w	r1, [r2, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8003e80:	f8c2 1b08 	str.w	r1, [r2, #2824]	; 0xb08
  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003e84:	d9f2      	bls.n	8003e6c <Vector14C+0x2ac>
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8003e86:	f8de 3000 	ldr.w	r3, [lr]
 8003e8a:	65f3      	str	r3, [r6, #92]	; 0x5c

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8003e8c:	f8de 2000 	ldr.w	r2, [lr]
 8003e90:	6d73      	ldr	r3, [r6, #84]	; 0x54
 8003e92:	626a      	str	r2, [r5, #36]	; 0x24
}

static void otg_rxfifo_flush(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8003e94:	2210      	movs	r2, #16
 8003e96:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 8003e98:	6919      	ldr	r1, [r3, #16]
 8003e9a:	f011 0410 	ands.w	r4, r1, #16
 8003e9e:	d1fb      	bne.n	8003e98 <Vector14C+0x2d8>
 8003ea0:	2012      	movs	r0, #18
 8003ea2:	f7fe fead 	bl	8002c00 <chSysPolledDelayX>
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8003ea6:	f8d5 3800 	ldr.w	r3, [r5, #2048]	; 0x800
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 8003eaa:	6df2      	ldr	r2, [r6, #92]	; 0x5c
 8003eac:	f8d6 e058 	ldr.w	lr, [r6, #88]	; 0x58
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8003eb0:	4f2d      	ldr	r7, [pc, #180]	; (8003f68 <Vector14C+0x3a8>)
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8003eb2:	f8df c0c0 	ldr.w	ip, [pc, #192]	; 8003f74 <Vector14C+0x3b4>
 8003eb6:	482d      	ldr	r0, [pc, #180]	; (8003f6c <Vector14C+0x3ac>)
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8003eb8:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8003ebc:	f8c5 3800 	str.w	r3, [r5, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8003ec0:	69ab      	ldr	r3, [r5, #24]
 8003ec2:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8003ec6:	f043 0310 	orr.w	r3, r3, #16
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 8003eca:	f102 0110 	add.w	r1, r2, #16

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8003ece:	61ab      	str	r3, [r5, #24]
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 8003ed0:	65f1      	str	r1, [r6, #92]	; 0x5c
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8003ed2:	f8de e004 	ldr.w	lr, [lr, #4]
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8003ed6:	f8c6 c00c 	str.w	ip, [r6, #12]
  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8003eda:	2309      	movs	r3, #9
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8003edc:	4571      	cmp	r1, lr
  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8003ede:	f8c5 3810 	str.w	r3, [r5, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8003ee2:	f8c5 3814 	str.w	r3, [r5, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
 8003ee6:	f8c5 4b10 	str.w	r4, [r5, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8003eea:	f8c5 7b00 	str.w	r7, [r5, #2816]	; 0xb00
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
 8003eee:	f8c5 4910 	str.w	r4, [r5, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 8003ef2:	f8c5 7900 	str.w	r7, [r5, #2304]	; 0x900
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8003ef6:	d82d      	bhi.n	8003f54 <Vector14C+0x394>

  /* Low level reset.*/
  usb_lld_reset(usbp);

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8003ef8:	6843      	ldr	r3, [r0, #4]
 8003efa:	681b      	ldr	r3, [r3, #0]
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8003efc:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8003f00:	62aa      	str	r2, [r5, #40]	; 0x28
 8003f02:	2b00      	cmp	r3, #0
 8003f04:	f43f aeaa 	beq.w	8003c5c <Vector14C+0x9c>
 8003f08:	4621      	mov	r1, r4
 8003f0a:	4798      	blx	r3
 8003f0c:	e6a6      	b.n	8003c5c <Vector14C+0x9c>
    if (src & (1 << 1))
      otg_epin_handler(usbp, 1);
    if (src & (1 << 2))
      otg_epin_handler(usbp, 2);
    if (src & (1 << 3))
      otg_epin_handler(usbp, 3);
 8003f0e:	2003      	movs	r0, #3
 8003f10:	f000 fc0e 	bl	8004730 <otg_epin_handler.constprop.6>
 8003f14:	e6a2      	b.n	8003c5c <Vector14C+0x9c>
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
      otg_epout_handler(usbp, 2);
    if (src & (1 << 19))
      otg_epout_handler(usbp, 3);
 8003f16:	2003      	movs	r0, #3
 8003f18:	f000 fba2 	bl	8004660 <otg_epout_handler.constprop.7>
#if USB_MAX_ENDPOINTS >= 8
    if (src & (1 << 24))
      otg_epout_handler(usbp, 8);
#endif
  }
  if (sts & GINTSTS_IEPINT) {
 8003f1c:	037f      	lsls	r7, r7, #13
 8003f1e:	f57f ae9d 	bpl.w	8003c5c <Vector14C+0x9c>
 8003f22:	e68f      	b.n	8003c44 <Vector14C+0x84>
    if (src & (1 << 0))
      otg_epin_handler(usbp, 0);
    if (src & (1 << 1))
      otg_epin_handler(usbp, 1);
    if (src & (1 << 2))
      otg_epin_handler(usbp, 2);
 8003f24:	2002      	movs	r0, #2
 8003f26:	f000 fc03 	bl	8004730 <otg_epin_handler.constprop.6>
 8003f2a:	e694      	b.n	8003c56 <Vector14C+0x96>
  }
  if (sts & GINTSTS_IEPINT) {
    if (src & (1 << 0))
      otg_epin_handler(usbp, 0);
    if (src & (1 << 1))
      otg_epin_handler(usbp, 1);
 8003f2c:	2001      	movs	r0, #1
 8003f2e:	f000 fbff 	bl	8004730 <otg_epin_handler.constprop.6>
 8003f32:	e68d      	b.n	8003c50 <Vector14C+0x90>
      otg_epout_handler(usbp, 8);
#endif
  }
  if (sts & GINTSTS_IEPINT) {
    if (src & (1 << 0))
      otg_epin_handler(usbp, 0);
 8003f34:	2000      	movs	r0, #0
 8003f36:	f000 fbfb 	bl	8004730 <otg_epin_handler.constprop.6>
 8003f3a:	e686      	b.n	8003c4a <Vector14C+0x8a>
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
      otg_epout_handler(usbp, 2);
 8003f3c:	2002      	movs	r0, #2
 8003f3e:	f000 fb8f 	bl	8004660 <otg_epout_handler.constprop.7>
 8003f42:	e67a      	b.n	8003c3a <Vector14C+0x7a>
  src = otgp->DAINT;
  if (sts & GINTSTS_OEPINT) {
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
 8003f44:	2001      	movs	r0, #1
 8003f46:	f000 fb8b 	bl	8004660 <otg_epout_handler.constprop.7>
 8003f4a:	e673      	b.n	8003c34 <Vector14C+0x74>

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
  if (sts & GINTSTS_OEPINT) {
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
 8003f4c:	2000      	movs	r0, #0
 8003f4e:	f000 fb87 	bl	8004660 <otg_epout_handler.constprop.7>
 8003f52:	e66c      	b.n	8003c2e <Vector14C+0x6e>
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
 8003f54:	4806      	ldr	r0, [pc, #24]	; (8003f70 <Vector14C+0x3b0>)
 8003f56:	f7fe fe63 	bl	8002c20 <chSysHalt>
  if (sts & GINTSTS_IISOIXFR) {
    otg_isoc_in_failed_handler(usbp);
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 8003f5a:	02bb      	lsls	r3, r7, #10
 8003f5c:	f57f ae5d 	bpl.w	8003c1a <Vector14C+0x5a>
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8003f60:	f8d2 8054 	ldr.w	r8, [r2, #84]	; 0x54
 8003f64:	e6fb      	b.n	8003d5e <Vector14C+0x19e>
 8003f66:	bf00      	nop
 8003f68:	10008040 	.word	0x10008040
 8003f6c:	200010e0 	.word	0x200010e0
 8003f70:	080052f4 	.word	0x080052f4
 8003f74:	080052b0 	.word	0x080052b0
	...

08003f80 <__early_init>:
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8003f80:	4934      	ldr	r1, [pc, #208]	; (8004054 <__early_init+0xd4>)
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8003f82:	4b35      	ldr	r3, [pc, #212]	; (8004058 <__early_init+0xd8>)
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8003f84:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8003f88:	f44f 4240 	mov.w	r2, #49152	; 0xc000
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8003f8c:	6408      	str	r0, [r1, #64]	; 0x40
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8003f8e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8003f90:	680b      	ldr	r3, [r1, #0]
 8003f92:	f043 0301 	orr.w	r3, r3, #1
 8003f96:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8003f98:	680a      	ldr	r2, [r1, #0]
 8003f9a:	4b2e      	ldr	r3, [pc, #184]	; (8004054 <__early_init+0xd4>)
 8003f9c:	0790      	lsls	r0, r2, #30
 8003f9e:	d5fb      	bpl.n	8003f98 <__early_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8003fa0:	689a      	ldr	r2, [r3, #8]
 8003fa2:	f022 0203 	bic.w	r2, r2, #3
 8003fa6:	609a      	str	r2, [r3, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8003fa8:	689a      	ldr	r2, [r3, #8]
 8003faa:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8003fac:	4619      	mov	r1, r3
 8003fae:	688b      	ldr	r3, [r1, #8]
 8003fb0:	4a28      	ldr	r2, [pc, #160]	; (8004054 <__early_init+0xd4>)
 8003fb2:	f013 030c 	ands.w	r3, r3, #12
 8003fb6:	d1fa      	bne.n	8003fae <__early_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8003fb8:	6811      	ldr	r1, [r2, #0]
 8003fba:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 8003fbe:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8003fc0:	6093      	str	r3, [r2, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8003fc2:	6813      	ldr	r3, [r2, #0]
 8003fc4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003fc8:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8003fca:	6811      	ldr	r1, [r2, #0]
 8003fcc:	4b21      	ldr	r3, [pc, #132]	; (8004054 <__early_init+0xd4>)
 8003fce:	0389      	lsls	r1, r1, #14
 8003fd0:	d5fb      	bpl.n	8003fca <__early_init+0x4a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8003fd2:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8003fd4:	f042 0201 	orr.w	r2, r2, #1
 8003fd8:	675a      	str	r2, [r3, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8003fda:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8003fdc:	491d      	ldr	r1, [pc, #116]	; (8004054 <__early_init+0xd4>)
 8003fde:	0790      	lsls	r0, r2, #30
 8003fe0:	d5fb      	bpl.n	8003fda <__early_init+0x5a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8003fe2:	4b1e      	ldr	r3, [pc, #120]	; (800405c <__early_init+0xdc>)
 8003fe4:	604b      	str	r3, [r1, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8003fe6:	680b      	ldr	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8003fe8:	4a1b      	ldr	r2, [pc, #108]	; (8004058 <__early_init+0xd8>)

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8003fea:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8003fee:	600b      	str	r3, [r1, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8003ff0:	6853      	ldr	r3, [r2, #4]
 8003ff2:	0459      	lsls	r1, r3, #17
 8003ff4:	d5fc      	bpl.n	8003ff0 <__early_init+0x70>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8003ff6:	4917      	ldr	r1, [pc, #92]	; (8004054 <__early_init+0xd4>)
 8003ff8:	680b      	ldr	r3, [r1, #0]
 8003ffa:	4a16      	ldr	r2, [pc, #88]	; (8004054 <__early_init+0xd4>)
 8003ffc:	019b      	lsls	r3, r3, #6
 8003ffe:	d5fb      	bpl.n	8003ff8 <__early_init+0x78>

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8004000:	4b17      	ldr	r3, [pc, #92]	; (8004060 <__early_init+0xe0>)
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8004002:	4918      	ldr	r1, [pc, #96]	; (8004064 <__early_init+0xe4>)
 8004004:	6091      	str	r1, [r2, #8]

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 8004006:	681a      	ldr	r2, [r3, #0]
 8004008:	4b17      	ldr	r3, [pc, #92]	; (8004068 <__early_init+0xe8>)
 800400a:	429a      	cmp	r2, r3
 800400c:	d017      	beq.n	800403e <__early_init+0xbe>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 800400e:	4b17      	ldr	r3, [pc, #92]	; (800406c <__early_init+0xec>)
 8004010:	f240 7205 	movw	r2, #1797	; 0x705
 8004014:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8004016:	4a0f      	ldr	r2, [pc, #60]	; (8004054 <__early_init+0xd4>)
 8004018:	6893      	ldr	r3, [r2, #8]
 800401a:	f043 0302 	orr.w	r3, r3, #2
 800401e:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8004020:	6893      	ldr	r3, [r2, #8]
 8004022:	490c      	ldr	r1, [pc, #48]	; (8004054 <__early_init+0xd4>)
 8004024:	f003 030c 	and.w	r3, r3, #12
 8004028:	2b08      	cmp	r3, #8
 800402a:	d1f9      	bne.n	8004020 <__early_init+0xa0>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 800402c:	6c4b      	ldr	r3, [r1, #68]	; 0x44
 800402e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8004032:	644b      	str	r3, [r1, #68]	; 0x44
 8004034:	6e4b      	ldr	r3, [r1, #100]	; 0x64
 8004036:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800403a:	664b      	str	r3, [r1, #100]	; 0x64
 800403c:	4770      	bx	lr

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 800403e:	4a0c      	ldr	r2, [pc, #48]	; (8004070 <__early_init+0xf0>)
 8004040:	4b0c      	ldr	r3, [pc, #48]	; (8004074 <__early_init+0xf4>)
 8004042:	6812      	ldr	r2, [r2, #0]
 8004044:	429a      	cmp	r2, r3
 8004046:	d1e2      	bne.n	800400e <__early_init+0x8e>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 8004048:	4b08      	ldr	r3, [pc, #32]	; (800406c <__early_init+0xec>)
 800404a:	f240 1205 	movw	r2, #261	; 0x105
 800404e:	601a      	str	r2, [r3, #0]
 8004050:	e7e1      	b.n	8004016 <__early_init+0x96>
 8004052:	bf00      	nop
 8004054:	40023800 	.word	0x40023800
 8004058:	40007000 	.word	0x40007000
 800405c:	07405408 	.word	0x07405408
 8004060:	e0042000 	.word	0xe0042000
 8004064:	38889400 	.word	0x38889400
 8004068:	20006411 	.word	0x20006411
 800406c:	40023c00 	.word	0x40023c00
 8004070:	e000ed00 	.word	0xe000ed00
 8004074:	410fc241 	.word	0x410fc241
	...

08004080 <usb_lld_start_in>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8004080:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8004084:	b4f0      	push	{r4, r5, r6, r7}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8004086:	68dc      	ldr	r4, [r3, #12]
 8004088:	6965      	ldr	r5, [r4, #20]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 800408a:	682b      	ldr	r3, [r5, #0]
 800408c:	60eb      	str	r3, [r5, #12]
  if (isp->txsize == 0) {
 800408e:	b9f3      	cbnz	r3, 80040ce <usb_lld_start_in+0x4e>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 8004090:	6d40      	ldr	r0, [r0, #84]	; 0x54
 8004092:	eb00 1341 	add.w	r3, r0, r1, lsl #5
 8004096:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800409a:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800409e:	6823      	ldr	r3, [r4, #0]
 80040a0:	f003 0303 	and.w	r3, r3, #3
 80040a4:	2b01      	cmp	r3, #1
 80040a6:	d026      	beq.n	80040f6 <usb_lld_start_in+0x76>
 80040a8:	b20b      	sxth	r3, r1
 80040aa:	eb00 1343 	add.w	r3, r0, r3, lsl #5
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80040ae:	2401      	movs	r4, #1
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80040b0:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 80040b4:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 80040b8:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80040bc:	f8d0 2834 	ldr.w	r2, [r0, #2100]	; 0x834
 80040c0:	fa04 f301 	lsl.w	r3, r4, r1
 80040c4:	4313      	orrs	r3, r2
 80040c6:	f8c0 3834 	str.w	r3, [r0, #2100]	; 0x834
}
 80040ca:	bcf0      	pop	{r4, r5, r6, r7}
 80040cc:	4770      	bx	lr
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 80040ce:	b319      	cbz	r1, 8004118 <usb_lld_start_in+0x98>
 80040d0:	1e5d      	subs	r5, r3, #1
 80040d2:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80040d6:	6d40      	ldr	r0, [r0, #84]	; 0x54
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 80040d8:	8a26      	ldrh	r6, [r4, #16]
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80040da:	eb00 1741 	add.w	r7, r0, r1, lsl #5
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 80040de:	19ab      	adds	r3, r5, r6
 80040e0:	fbb3 f3f6 	udiv	r3, r3, r6
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80040e4:	ea42 43c3 	orr.w	r3, r2, r3, lsl #19
 80040e8:	f8c7 3910 	str.w	r3, [r7, #2320]	; 0x910
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80040ec:	6823      	ldr	r3, [r4, #0]
 80040ee:	f003 0303 	and.w	r3, r3, #3
 80040f2:	2b01      	cmp	r3, #1
 80040f4:	d1d8      	bne.n	80040a8 <usb_lld_start_in+0x28>
    /* Odd/even bit toggling.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80040f6:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 80040fa:	f413 7f80 	tst.w	r3, #256	; 0x100
 80040fe:	b20b      	sxth	r3, r1
 8004100:	eb00 1443 	add.w	r4, r0, r3, lsl #5
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8004104:	f8d4 2900 	ldr.w	r2, [r4, #2304]	; 0x900
 8004108:	bf14      	ite	ne
 800410a:	f042 5280 	orrne.w	r2, r2, #268435456	; 0x10000000
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 800410e:	f042 5200 	orreq.w	r2, r2, #536870912	; 0x20000000
 8004112:	f8c4 2900 	str.w	r2, [r4, #2304]	; 0x900
 8004116:	e7c8      	b.n	80040aa <usb_lld_start_in+0x2a>
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8004118:	2b40      	cmp	r3, #64	; 0x40
 800411a:	d9d9      	bls.n	80040d0 <usb_lld_start_in+0x50>
      isp->txsize = EP0_MAX_INSIZE;
 800411c:	2340      	movs	r3, #64	; 0x40
 800411e:	602b      	str	r3, [r5, #0]
 8004120:	4a01      	ldr	r2, [pc, #4]	; (8004128 <usb_lld_start_in+0xa8>)
 8004122:	253f      	movs	r5, #63	; 0x3f
 8004124:	e7d7      	b.n	80040d6 <usb_lld_start_in+0x56>
 8004126:	bf00      	nop
 8004128:	20000040 	.word	0x20000040
 800412c:	00000000 	.word	0x00000000

08004130 <usb_lld_start_out>:
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8004130:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 8004134:	b430      	push	{r4, r5}
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8004136:	68dc      	ldr	r4, [r3, #12]
 8004138:	69a2      	ldr	r2, [r4, #24]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 800413a:	6813      	ldr	r3, [r2, #0]
 800413c:	60d3      	str	r3, [r2, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 800413e:	b909      	cbnz	r1, 8004144 <usb_lld_start_out+0x14>
 8004140:	2b40      	cmp	r3, #64	; 0x40
 8004142:	d822      	bhi.n	800418a <usb_lld_start_out+0x5a>
 8004144:	3b01      	subs	r3, #1
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8004146:	8a62      	ldrh	r2, [r4, #18]
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8004148:	6d40      	ldr	r0, [r0, #84]	; 0x54
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800414a:	6824      	ldr	r4, [r4, #0]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 800414c:	4413      	add	r3, r2
 800414e:	fbb3 f3f2 	udiv	r3, r3, r2
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 8004152:	fb02 f203 	mul.w	r2, r2, r3
 8004156:	3203      	adds	r2, #3

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8004158:	04db      	lsls	r3, r3, #19
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 800415a:	f022 0203 	bic.w	r2, r2, #3
 800415e:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8004162:	4313      	orrs	r3, r2
 8004164:	eb00 1541 	add.w	r5, r0, r1, lsl #5
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8004168:	f004 0203 	and.w	r2, r4, #3
 800416c:	2a01      	cmp	r2, #1
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 800416e:	f8c5 3b10 	str.w	r3, [r5, #2832]	; 0xb10
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8004172:	d00e      	beq.n	8004192 <usb_lld_start_out+0x62>
 8004174:	b209      	sxth	r1, r1
 8004176:	eb00 1141 	add.w	r1, r0, r1, lsl #5
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
}
 800417a:	bc30      	pop	{r4, r5}
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 800417c:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 8004180:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 8004184:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
 8004188:	4770      	bx	lr
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
      osp->rxsize = EP0_MAX_OUTSIZE;
 800418a:	2340      	movs	r3, #64	; 0x40
 800418c:	6013      	str	r3, [r2, #0]
 800418e:	233f      	movs	r3, #63	; 0x3f
 8004190:	e7d9      	b.n	8004146 <usb_lld_start_out+0x16>
 8004192:	b209      	sxth	r1, r1
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
    /* Odd/even bit toggling for isochronous endpoint.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8004194:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 8004198:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 800419c:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 80041a0:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 80041a4:	bf14      	ite	ne
 80041a6:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 80041aa:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
 80041ae:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 80041b2:	e7e0      	b.n	8004176 <usb_lld_start_out+0x46>
	...

080041c0 <usb_lld_pump>:
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 80041c0:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 80041c4:	4604      	mov	r4, r0
 80041c6:	b083      	sub	sp, #12
 80041c8:	2320      	movs	r3, #32
  USBDriver *usbp = (USBDriver *)p;
  stm32_otg_t *otgp = usbp->otg;
 80041ca:	6d45      	ldr	r5, [r0, #84]	; 0x54
 80041cc:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80041d0:	f7ff f81e 	bl	8003210 <_dbg_check_lock>
 80041d4:	f8df 824c 	ldr.w	r8, [pc, #588]	; 8004424 <usb_lld_pump+0x264>
 80041d8:	f04f 0a00 	mov.w	sl, #0
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 80041dc:	7823      	ldrb	r3, [r4, #0]
 80041de:	2b01      	cmp	r3, #1
 80041e0:	d004      	beq.n	80041ec <usb_lld_pump+0x2c>
 80041e2:	6e23      	ldr	r3, [r4, #96]	; 0x60
 80041e4:	b9a3      	cbnz	r3, 8004210 <usb_lld_pump+0x50>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 80041e6:	696b      	ldr	r3, [r5, #20]
 80041e8:	06db      	lsls	r3, r3, #27
 80041ea:	d411      	bmi.n	8004210 <usb_lld_pump+0x50>
      otgp->GINTMSK |= GINTMSK_RXFLVLM;
 80041ec:	69ab      	ldr	r3, [r5, #24]
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");
 80041ee:	6e61      	ldr	r1, [r4, #100]	; 0x64
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80041f0:	f8d8 2018 	ldr.w	r2, [r8, #24]
 80041f4:	f043 0310 	orr.w	r3, r3, #16
 80041f8:	61ab      	str	r3, [r5, #24]
 80041fa:	b111      	cbz	r1, 8004202 <usb_lld_pump+0x42>
 80041fc:	4888      	ldr	r0, [pc, #544]	; (8004420 <usb_lld_pump+0x260>)
 80041fe:	f7fe fd0f 	bl	8002c20 <chSysHalt>

  *trp = tp;
 8004202:	4623      	mov	r3, r4
  tp->u.wttrp = trp;
  chSchGoSleepS(CH_STATE_SUSPENDED);
 8004204:	2003      	movs	r0, #3
msg_t chThdSuspendS(thread_reference_t *trp) {
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 8004206:	f843 2f64 	str.w	r2, [r3, #100]!
  tp->u.wttrp = trp;
 800420a:	6253      	str	r3, [r2, #36]	; 0x24
  chSchGoSleepS(CH_STATE_SUSPENDED);
 800420c:	f7fe fd38 	bl	8002c80 <chSchGoSleepS>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004210:	f7fe ffd6 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004214:	f8d8 3000 	ldr.w	r3, [r8]
 8004218:	4a82      	ldr	r2, [pc, #520]	; (8004424 <usb_lld_pump+0x264>)
 800421a:	4543      	cmp	r3, r8
 800421c:	d004      	beq.n	8004228 <usb_lld_pump+0x68>
 800421e:	6992      	ldr	r2, [r2, #24]
 8004220:	689b      	ldr	r3, [r3, #8]
 8004222:	6892      	ldr	r2, [r2, #8]
 8004224:	429a      	cmp	r2, r3
 8004226:	d369      	bcc.n	80042fc <usb_lld_pump+0x13c>
 8004228:	f38a 8811 	msr	BASEPRI, sl
 800422c:	2600      	movs	r6, #0

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 800422e:	696b      	ldr	r3, [r5, #20]
 8004230:	06db      	lsls	r3, r3, #27
 8004232:	d550      	bpl.n	80042d6 <usb_lld_pump+0x116>
 * @notapi
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
 8004234:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8004236:	6a1a      	ldr	r2, [r3, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8004238:	f402 11f0 	and.w	r1, r2, #1966080	; 0x1e0000
 800423c:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
 8004240:	d01e      	beq.n	8004280 <usb_lld_pump+0xc0>
 8004242:	f5b1 2f40 	cmp.w	r1, #786432	; 0xc0000
 8004246:	d1f2      	bne.n	800422e <usb_lld_pump+0x6e>
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8004248:	f002 010f 	and.w	r1, r2, #15
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 800424c:	eb04 0181 	add.w	r1, r4, r1, lsl #2
  sts = usbp->otg->GRXSTSP;
  switch (sts & GRXSTSP_PKTSTS_MASK) {
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8004250:	f3c2 120a 	ubfx	r2, r2, #4, #11
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8004254:	68c9      	ldr	r1, [r1, #12]
 8004256:	6a0f      	ldr	r7, [r1, #32]
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 8004258:	2a00      	cmp	r2, #0
 800425a:	d0e8      	beq.n	800422e <usb_lld_pump+0x6e>
 800425c:	2100      	movs	r1, #0
    if ((i & 3) == 0){
      w = *fifop;
 800425e:	f503 5080 	add.w	r0, r3, #4096	; 0x1000
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 8004262:	460b      	mov	r3, r1
 8004264:	e002      	b.n	800426c <usb_lld_pump+0xac>
    }
    if (i < max) {
      *buf++ = (uint8_t)w;
      w >>= 8;
    }
    i++;
 8004266:	3301      	adds	r3, #1
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 8004268:	4293      	cmp	r3, r2
 800426a:	d0e0      	beq.n	800422e <usb_lld_pump+0x6e>
    if ((i & 3) == 0){
 800426c:	f013 0f03 	tst.w	r3, #3
      w = *fifop;
 8004270:	bf08      	it	eq
 8004272:	6801      	ldreq	r1, [r0, #0]
    }
    if (i < max) {
 8004274:	2b07      	cmp	r3, #7
 8004276:	d8f6      	bhi.n	8004266 <usb_lld_pump+0xa6>
      *buf++ = (uint8_t)w;
 8004278:	7039      	strb	r1, [r7, #0]
      w >>= 8;
 800427a:	0a09      	lsrs	r1, r1, #8
  while (i < n) {
    if ((i & 3) == 0){
      w = *fifop;
    }
    if (i < max) {
      *buf++ = (uint8_t)w;
 800427c:	3701      	adds	r7, #1
 800427e:	e7f2      	b.n	8004266 <usb_lld_pump+0xa6>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8004280:	f002 0e0f 	and.w	lr, r2, #15
 8004284:	eb04 0e8e 	add.w	lr, r4, lr, lsl #2
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8004288:	f3c2 120a 	ubfx	r2, r2, #4, #11
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
                            usbp->epc[ep]->out_state->rxbuf,
 800428c:	f8de 100c 	ldr.w	r1, [lr, #12]
 8004290:	698f      	ldr	r7, [r1, #24]
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8004292:	e897 1003 	ldmia.w	r7, {r0, r1, ip}
 8004296:	ebc1 0900 	rsb	r9, r1, r0
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 800429a:	b36a      	cbz	r2, 80042f8 <usb_lld_pump+0x138>
 800429c:	2100      	movs	r1, #0
    if ((i & 3) == 0){
      w = *fifop;
 800429e:	f503 5780 	add.w	r7, r3, #4096	; 0x1000
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 80042a2:	4660      	mov	r0, ip
 80042a4:	460b      	mov	r3, r1
    if ((i & 3) == 0){
 80042a6:	f013 0f03 	tst.w	r3, #3
      w = *fifop;
 80042aa:	bf08      	it	eq
 80042ac:	6839      	ldreq	r1, [r7, #0]
    }
    if (i < max) {
 80042ae:	4599      	cmp	r9, r3
 80042b0:	d902      	bls.n	80042b8 <usb_lld_pump+0xf8>
      *buf++ = (uint8_t)w;
 80042b2:	7001      	strb	r1, [r0, #0]
      w >>= 8;
 80042b4:	0a09      	lsrs	r1, r1, #8
  while (i < n) {
    if ((i & 3) == 0){
      w = *fifop;
    }
    if (i < max) {
      *buf++ = (uint8_t)w;
 80042b6:	3001      	adds	r0, #1
      w >>= 8;
    }
    i++;
 80042b8:	3301      	adds	r3, #1
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 80042ba:	4293      	cmp	r3, r2
 80042bc:	d1f3      	bne.n	80042a6 <usb_lld_pump+0xe6>
 80042be:	f8de 300c 	ldr.w	r3, [lr, #12]
 80042c2:	699f      	ldr	r7, [r3, #24]
 80042c4:	68b8      	ldr	r0, [r7, #8]
 80042c6:	6879      	ldr	r1, [r7, #4]

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 80042c8:	696b      	ldr	r3, [r5, #20]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
                            usbp->epc[ep]->out_state->rxcnt);
    usbp->epc[ep]->out_state->rxbuf += cnt;
 80042ca:	4410      	add	r0, r2

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 80042cc:	06db      	lsls	r3, r3, #27
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
                            usbp->epc[ep]->out_state->rxcnt);
    usbp->epc[ep]->out_state->rxbuf += cnt;
    usbp->epc[ep]->out_state->rxcnt += cnt;
 80042ce:	440a      	add	r2, r1
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
                            usbp->epc[ep]->out_state->rxcnt);
    usbp->epc[ep]->out_state->rxbuf += cnt;
 80042d0:	60b8      	str	r0, [r7, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 80042d2:	607a      	str	r2, [r7, #4]

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 80042d4:	d4ae      	bmi.n	8004234 <usb_lld_pump+0x74>
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 80042d6:	2701      	movs	r7, #1
      if (usbp->txpending & epmask) {
 80042d8:	6e23      	ldr	r3, [r4, #96]	; 0x60
      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 80042da:	40b7      	lsls	r7, r6
      if (usbp->txpending & epmask) {
 80042dc:	421f      	tst	r7, r3
 80042de:	d110      	bne.n	8004302 <usb_lld_pump+0x142>
      osalThreadSuspendS(&usbp->wait);
    }
    osalSysUnlock();

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80042e0:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80042e2:	3601      	adds	r6, #1
 80042e4:	689b      	ldr	r3, [r3, #8]
 80042e6:	b2f6      	uxtb	r6, r6
 80042e8:	429e      	cmp	r6, r3
 80042ea:	d9a0      	bls.n	800422e <usb_lld_pump+0x6e>
 80042ec:	2320      	movs	r3, #32
 80042ee:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80042f2:	f7fe ff8d 	bl	8003210 <_dbg_check_lock>
 80042f6:	e771      	b.n	80041dc <usb_lld_pump+0x1c>
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 80042f8:	4660      	mov	r0, ip
 80042fa:	e7e5      	b.n	80042c8 <usb_lld_pump+0x108>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80042fc:	484a      	ldr	r0, [pc, #296]	; (8004428 <usb_lld_pump+0x268>)
 80042fe:	f7fe fc8f 	bl	8002c20 <chSysHalt>
 8004302:	2320      	movs	r3, #32
 8004304:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8004308:	f7fe ff82 	bl	8003210 <_dbg_check_lock>
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 800430c:	68aa      	ldr	r2, [r5, #8]
        usbp->txpending &= ~epmask;
 800430e:	6e23      	ldr	r3, [r4, #96]	; 0x60
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8004310:	f022 0201 	bic.w	r2, r2, #1
        usbp->txpending &= ~epmask;
 8004314:	ea23 0307 	bic.w	r3, r3, r7
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8004318:	60aa      	str	r2, [r5, #8]
        usbp->txpending &= ~epmask;
 800431a:	6623      	str	r3, [r4, #96]	; 0x60
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800431c:	f7fe ff50 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004320:	f8d8 3000 	ldr.w	r3, [r8]
 8004324:	4a3f      	ldr	r2, [pc, #252]	; (8004424 <usb_lld_pump+0x264>)
 8004326:	4543      	cmp	r3, r8
 8004328:	d004      	beq.n	8004334 <usb_lld_pump+0x174>
 800432a:	6992      	ldr	r2, [r2, #24]
 800432c:	689b      	ldr	r3, [r3, #8]
 800432e:	6892      	ldr	r2, [r2, #8]
 8004330:	429a      	cmp	r2, r3
 8004332:	d3e3      	bcc.n	80042fc <usb_lld_pump+0x13c>
 8004334:	f38a 8811 	msr	BASEPRI, sl
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 8004338:	eb04 0386 	add.w	r3, r4, r6, lsl #2
 800433c:	68d8      	ldr	r0, [r3, #12]
 800433e:	f8d0 e014 	ldr.w	lr, [r0, #20]
 8004342:	f8de 1004 	ldr.w	r1, [lr, #4]
 8004346:	f8de 3000 	ldr.w	r3, [lr]
 800434a:	428b      	cmp	r3, r1
 800434c:	d941      	bls.n	80043d2 <usb_lld_pump+0x212>
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800434e:	6d62      	ldr	r2, [r4, #84]	; 0x54
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return true;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
    if (n > usbp->epc[ep]->in_maxsize)
 8004350:	f8b0 9010 	ldrh.w	r9, [r0, #16]
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8004354:	eb02 1046 	add.w	r0, r2, r6, lsl #5
    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return true;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8004358:	1a59      	subs	r1, r3, r1
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800435a:	f8d0 3918 	ldr.w	r3, [r0, #2328]	; 0x918
 800435e:	4549      	cmp	r1, r9
 8004360:	bf28      	it	cs
 8004362:	4649      	movcs	r1, r9
 8004364:	b29b      	uxth	r3, r3
 8004366:	ebb1 0f83 	cmp.w	r1, r3, lsl #2
 800436a:	d856      	bhi.n	800441a <usb_lld_pump+0x25a>
      return false;

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 800436c:	f8de c008 	ldr.w	ip, [lr, #8]
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {

  osalDbgAssert(n > 0, "is zero");
 8004370:	b359      	cbz	r1, 80043ca <usb_lld_pump+0x20a>
      return false;

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8004372:	1c73      	adds	r3, r6, #1
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8004374:	9001      	str	r0, [sp, #4]
 8004376:	46a3      	mov	fp, r4
      return false;

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8004378:	eb02 3003 	add.w	r0, r2, r3, lsl #12
 800437c:	4662      	mov	r2, ip
                                       size_t n) {

  osalDbgAssert(n > 0, "is zero");

  while (true) {
    *fifop = *((uint32_t *)buf);
 800437e:	6813      	ldr	r3, [r2, #0]
 8004380:	6003      	str	r3, [r0, #0]
    if (n <= 4) {
 8004382:	2904      	cmp	r1, #4
 8004384:	d907      	bls.n	8004396 <usb_lld_pump+0x1d6>
 8004386:	460b      	mov	r3, r1
 8004388:	4694      	mov	ip, r2
      break;
    }
    n -= 4;
 800438a:	3b04      	subs	r3, #4
                                       size_t n) {

  osalDbgAssert(n > 0, "is zero");

  while (true) {
    *fifop = *((uint32_t *)buf);
 800438c:	f85c 4f04 	ldr.w	r4, [ip, #4]!
 8004390:	6004      	str	r4, [r0, #0]
    if (n <= 4) {
 8004392:	2b04      	cmp	r3, #4
 8004394:	d8f9      	bhi.n	800438a <usb_lld_pump+0x1ca>
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 8004396:	f8de 3004 	ldr.w	r3, [lr, #4]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 800439a:	f8de c000 	ldr.w	ip, [lr]
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
                               usbp->epc[ep]->in_state->txbuf,
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
 800439e:	440a      	add	r2, r1
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 80043a0:	4419      	add	r1, r3
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 80043a2:	458c      	cmp	ip, r1
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
                               usbp->epc[ep]->in_state->txbuf,
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
 80043a4:	f8ce 2008 	str.w	r2, [lr, #8]
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 80043a8:	f8ce 1004 	str.w	r1, [lr, #4]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 80043ac:	d910      	bls.n	80043d0 <usb_lld_pump+0x210>
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80043ae:	9b01      	ldr	r3, [sp, #4]
    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return true;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 80043b0:	ebc1 010c 	rsb	r1, r1, ip
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 80043b4:	f8d3 3918 	ldr.w	r3, [r3, #2328]	; 0x918
 80043b8:	4549      	cmp	r1, r9
 80043ba:	bf28      	it	cs
 80043bc:	4649      	movcs	r1, r9
 80043be:	b29b      	uxth	r3, r3
 80043c0:	ebb1 0f83 	cmp.w	r1, r3, lsl #2
 80043c4:	d828      	bhi.n	8004418 <usb_lld_pump+0x258>
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {

  osalDbgAssert(n > 0, "is zero");
 80043c6:	2900      	cmp	r1, #0
 80043c8:	d1d9      	bne.n	800437e <usb_lld_pump+0x1be>
 80043ca:	4818      	ldr	r0, [pc, #96]	; (800442c <usb_lld_pump+0x26c>)
 80043cc:	f7fe fc28 	bl	8002c20 <chSysHalt>
 80043d0:	465c      	mov	r4, fp
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return true;
 80043d2:	f04f 0901 	mov.w	r9, #1
 80043d6:	2320      	movs	r3, #32
 80043d8:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80043dc:	f7fe ff18 	bl	8003210 <_dbg_check_lock>
        osalSysUnlock();

        done = otg_txfifo_handler(usbp, ep);

        osalSysLock();
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 80043e0:	68ab      	ldr	r3, [r5, #8]
 80043e2:	f043 0301 	orr.w	r3, r3, #1
 80043e6:	60ab      	str	r3, [r5, #8]
        if (!done)
 80043e8:	f1b9 0f00 	cmp.w	r9, #0
 80043ec:	d104      	bne.n	80043f8 <usb_lld_pump+0x238>
          otgp->DIEPEMPMSK |= epmask;
 80043ee:	f8d5 3834 	ldr.w	r3, [r5, #2100]	; 0x834
 80043f2:	431f      	orrs	r7, r3
 80043f4:	f8c5 7834 	str.w	r7, [r5, #2100]	; 0x834
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80043f8:	f7fe fee2 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80043fc:	f8d8 3000 	ldr.w	r3, [r8]
 8004400:	4a08      	ldr	r2, [pc, #32]	; (8004424 <usb_lld_pump+0x264>)
 8004402:	4543      	cmp	r3, r8
 8004404:	d005      	beq.n	8004412 <usb_lld_pump+0x252>
 8004406:	6992      	ldr	r2, [r2, #24]
 8004408:	689b      	ldr	r3, [r3, #8]
 800440a:	6892      	ldr	r2, [r2, #8]
 800440c:	429a      	cmp	r2, r3
 800440e:	f4ff af75 	bcc.w	80042fc <usb_lld_pump+0x13c>
 8004412:	f38a 8811 	msr	BASEPRI, sl
 8004416:	e763      	b.n	80042e0 <usb_lld_pump+0x120>
 8004418:	465c      	mov	r4, fp
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
      return false;
 800441a:	f04f 0900 	mov.w	r9, #0
 800441e:	e7da      	b.n	80043d6 <usb_lld_pump+0x216>
 8004420:	08005234 	.word	0x08005234
 8004424:	20001320 	.word	0x20001320
 8004428:	08005260 	.word	0x08005260
 800442c:	08005244 	.word	0x08005244

08004430 <chSchWakeupS.constprop.51>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8004430:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = currp;
 8004432:	4d1a      	ldr	r5, [pc, #104]	; (800449c <chSchWakeupS.constprop.51+0x6c>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8004434:	4604      	mov	r4, r0
  thread_t *otp = currp;

  chDbgCheckClassS();
 8004436:	f7fe fc13 	bl	8002c60 <chDbgCheckClassS>

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800443a:	682b      	ldr	r3, [r5, #0]
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 800443c:	69a8      	ldr	r0, [r5, #24]

  chDbgCheckClassS();

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800443e:	42ab      	cmp	r3, r5
 8004440:	d02a      	beq.n	8004498 <chSchWakeupS.constprop.51+0x68>
 8004442:	689a      	ldr	r2, [r3, #8]
 8004444:	6883      	ldr	r3, [r0, #8]
 8004446:	4293      	cmp	r3, r2
 8004448:	d320      	bcc.n	800448c <chSchWakeupS.constprop.51+0x5c>

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 800444a:	68a2      	ldr	r2, [r4, #8]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 800444c:	2100      	movs	r1, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 800444e:	429a      	cmp	r2, r3
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8004450:	6261      	str	r1, [r4, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8004452:	d916      	bls.n	8004482 <chSchWakeupS.constprop.51+0x52>
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyI(otp);
 8004454:	f7fe fddc 	bl	8003010 <chSchReadyI>
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 8004458:	2301      	movs	r3, #1

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 800445a:	4601      	mov	r1, r0
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    otp = chSchReadyI(otp);
 800445c:	4606      	mov	r6, r0
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 800445e:	f884 3020 	strb.w	r3, [r4, #32]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8004462:	4620      	mov	r0, r4
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 8004464:	61ac      	str	r4, [r5, #24]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8004466:	f7fe fbab 	bl	8002bc0 <_trace_switch>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800446a:	f3ef 8309 	mrs	r3, PSP
 800446e:	69f2      	ldr	r2, [r6, #28]
 8004470:	3b64      	subs	r3, #100	; 0x64
 8004472:	429a      	cmp	r2, r3
 8004474:	d80d      	bhi.n	8004492 <chSchWakeupS.constprop.51+0x62>
 8004476:	4620      	mov	r0, r4
 8004478:	4631      	mov	r1, r6
  }
}
 800447a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 800447e:	f7fb bf2d 	b.w	80002dc <_port_switch>
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
 8004482:	4620      	mov	r0, r4
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 8004484:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
    (void) chSchReadyI(ntp);
 8004488:	f7fe bdc2 	b.w	8003010 <chSchReadyI>
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;

  chDbgCheckClassS();

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800448c:	4804      	ldr	r0, [pc, #16]	; (80044a0 <chSchWakeupS.constprop.51+0x70>)
 800448e:	f7fe fbc7 	bl	8002c20 <chSysHalt>
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8004492:	4804      	ldr	r0, [pc, #16]	; (80044a4 <chSchWakeupS.constprop.51+0x74>)
 8004494:	f7fe fbc4 	bl	8002c20 <chSysHalt>
 8004498:	6883      	ldr	r3, [r0, #8]
 800449a:	e7d6      	b.n	800444a <chSchWakeupS.constprop.51+0x1a>
 800449c:	20001320 	.word	0x20001320
 80044a0:	080053b4 	.word	0x080053b4
 80044a4:	08005048 	.word	0x08005048
	...

080044b0 <chTMStartMeasurementX.constprop.48>:
 80044b0:	4b01      	ldr	r3, [pc, #4]	; (80044b8 <chTMStartMeasurementX.constprop.48+0x8>)
 80044b2:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 80044b4:	6083      	str	r3, [r0, #8]
 80044b6:	4770      	bx	lr
 80044b8:	e0001000 	.word	0xe0001000
 80044bc:	00000000 	.word	0x00000000

080044c0 <chThdDequeueAllI.constprop.42>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 80044c0:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 80044c2:	6803      	ldr	r3, [r0, #0]

  while (queue_notempty(tqp)) {
 80044c4:	4298      	cmp	r0, r3
 80044c6:	d00a      	beq.n	80044de <chThdDequeueAllI.constprop.42+0x1e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80044c8:	681a      	ldr	r2, [r3, #0]
 80044ca:	6002      	str	r2, [r0, #0]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 80044cc:	f893 1020 	ldrb.w	r1, [r3, #32]
  tqp->next->queue.prev = (thread_t *)tqp;
 80044d0:	6050      	str	r0, [r2, #4]
 80044d2:	2904      	cmp	r1, #4
 80044d4:	4604      	mov	r4, r0
 80044d6:	d003      	beq.n	80044e0 <chThdDequeueAllI.constprop.42+0x20>
 80044d8:	480a      	ldr	r0, [pc, #40]	; (8004504 <chThdDequeueAllI.constprop.42+0x44>)
 80044da:	f7fe fba1 	bl	8002c20 <chSysHalt>
 80044de:	bd38      	pop	{r3, r4, r5, pc}

  tp->u.rdymsg = msg;
 80044e0:	f06f 0501 	mvn.w	r5, #1
 80044e4:	625d      	str	r5, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 80044e6:	4618      	mov	r0, r3
 80044e8:	f7fe fd92 	bl	8003010 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 80044ec:	6823      	ldr	r3, [r4, #0]
 80044ee:	429c      	cmp	r4, r3
 80044f0:	d0f5      	beq.n	80044de <chThdDequeueAllI.constprop.42+0x1e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80044f2:	681a      	ldr	r2, [r3, #0]
 80044f4:	6022      	str	r2, [r4, #0]

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 80044f6:	f893 1020 	ldrb.w	r1, [r3, #32]
  tqp->next->queue.prev = (thread_t *)tqp;
 80044fa:	6054      	str	r4, [r2, #4]
 80044fc:	2904      	cmp	r1, #4
 80044fe:	d1eb      	bne.n	80044d8 <chThdDequeueAllI.constprop.42+0x18>
 8004500:	e7f0      	b.n	80044e4 <chThdDequeueAllI.constprop.42+0x24>
 8004502:	bf00      	nop
 8004504:	080053c4 	.word	0x080053c4
	...

08004510 <dmaStreamAllocate.constprop.31>:
 * @retval false        no error, stream taken.
 * @retval true         error, stream already taken.
 *
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
 8004510:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {

  osalDbgCheck(dmastp != NULL);
 8004512:	2800      	cmp	r0, #0
 8004514:	d04f      	beq.n	80045b6 <dmaStreamAllocate.constprop.31+0xa6>

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8004516:	4e29      	ldr	r6, [pc, #164]	; (80045bc <dmaStreamAllocate.constprop.31+0xac>)
 8004518:	7a44      	ldrb	r4, [r0, #9]
 800451a:	6832      	ldr	r2, [r6, #0]
 800451c:	2301      	movs	r3, #1
 800451e:	fa03 f704 	lsl.w	r7, r3, r4
 8004522:	4217      	tst	r7, r2
 8004524:	d143      	bne.n	80045ae <dmaStreamAllocate.constprop.31+0x9e>
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8004526:	4d26      	ldr	r5, [pc, #152]	; (80045c0 <dmaStreamAllocate.constprop.31+0xb0>)
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8004528:	4b26      	ldr	r3, [pc, #152]	; (80045c4 <dmaStreamAllocate.constprop.31+0xb4>)
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 800452a:	f845 1034 	str.w	r1, [r5, r4, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1U << dmastp->selfindex);
 800452e:	433a      	orrs	r2, r7
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 8004530:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
  dma_streams_mask |= (1U << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 8004534:	f012 0fff 	tst.w	r2, #255	; 0xff
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1U << dmastp->selfindex);
 8004538:	6032      	str	r2, [r6, #0]
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 800453a:	6063      	str	r3, [r4, #4]
  dma_streams_mask |= (1U << dmastp->selfindex);

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
 800453c:	d004      	beq.n	8004548 <dmaStreamAllocate.constprop.31+0x38>
    rccEnableDMA1(false);
 800453e:	4c22      	ldr	r4, [pc, #136]	; (80045c8 <dmaStreamAllocate.constprop.31+0xb8>)
 8004540:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8004542:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8004546:	6323      	str	r3, [r4, #48]	; 0x30
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
 8004548:	f412 4f7f 	tst.w	r2, #65280	; 0xff00
 800454c:	d129      	bne.n	80045a2 <dmaStreamAllocate.constprop.31+0x92>
    rccEnableDMA2(false);
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 800454e:	6802      	ldr	r2, [r0, #0]
 8004550:	6813      	ldr	r3, [r2, #0]
 8004552:	f023 031f 	bic.w	r3, r3, #31
 8004556:	6013      	str	r3, [r2, #0]
 8004558:	6813      	ldr	r3, [r2, #0]
 800455a:	f013 0301 	ands.w	r3, r3, #1
 800455e:	d1fb      	bne.n	8004558 <dmaStreamAllocate.constprop.31+0x48>
 8004560:	7a05      	ldrb	r5, [r0, #8]
 8004562:	6846      	ldr	r6, [r0, #4]
 8004564:	243d      	movs	r4, #61	; 0x3d
 8004566:	40ac      	lsls	r4, r5
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8004568:	2521      	movs	r5, #33	; 0x21
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
    rccEnableDMA2(false);
  }

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 800456a:	6034      	str	r4, [r6, #0]
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 800456c:	6013      	str	r3, [r2, #0]
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 800456e:	6155      	str	r5, [r2, #20]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
 8004570:	b1f9      	cbz	r1, 80045b2 <dmaStreamAllocate.constprop.31+0xa2>
    nvicEnableVector(dmastp->vector, priority);
 8004572:	7a81      	ldrb	r1, [r0, #10]
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004574:	094a      	lsrs	r2, r1, #5
 8004576:	0092      	lsls	r2, r2, #2

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8004578:	f101 4460 	add.w	r4, r1, #3758096384	; 0xe0000000
 800457c:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
 8004580:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 8004584:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004588:	2001      	movs	r0, #1
 800458a:	f001 011f 	and.w	r1, r1, #31
 800458e:	fa00 f101 	lsl.w	r1, r0, r1

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8004592:	2550      	movs	r5, #80	; 0x50
 8004594:	f884 5300 	strb.w	r5, [r4, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004598:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800459c:	6011      	str	r1, [r2, #0]
 800459e:	4618      	mov	r0, r3
 80045a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0U) {
    rccEnableDMA1(false);
  }
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0U) {
    rccEnableDMA2(false);
 80045a2:	4a09      	ldr	r2, [pc, #36]	; (80045c8 <dmaStreamAllocate.constprop.31+0xb8>)
 80045a4:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80045a6:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80045aa:	6313      	str	r3, [r2, #48]	; 0x30
 80045ac:	e7cf      	b.n	800454e <dmaStreamAllocate.constprop.31+0x3e>

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;
 80045ae:	4618      	mov	r0, r3
 80045b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  dmaStreamDisable(dmastp);
  dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
  dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL) {
 80045b2:	4608      	mov	r0, r1
    nvicEnableVector(dmastp->vector, priority);
  }

  return false;
}
 80045b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {

  osalDbgCheck(dmastp != NULL);
 80045b6:	4805      	ldr	r0, [pc, #20]	; (80045cc <dmaStreamAllocate.constprop.31+0xbc>)
 80045b8:	f7fe fb32 	bl	8002c20 <chSysHalt>
 80045bc:	20001c28 	.word	0x20001c28
 80045c0:	20001ba8 	.word	0x20001ba8
 80045c4:	20001c2c 	.word	0x20001c2c
 80045c8:	40023800 	.word	0x40023800
 80045cc:	0800537c 	.word	0x0800537c

080045d0 <_pal_lld_setgroupmode.constprop.12>:
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 80045d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 80045d4:	2501      	movs	r5, #1

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80045d6:	4c21      	ldr	r4, [pc, #132]	; (800465c <_pal_lld_setgroupmode.constprop.12+0x8c>)
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 80045d8:	46a9      	mov	r9, r5
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 80045da:	2300      	movs	r3, #0
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80045dc:	2602      	movs	r6, #2
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80045de:	f04f 0804 	mov.w	r8, #4
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 80045e2:	f04f 0c0f 	mov.w	ip, #15
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 80045e6:	f04f 0e03 	mov.w	lr, #3
 80045ea:	e00e      	b.n	800460a <_pal_lld_setgroupmode.constprop.12+0x3a>
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80045ec:	6a22      	ldr	r2, [r4, #32]
 80045ee:	ea22 0b0b 	bic.w	fp, r2, fp
 80045f2:	ea4b 020a 	orr.w	r2, fp, sl
 80045f6:	6222      	str	r2, [r4, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 80045f8:	6822      	ldr	r2, [r4, #0]
 80045fa:	4011      	ands	r1, r2
 80045fc:	4331      	orrs	r1, r6
 80045fe:	6021      	str	r1, [r4, #0]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 8004600:	0840      	lsrs	r0, r0, #1
 8004602:	d028      	beq.n	8004656 <_pal_lld_setgroupmode.constprop.12+0x86>
      return;
    otyper <<= 1;
 8004604:	006d      	lsls	r5, r5, #1
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 8004606:	00b6      	lsls	r6, r6, #2
    bit++;
 8004608:	3301      	adds	r3, #1
 800460a:	005a      	lsls	r2, r3, #1
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 800460c:	fa0e f102 	lsl.w	r1, lr, r2
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8004610:	f003 0207 	and.w	r2, r3, #7
 8004614:	0092      	lsls	r2, r2, #2
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 8004616:	f010 0f01 	tst.w	r0, #1
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 800461a:	fa09 f703 	lsl.w	r7, r9, r3
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800461e:	ea6f 0101 	mvn.w	r1, r1
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8004622:	fa08 fa02 	lsl.w	sl, r8, r2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8004626:	fa0c fb02 	lsl.w	fp, ip, r2
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 800462a:	d0e9      	beq.n	8004600 <_pal_lld_setgroupmode.constprop.12+0x30>

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800462c:	6862      	ldr	r2, [r4, #4]
 800462e:	ea22 0207 	bic.w	r2, r2, r7
 8004632:	432a      	orrs	r2, r5
 8004634:	6062      	str	r2, [r4, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8004636:	68a2      	ldr	r2, [r4, #8]
 8004638:	400a      	ands	r2, r1
 800463a:	60a2      	str	r2, [r4, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800463c:	68e2      	ldr	r2, [r4, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 800463e:	2b07      	cmp	r3, #7
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8004640:	ea02 0201 	and.w	r2, r2, r1
 8004644:	60e2      	str	r2, [r4, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8004646:	d9d1      	bls.n	80045ec <_pal_lld_setgroupmode.constprop.12+0x1c>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8004648:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800464a:	ea22 0b0b 	bic.w	fp, r2, fp
 800464e:	ea4b 020a 	orr.w	r2, fp, sl
 8004652:	6262      	str	r2, [r4, #36]	; 0x24
 8004654:	e7d0      	b.n	80045f8 <_pal_lld_setgroupmode.constprop.12+0x28>
 8004656:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800465a:	bf00      	nop
 800465c:	40020400 	.word	0x40020400

08004660 <otg_epout_handler.constprop.7>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8004660:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8004664:	4e2d      	ldr	r6, [pc, #180]	; (800471c <otg_epout_handler.constprop.7+0xbc>)
 8004666:	6d77      	ldr	r7, [r6, #84]	; 0x54
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8004668:	eb07 1340 	add.w	r3, r7, r0, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 800466c:	4605      	mov	r5, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->oe[ep].DOEPINT;
 800466e:	f8d3 4b08 	ldr.w	r4, [r3, #2824]	; 0xb08

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 8004672:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8004676:	0720      	lsls	r0, r4, #28
 8004678:	d503      	bpl.n	8004682 <otg_epout_handler.constprop.7+0x22>
 800467a:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 800467e:	0719      	lsls	r1, r3, #28
 8004680:	d441      	bmi.n	8004706 <otg_epout_handler.constprop.7+0xa6>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
  }
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8004682:	07e2      	lsls	r2, r4, #31
 8004684:	d52b      	bpl.n	80046de <otg_epout_handler.constprop.7+0x7e>
 8004686:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 800468a:	07db      	lsls	r3, r3, #31
 800468c:	d527      	bpl.n	80046de <otg_epout_handler.constprop.7+0x7e>
    USBOutEndpointState *osp;

    /* Receive transfer complete, checking if it is a SETUP transfer on EP0,
       than it must be ignored, the STUPM handler will take care of it.*/
    if ((ep == 0) && (usbp->ep0state == USB_EP0_WAITING_SETUP))
 800468e:	bb45      	cbnz	r5, 80046e2 <otg_epout_handler.constprop.7+0x82>
 8004690:	f896 3034 	ldrb.w	r3, [r6, #52]	; 0x34
 8004694:	2b00      	cmp	r3, #0
 8004696:	d03e      	beq.n	8004716 <otg_epout_handler.constprop.7+0xb6>
      return;

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;
 8004698:	f8df 8084 	ldr.w	r8, [pc, #132]	; 8004720 <otg_epout_handler.constprop.7+0xc0>
 800469c:	f8d8 1004 	ldr.w	r1, [r8, #4]
 80046a0:	698c      	ldr	r4, [r1, #24]

    /* A short packet always terminates a transaction.*/
    if ((ep == 0) &&
        ((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 80046a2:	8a4b      	ldrh	r3, [r1, #18]
 80046a4:	6867      	ldr	r7, [r4, #4]
 80046a6:	fbb7 f2f3 	udiv	r2, r7, r3
 80046aa:	fb03 7312 	mls	r3, r3, r2, r7

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;

    /* A short packet always terminates a transaction.*/
    if ((ep == 0) &&
 80046ae:	b9db      	cbnz	r3, 80046e8 <otg_epout_handler.constprop.7+0x88>
        ((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
        (osp->rxsize < osp->totsize)) {
 80046b0:	6822      	ldr	r2, [r4, #0]
 80046b2:	68e3      	ldr	r3, [r4, #12]
    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;

    /* A short packet always terminates a transaction.*/
    if ((ep == 0) &&
        ((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 80046b4:	429a      	cmp	r2, r3
 80046b6:	d217      	bcs.n	80046e8 <otg_epout_handler.constprop.7+0x88>
        (osp->rxsize < osp->totsize)) {
      /* For EP 0 only, in case the transaction covered only part of the total
         transfer then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 80046b8:	1a9b      	subs	r3, r3, r2
      osp->rxcnt  = 0;
 80046ba:	e884 0028 	stmia.w	r4, {r3, r5}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80046be:	2320      	movs	r3, #32
 80046c0:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80046c4:	f7fe fd2c 	bl	8003120 <_dbg_check_lock_from_isr>
      osalSysLockFromISR();
      usb_lld_start_out(usbp, ep);
 80046c8:	f1a8 0008 	sub.w	r0, r8, #8
 80046cc:	4629      	mov	r1, r5
 80046ce:	f7ff fd2f 	bl	8004130 <usb_lld_start_out>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80046d2:	f7fe fd0d 	bl	80030f0 <_dbg_check_unlock_from_isr>
 80046d6:	f385 8811 	msr	BASEPRI, r5
 80046da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80046de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
       than it must be ignored, the STUPM handler will take care of it.*/
    if ((ep == 0) && (usbp->ep0state == USB_EP0_WAITING_SETUP))
      return;

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;
 80046e2:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 80046e6:	68d9      	ldr	r1, [r3, #12]
      usb_lld_start_out(usbp, ep);
      osalSysUnlockFromISR();
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 80046e8:	8972      	ldrh	r2, [r6, #10]
 80046ea:	68cc      	ldr	r4, [r1, #12]
 80046ec:	2301      	movs	r3, #1
 80046ee:	40ab      	lsls	r3, r5
 80046f0:	ea22 0303 	bic.w	r3, r2, r3
 80046f4:	8173      	strh	r3, [r6, #10]
 80046f6:	2c00      	cmp	r4, #0
 80046f8:	d0f1      	beq.n	80046de <otg_epout_handler.constprop.7+0x7e>
 80046fa:	4629      	mov	r1, r5
 80046fc:	4623      	mov	r3, r4
 80046fe:	4807      	ldr	r0, [pc, #28]	; (800471c <otg_epout_handler.constprop.7+0xbc>)
    }
  }
}
 8004700:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      usb_lld_start_out(usbp, ep);
      osalSysUnlockFromISR();
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 8004704:	4718      	bx	r3
  otgp->oe[ep].DOEPINT = epint;

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 8004706:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 800470a:	4630      	mov	r0, r6
 800470c:	68db      	ldr	r3, [r3, #12]
 800470e:	4629      	mov	r1, r5
 8004710:	685b      	ldr	r3, [r3, #4]
 8004712:	4798      	blx	r3
 8004714:	e7b5      	b.n	8004682 <otg_epout_handler.constprop.7+0x22>
 8004716:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800471a:	bf00      	nop
 800471c:	200010e0 	.word	0x200010e0
 8004720:	200010e8 	.word	0x200010e8
	...

08004730 <otg_epin_handler.constprop.6>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8004730:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8004734:	4e2d      	ldr	r6, [pc, #180]	; (80047ec <otg_epin_handler.constprop.6+0xbc>)
 8004736:	6d75      	ldr	r5, [r6, #84]	; 0x54
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8004738:	eb05 1340 	add.w	r3, r5, r0, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 800473c:	4607      	mov	r7, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->ie[ep].DIEPINT;
 800473e:	f8d3 4908 	ldr.w	r4, [r3, #2312]	; 0x908

  otgp->ie[ep].DIEPINT = epint;
 8004742:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8004746:	07e1      	lsls	r1, r4, #31
 8004748:	d503      	bpl.n	8004752 <otg_epin_handler.constprop.6+0x22>
 800474a:	f8d5 3810 	ldr.w	r3, [r5, #2064]	; 0x810
 800474e:	07da      	lsls	r2, r3, #31
 8004750:	d409      	bmi.n	8004766 <otg_epin_handler.constprop.6+0x36>
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8004752:	0623      	lsls	r3, r4, #24
 8004754:	d505      	bpl.n	8004762 <otg_epin_handler.constprop.6+0x32>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 8004756:	2401      	movs	r4, #1
 8004758:	f8d5 3834 	ldr.w	r3, [r5, #2100]	; 0x834
 800475c:	40bc      	lsls	r4, r7
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 800475e:	421c      	tst	r4, r3
 8004760:	d118      	bne.n	8004794 <otg_epin_handler.constprop.6+0x64>
 8004762:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8004766:	eb06 0380 	add.w	r3, r6, r0, lsl #2
 800476a:	68d9      	ldr	r1, [r3, #12]
 800476c:	694b      	ldr	r3, [r1, #20]

    if (isp->txsize < isp->totsize) {
 800476e:	6818      	ldr	r0, [r3, #0]
 8004770:	68da      	ldr	r2, [r3, #12]
 8004772:	4290      	cmp	r0, r2
 8004774:	d327      	bcc.n	80047c6 <otg_epin_handler.constprop.6+0x96>
      usb_lld_start_in(usbp, ep);
      osalSysUnlockFromISR();
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 8004776:	8932      	ldrh	r2, [r6, #8]
 8004778:	f8d1 c008 	ldr.w	ip, [r1, #8]
 800477c:	2301      	movs	r3, #1
 800477e:	40bb      	lsls	r3, r7
 8004780:	ea22 0303 	bic.w	r3, r2, r3
 8004784:	8133      	strh	r3, [r6, #8]
 8004786:	f1bc 0f00 	cmp.w	ip, #0
 800478a:	d0e2      	beq.n	8004752 <otg_epin_handler.constprop.6+0x22>
 800478c:	4630      	mov	r0, r6
 800478e:	4639      	mov	r1, r7
 8004790:	47e0      	blx	ip
 8004792:	e7de      	b.n	8004752 <otg_epin_handler.constprop.6+0x22>
 8004794:	2320      	movs	r3, #32
 8004796:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 800479a:	f7fe fcc1 	bl	8003120 <_dbg_check_lock_from_isr>
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
    otgp->DIEPEMPMSK &= ~(1 << ep);
 800479e:	f8d5 2834 	ldr.w	r2, [r5, #2100]	; 0x834
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 80047a2:	6e33      	ldr	r3, [r6, #96]	; 0x60
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 80047a4:	4812      	ldr	r0, [pc, #72]	; (80047f0 <otg_epin_handler.constprop.6+0xc0>)
    otgp->DIEPEMPMSK &= ~(1 << ep);
 80047a6:	ea22 0204 	bic.w	r2, r2, r4
 80047aa:	f8c5 2834 	str.w	r2, [r5, #2100]	; 0x834
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 80047ae:	431c      	orrs	r4, r3
 80047b0:	2100      	movs	r1, #0
 80047b2:	6634      	str	r4, [r6, #96]	; 0x60
 80047b4:	f7fe fc54 	bl	8003060 <chThdResumeI>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80047b8:	f7fe fc9a 	bl	80030f0 <_dbg_check_unlock_from_isr>
 80047bc:	2300      	movs	r3, #0
 80047be:	f383 8811 	msr	BASEPRI, r3
 80047c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

    if (isp->txsize < isp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 80047c6:	1a12      	subs	r2, r2, r0
      isp->txcnt  = 0;
 80047c8:	f04f 0800 	mov.w	r8, #0
 80047cc:	e883 0104 	stmia.w	r3, {r2, r8}
 80047d0:	2320      	movs	r3, #32
 80047d2:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 80047d6:	f7fe fca3 	bl	8003120 <_dbg_check_lock_from_isr>
      osalSysLockFromISR();
      usb_lld_start_in(usbp, ep);
 80047da:	4630      	mov	r0, r6
 80047dc:	4639      	mov	r1, r7
 80047de:	f7ff fc4f 	bl	8004080 <usb_lld_start_in>
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 80047e2:	f7fe fc85 	bl	80030f0 <_dbg_check_unlock_from_isr>
 80047e6:	f388 8811 	msr	BASEPRI, r8
 80047ea:	e7b2      	b.n	8004752 <otg_epin_handler.constprop.6+0x22>
 80047ec:	200010e0 	.word	0x200010e0
 80047f0:	20001144 	.word	0x20001144
	...

08004800 <buffer_append_int16>:
 */

#include "buffer.h"

void buffer_append_int16(uint8_t* buffer, int16_t number, int32_t *index) {
	buffer[(*index)++] = number >> 8;
 8004800:	6813      	ldr	r3, [r2, #0]
 *      Author: benjamin
 */

#include "buffer.h"

void buffer_append_int16(uint8_t* buffer, int16_t number, int32_t *index) {
 8004802:	b430      	push	{r4, r5}
	buffer[(*index)++] = number >> 8;
 8004804:	1c5d      	adds	r5, r3, #1
 8004806:	120c      	asrs	r4, r1, #8
 8004808:	6015      	str	r5, [r2, #0]
 800480a:	54c4      	strb	r4, [r0, r3]
	buffer[(*index)++] = number;
 800480c:	6813      	ldr	r3, [r2, #0]
 800480e:	1c5c      	adds	r4, r3, #1
 8004810:	6014      	str	r4, [r2, #0]
 8004812:	54c1      	strb	r1, [r0, r3]
}
 8004814:	bc30      	pop	{r4, r5}
 8004816:	4770      	bx	lr
	...

08004820 <i2cMasterTransmitTimeout.constprop.27>:
 *                      be retrieved using @p i2cGetErrors().
 * @retval MSG_TIMEOUT  if a timeout occurred before operation end.
 *
 * @api
 */
msg_t i2cMasterTransmitTimeout(I2CDriver *i2cp,
 8004820:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004824:	b084      	sub	sp, #16
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               systime_t timeout) {
  msg_t rdymsg;

  osalDbgCheck((i2cp != NULL) && (addr != 0U) &&
 8004826:	b148      	cbz	r0, 800483c <i2cMasterTransmitTimeout.constprop.27+0x1c>
 8004828:	b142      	cbz	r2, 800483c <i2cMasterTransmitTimeout.constprop.27+0x1c>
 800482a:	b139      	cbz	r1, 800483c <i2cMasterTransmitTimeout.constprop.27+0x1c>
 800482c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 800482e:	b944      	cbnz	r4, 8004842 <i2cMasterTransmitTimeout.constprop.27+0x22>
 8004830:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8004832:	b11c      	cbz	r4, 800483c <i2cMasterTransmitTimeout.constprop.27+0x1c>
               (txbytes > 0U) && (txbuf != NULL) &&
               ((rxbytes == 0U) || ((rxbytes > 0U) && (rxbuf != NULL))) &&
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
 8004834:	4c4e      	ldr	r4, [pc, #312]	; (8004970 <i2cMasterTransmitTimeout.constprop.27+0x150>)
 8004836:	7825      	ldrb	r5, [r4, #0]
 8004838:	2d02      	cmp	r5, #2
 800483a:	d005      	beq.n	8004848 <i2cMasterTransmitTimeout.constprop.27+0x28>
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               systime_t timeout) {
  msg_t rdymsg;

  osalDbgCheck((i2cp != NULL) && (addr != 0U) &&
 800483c:	484d      	ldr	r0, [pc, #308]	; (8004974 <i2cMasterTransmitTimeout.constprop.27+0x154>)
 800483e:	f7fe f9ef 	bl	8002c20 <chSysHalt>
 8004842:	2b00      	cmp	r3, #0
 8004844:	d1f4      	bne.n	8004830 <i2cMasterTransmitTimeout.constprop.27+0x10>
 8004846:	e7f9      	b.n	800483c <i2cMasterTransmitTimeout.constprop.27+0x1c>
 8004848:	e88d 000f 	stmia.w	sp, {r0, r1, r2, r3}
 800484c:	2520      	movs	r5, #32
 800484e:	f385 8811 	msr	BASEPRI, r5
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8004852:	f7fe fcdd 	bl	8003210 <_dbg_check_lock>

  /* Resetting error flags for this transfer.*/
  i2cp->errors = I2C_NO_ERROR;

  /* Initializes driver fields, LSB = 0 -> transmit.*/
  i2cp->addr = (addr << 1);
 8004856:	9800      	ldr	r0, [sp, #0]

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004858:	4d47      	ldr	r5, [pc, #284]	; (8004978 <i2cMasterTransmitTimeout.constprop.27+0x158>)
 800485a:	0040      	lsls	r0, r0, #1
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 800485c:	2700      	movs	r7, #0
  i2cp->state = I2C_ACTIVE_TX;
 800485e:	2603      	movs	r6, #3
 8004860:	8420      	strh	r0, [r4, #32]
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8004862:	60a7      	str	r7, [r4, #8]
  i2cp->state = I2C_ACTIVE_TX;
 8004864:	7026      	strb	r6, [r4, #0]
 */
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
  I2C_TypeDef *dp = i2cp->i2c;
 8004866:	6b67      	ldr	r7, [r4, #52]	; 0x34
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004868:	f7fe fcaa 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800486c:	6828      	ldr	r0, [r5, #0]
 800486e:	a901      	add	r1, sp, #4
 8004870:	42a8      	cmp	r0, r5
 8004872:	c90e      	ldmia	r1, {r1, r2, r3}
 8004874:	d004      	beq.n	8004880 <i2cMasterTransmitTimeout.constprop.27+0x60>
 8004876:	69ae      	ldr	r6, [r5, #24]
 8004878:	6880      	ldr	r0, [r0, #8]
 800487a:	68b6      	ldr	r6, [r6, #8]
 800487c:	4286      	cmp	r6, r0
 800487e:	d33c      	bcc.n	80048fa <i2cMasterTransmitTimeout.constprop.27+0xda>
 8004880:	2000      	movs	r0, #0
 8004882:	f380 8811 	msr	BASEPRI, r0

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8004886:	6b26      	ldr	r6, [r4, #48]	; 0x30
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8004888:	6ae0      	ldr	r0, [r4, #44]	; 0x2c

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 800488a:	f8d6 e000 	ldr.w	lr, [r6]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 800488e:	6800      	ldr	r0, [r0, #0]

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8004890:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8004892:	f8d4 c024 	ldr.w	ip, [r4, #36]	; 0x24

  /* Releases the lock from high level driver.*/
  osalSysUnlock();

  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8004896:	f8ce 6000 	str.w	r6, [lr]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 800489a:	f8ce 100c 	str.w	r1, [lr, #12]
 800489e:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 80048a2:	f8ce 2004 	str.w	r2, [lr, #4]

  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 80048a6:	f8c0 c000 	str.w	ip, [r0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 80048aa:	60c3      	str	r3, [r0, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 80048ac:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80048ae:	6043      	str	r3, [r0, #4]
 80048b0:	f8d6 9024 	ldr.w	r9, [r6, #36]	; 0x24
 80048b4:	f8df a0c0 	ldr.w	sl, [pc, #192]	; 8004978 <i2cMasterTransmitTimeout.constprop.27+0x158>
 80048b8:	f04f 0820 	mov.w	r8, #32
 80048bc:	f388 8811 	msr	BASEPRI, r8
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80048c0:	f7fe fca6 	bl	8003210 <_dbg_check_lock>
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if (!(dp->SR2 & I2C_SR2_BUSY) && !(dp->CR1 & I2C_CR1_STOP))
 80048c4:	69bb      	ldr	r3, [r7, #24]
 80048c6:	0799      	lsls	r1, r3, #30
 80048c8:	d402      	bmi.n	80048d0 <i2cMasterTransmitTimeout.constprop.27+0xb0>
 80048ca:	683b      	ldr	r3, [r7, #0]
 80048cc:	059a      	lsls	r2, r3, #22
 80048ce:	d52d      	bpl.n	800492c <i2cMasterTransmitTimeout.constprop.27+0x10c>
 80048d0:	6a73      	ldr	r3, [r6, #36]	; 0x24
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 80048d2:	ebc9 0303 	rsb	r3, r9, r3
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end))
 80048d6:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 80048da:	d211      	bcs.n	8004900 <i2cMasterTransmitTimeout.constprop.27+0xe0>
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80048dc:	f7fe fc70 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80048e0:	682b      	ldr	r3, [r5, #0]
 80048e2:	42ab      	cmp	r3, r5
 80048e4:	d005      	beq.n	80048f2 <i2cMasterTransmitTimeout.constprop.27+0xd2>
 80048e6:	f8da 2018 	ldr.w	r2, [sl, #24]
 80048ea:	689b      	ldr	r3, [r3, #8]
 80048ec:	6892      	ldr	r2, [r2, #8]
 80048ee:	429a      	cmp	r2, r3
 80048f0:	d303      	bcc.n	80048fa <i2cMasterTransmitTimeout.constprop.27+0xda>
 80048f2:	2300      	movs	r3, #0
 80048f4:	f383 8811 	msr	BASEPRI, r3
 80048f8:	e7e0      	b.n	80048bc <i2cMasterTransmitTimeout.constprop.27+0x9c>
 80048fa:	4820      	ldr	r0, [pc, #128]	; (800497c <i2cMasterTransmitTimeout.constprop.27+0x15c>)
 80048fc:	f7fe f990 	bl	8002c20 <chSysHalt>
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
 8004900:	2305      	movs	r3, #5
 8004902:	7023      	strb	r3, [r4, #0]
 8004904:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8004908:	f7fe fc5a 	bl	80031c0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800490c:	682b      	ldr	r3, [r5, #0]
 800490e:	4a1a      	ldr	r2, [pc, #104]	; (8004978 <i2cMasterTransmitTimeout.constprop.27+0x158>)
 8004910:	42ab      	cmp	r3, r5
 8004912:	d004      	beq.n	800491e <i2cMasterTransmitTimeout.constprop.27+0xfe>
 8004914:	6992      	ldr	r2, [r2, #24]
 8004916:	689b      	ldr	r3, [r3, #8]
 8004918:	6892      	ldr	r2, [r2, #8]
 800491a:	429a      	cmp	r2, r3
 800491c:	d316      	bcc.n	800494c <i2cMasterTransmitTimeout.constprop.27+0x12c>
 800491e:	2300      	movs	r3, #0
 8004920:	f383 8811 	msr	BASEPRI, r3
  else {
    i2cp->state = I2C_READY;
  }
  osalSysUnlock();
  return rdymsg;
}
 8004924:	4630      	mov	r0, r6
 8004926:	b004      	add	sp, #16
 8004928:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

    osalSysUnlock();
  }

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_ITEVTEN;
 800492c:	687b      	ldr	r3, [r7, #4]
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");
 800492e:	69e1      	ldr	r1, [r4, #28]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004930:	69aa      	ldr	r2, [r5, #24]
 8004932:	f8df 803c 	ldr.w	r8, [pc, #60]	; 8004970 <i2cMasterTransmitTimeout.constprop.27+0x150>
 8004936:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800493a:	607b      	str	r3, [r7, #4]
  dp->CR1 |= I2C_CR1_START;
 800493c:	683b      	ldr	r3, [r7, #0]
 800493e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004942:	603b      	str	r3, [r7, #0]
 8004944:	b129      	cbz	r1, 8004952 <i2cMasterTransmitTimeout.constprop.27+0x132>
 8004946:	480e      	ldr	r0, [pc, #56]	; (8004980 <i2cMasterTransmitTimeout.constprop.27+0x160>)
 8004948:	f7fe f96a 	bl	8002c20 <chSysHalt>
 800494c:	480d      	ldr	r0, [pc, #52]	; (8004984 <i2cMasterTransmitTimeout.constprop.27+0x164>)
 800494e:	f7fe f967 	bl	8002c20 <chSysHalt>

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8004952:	4643      	mov	r3, r8
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8004954:	2003      	movs	r0, #3

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8004956:	f843 2f1c 	str.w	r2, [r3, #28]!
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800495a:	990d      	ldr	r1, [sp, #52]	; 0x34
  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
  tp->u.wttrp = trp;
 800495c:	6253      	str	r3, [r2, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800495e:	f7fe fa27 	bl	8002db0 <chSchGoSleepTimeoutS>
  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
 8004962:	1c43      	adds	r3, r0, #1
 8004964:	4606      	mov	r6, r0
 8004966:	d0cb      	beq.n	8004900 <i2cMasterTransmitTimeout.constprop.27+0xe0>
    i2cp->state = I2C_LOCKED;
  }
  else {
    i2cp->state = I2C_READY;
 8004968:	2302      	movs	r3, #2
 800496a:	f888 3000 	strb.w	r3, [r8]
 800496e:	e7cb      	b.n	8004908 <i2cMasterTransmitTimeout.constprop.27+0xe8>
 8004970:	20001c2c 	.word	0x20001c2c
 8004974:	080053d8 	.word	0x080053d8
 8004978:	20001320 	.word	0x20001320
 800497c:	08005370 	.word	0x08005370
 8004980:	0800539c 	.word	0x0800539c
 8004984:	08005390 	.word	0x08005390
	...

08004990 <I2CdevwriteBytes.constprop.4>:
 * @param regAddr First register address to write to
 * @param length Number of bytes to write
 * @param data Buffer to copy new data from
 * @return Status of operation (true = success)
 */
bool I2CdevwriteBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data) {
 8004990:	b570      	push	{r4, r5, r6, lr}
 8004992:	b094      	sub	sp, #80	; 0x50
    uint8_t mpu_txbuf[I2CDEV_BUFFER_LENGTH], mpu_rxbuf[1];
    msg_t rdymsg;
    if((length + 1)> I2CDEV_BUFFER_LENGTH) {
        return FALSE;
    }
    mpu_txbuf[0] = regAddr;
 8004994:	ac14      	add	r4, sp, #80	; 0x50
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8004996:	4d10      	ldr	r5, [pc, #64]	; (80049d8 <I2CdevwriteBytes.constprop.4+0x48>)
    memcpy(mpu_txbuf + sizeof(uint8_t), data, sizeof(uint8_t) * length);
 8004998:	7813      	ldrb	r3, [r2, #0]
    uint8_t mpu_txbuf[I2CDEV_BUFFER_LENGTH], mpu_rxbuf[1];
    msg_t rdymsg;
    if((length + 1)> I2CDEV_BUFFER_LENGTH) {
        return FALSE;
    }
    mpu_txbuf[0] = regAddr;
 800499a:	f804 1d40 	strb.w	r1, [r4, #-64]!
 * @param regAddr First register address to write to
 * @param length Number of bytes to write
 * @param data Buffer to copy new data from
 * @return Status of operation (true = success)
 */
bool I2CdevwriteBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data) {
 800499e:	4606      	mov	r6, r0
 80049a0:	4628      	mov	r0, r5
    msg_t rdymsg;
    if((length + 1)> I2CDEV_BUFFER_LENGTH) {
        return FALSE;
    }
    mpu_txbuf[0] = regAddr;
    memcpy(mpu_txbuf + sizeof(uint8_t), data, sizeof(uint8_t) * length);
 80049a2:	f88d 3011 	strb.w	r3, [sp, #17]
 80049a6:	f7fe fca3 	bl	80032f0 <chMtxLock>

    i2cAcquireBus(&I2C_MPU);
    rdymsg = i2cMasterTransmit(&I2C_MPU, devAddr, mpu_txbuf, length + 1, mpu_rxbuf, 0);
 80049aa:	2200      	movs	r2, #0
 80049ac:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80049b0:	4621      	mov	r1, r4
 80049b2:	e88d 000c 	stmia.w	sp, {r2, r3}
 80049b6:	4630      	mov	r0, r6
 80049b8:	2202      	movs	r2, #2
 80049ba:	ab03      	add	r3, sp, #12
 80049bc:	f7ff ff30 	bl	8004820 <i2cMasterTransmitTimeout.constprop.27>
 80049c0:	4604      	mov	r4, r0
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 80049c2:	4628      	mov	r0, r5
 80049c4:	f7fe fc34 	bl	8003230 <chMtxUnlock>
    i2cReleaseBus(&I2C_MPU);
    if(rdymsg == MSG_TIMEOUT || rdymsg == MSG_RESET) {
 80049c8:	1ca0      	adds	r0, r4, #2
        return FALSE;
    }
    return TRUE;
}
 80049ca:	2801      	cmp	r0, #1
 80049cc:	bf94      	ite	ls
 80049ce:	2000      	movls	r0, #0
 80049d0:	2001      	movhi	r0, #1
 80049d2:	b014      	add	sp, #80	; 0x50
 80049d4:	bd70      	pop	{r4, r5, r6, pc}
 80049d6:	bf00      	nop
 80049d8:	20001c38 	.word	0x20001c38
 80049dc:	00000000 	.word	0x00000000

080049e0 <I2CdevreadBytes.constprop.3>:
 * @param length Number of bytes to read
 * @param data Buffer to store read data in
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Number of bytes read (-1 indicates failure)
 */
int8_t I2CdevreadBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout) {
 80049e0:	b570      	push	{r4, r5, r6, lr}
 80049e2:	b084      	sub	sp, #16
    //uint8_t mpu_txbuf[1], mpu_rxbuf[I2CDEV_BUFFER_LENGTH], i;
    msg_t rdymsg;
    if(length > I2CDEV_BUFFER_LENGTH) {
 80049e4:	2a40      	cmp	r2, #64	; 0x40
 * @param length Number of bytes to read
 * @param data Buffer to store read data in
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Number of bytes read (-1 indicates failure)
 */
int8_t I2CdevreadBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout) {
 80049e6:	f88d 100f 	strb.w	r1, [sp, #15]
    //uint8_t mpu_txbuf[1], mpu_rxbuf[I2CDEV_BUFFER_LENGTH], i;
    msg_t rdymsg;
    if(length > I2CDEV_BUFFER_LENGTH) {
 80049ea:	d902      	bls.n	80049f2 <I2CdevreadBytes.constprop.3+0x12>
        return FALSE;
 80049ec:	2000      	movs	r0, #0
    i2cReleaseBus(&I2C_MPU);
    if(rdymsg == MSG_TIMEOUT || rdymsg == MSG_RESET) {
        return FALSE;
    }
    return TRUE;
}
 80049ee:	b004      	add	sp, #16
 80049f0:	bd70      	pop	{r4, r5, r6, pc}
 80049f2:	4606      	mov	r6, r0
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 80049f4:	480d      	ldr	r0, [pc, #52]	; (8004a2c <I2CdevreadBytes.constprop.3+0x4c>)
 80049f6:	4614      	mov	r4, r2
 80049f8:	461d      	mov	r5, r3
 80049fa:	f7fe fc79 	bl	80032f0 <chMtxLock>
    msg_t rdymsg;
    if(length > I2CDEV_BUFFER_LENGTH) {
        return FALSE;
    }
    i2cAcquireBus(&I2C_MPU);
    rdymsg = i2cMasterTransmitTimeout(&I2C_MPU, devAddr, &regAddr, 1, data, length, MS2ST(timeout));
 80049fe:	f242 7210 	movw	r2, #10000	; 0x2710
 8004a02:	9400      	str	r4, [sp, #0]
 8004a04:	462b      	mov	r3, r5
 8004a06:	9201      	str	r2, [sp, #4]
 8004a08:	f10d 010f 	add.w	r1, sp, #15
 8004a0c:	2201      	movs	r2, #1
 8004a0e:	4630      	mov	r0, r6
 8004a10:	f7ff ff06 	bl	8004820 <i2cMasterTransmitTimeout.constprop.27>
 8004a14:	4604      	mov	r4, r0
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8004a16:	4805      	ldr	r0, [pc, #20]	; (8004a2c <I2CdevreadBytes.constprop.3+0x4c>)
 8004a18:	f7fe fc0a 	bl	8003230 <chMtxUnlock>
    i2cReleaseBus(&I2C_MPU);
    if(rdymsg == MSG_TIMEOUT || rdymsg == MSG_RESET) {
 8004a1c:	1ca0      	adds	r0, r4, #2
 */
int8_t I2CdevreadBytes(uint8_t devAddr, uint8_t regAddr, uint8_t length, uint8_t *data, uint16_t timeout) {
    //uint8_t mpu_txbuf[1], mpu_rxbuf[I2CDEV_BUFFER_LENGTH], i;
    msg_t rdymsg;
    if(length > I2CDEV_BUFFER_LENGTH) {
        return FALSE;
 8004a1e:	2801      	cmp	r0, #1
 8004a20:	bf94      	ite	ls
 8004a22:	2000      	movls	r0, #0
 8004a24:	2001      	movhi	r0, #1
    i2cReleaseBus(&I2C_MPU);
    if(rdymsg == MSG_TIMEOUT || rdymsg == MSG_RESET) {
        return FALSE;
    }
    return TRUE;
}
 8004a26:	b004      	add	sp, #16
 8004a28:	bd70      	pop	{r4, r5, r6, pc}
 8004a2a:	bf00      	nop
 8004a2c:	20001c38 	.word	0x20001c38

08004a30 <I2CdevwriteBits>:
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2CdevwriteBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data) {
 8004a30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004a34:	b082      	sub	sp, #8
    //    xxx   args: bitStart=4, length=3
    // 00011100 mask byte
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b = 0;
 8004a36:	ac02      	add	r4, sp, #8
 8004a38:	2500      	movs	r5, #0
 8004a3a:	f804 5d02 	strb.w	r5, [r4, #-2]!
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2CdevwriteBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data) {
 8004a3e:	4617      	mov	r7, r2
 8004a40:	4698      	mov	r8, r3
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2CdevreadByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout) {
    return I2CdevreadBytes(devAddr, regAddr, 1, data, timeout);
 8004a42:	2201      	movs	r2, #1
 8004a44:	4623      	mov	r3, r4
 * @param bitStart First bit position to write (0-7)
 * @param length Number of bits to write (not more than 8)
 * @param data Right-aligned value to write
 * @return Status of operation (true = success)
 */
bool I2CdevwriteBits(uint8_t devAddr, uint8_t regAddr, uint8_t bitStart, uint8_t length, uint8_t data) {
 8004a46:	4606      	mov	r6, r0
 8004a48:	460d      	mov	r5, r1
 8004a4a:	f89d 4020 	ldrb.w	r4, [sp, #32]
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2CdevreadByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout) {
    return I2CdevreadBytes(devAddr, regAddr, 1, data, timeout);
 8004a4e:	f7ff ffc7 	bl	80049e0 <I2CdevreadBytes.constprop.3>
    // 00011100 mask byte
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b = 0;
    if (I2CdevreadByte(devAddr, regAddr, &b, I2CDEV_DEFAULT_READ_TIMEOUT) != 0) {
 8004a52:	b1c8      	cbz	r0, 8004a88 <I2CdevwriteBits+0x58>
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
 8004a54:	2101      	movs	r1, #1
 8004a56:	ebc8 0707 	rsb	r7, r8, r7
 8004a5a:	440f      	add	r7, r1
 8004a5c:	fa01 f108 	lsl.w	r1, r1, r8
        data <<= (bitStart - length + 1); // shift data into correct position
        data &= mask; // zero all non-important bits in data
        b &= ~(mask); // zero all important bits in existing byte
 8004a60:	f89d 2006 	ldrb.w	r2, [sp, #6]
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b = 0;
    if (I2CdevreadByte(devAddr, regAddr, &b, I2CDEV_DEFAULT_READ_TIMEOUT) != 0) {
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
        data <<= (bitStart - length + 1); // shift data into correct position
 8004a64:	40bc      	lsls	r4, r7
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b = 0;
    if (I2CdevreadByte(devAddr, regAddr, &b, I2CDEV_DEFAULT_READ_TIMEOUT) != 0) {
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
 8004a66:	3901      	subs	r1, #1
        data <<= (bitStart - length + 1); // shift data into correct position
 8004a68:	b2e3      	uxtb	r3, r4
    // 10101111 original value (sample)
    // 10100011 original & ~mask
    // 10101011 masked | value
    uint8_t b = 0;
    if (I2CdevreadByte(devAddr, regAddr, &b, I2CDEV_DEFAULT_READ_TIMEOUT) != 0) {
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
 8004a6a:	fa01 f407 	lsl.w	r4, r1, r7
        data <<= (bitStart - length + 1); // shift data into correct position
        data &= mask; // zero all non-important bits in data
 8004a6e:	4023      	ands	r3, r4
        b &= ~(mask); // zero all important bits in existing byte
 8004a70:	ea22 0404 	bic.w	r4, r2, r4
 8004a74:	aa02      	add	r2, sp, #8
        b |= data; // combine data with existing byte
 8004a76:	431c      	orrs	r4, r3
 8004a78:	f802 4d01 	strb.w	r4, [r2, #-1]!
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2CdevwriteByte(uint8_t devAddr, uint8_t regAddr, uint8_t data) {
    return I2CdevwriteBytes(devAddr, regAddr, 1, &data);
 8004a7c:	4630      	mov	r0, r6
 8004a7e:	4629      	mov	r1, r5
    if (I2CdevreadByte(devAddr, regAddr, &b, I2CDEV_DEFAULT_READ_TIMEOUT) != 0) {
        uint8_t mask = ((1 << length) - 1) << (bitStart - length + 1);
        data <<= (bitStart - length + 1); // shift data into correct position
        data &= mask; // zero all non-important bits in data
        b &= ~(mask); // zero all important bits in existing byte
        b |= data; // combine data with existing byte
 8004a80:	f88d 4006 	strb.w	r4, [sp, #6]
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2CdevwriteByte(uint8_t devAddr, uint8_t regAddr, uint8_t data) {
    return I2CdevwriteBytes(devAddr, regAddr, 1, &data);
 8004a84:	f7ff ff84 	bl	8004990 <I2CdevwriteBytes.constprop.4>
        b |= data; // combine data with existing byte
        return I2CdevwriteByte(devAddr, regAddr, b);
    } else {
        return FALSE;
    }
}
 8004a88:	b002      	add	sp, #8
 8004a8a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004a8e:	bf00      	nop

08004a90 <I2CdevwriteBit>:
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2CdevwriteBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {
 8004a90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004a92:	b083      	sub	sp, #12
      uint8_t b = 0;
 8004a94:	ac02      	add	r4, sp, #8
 8004a96:	2500      	movs	r5, #0
 8004a98:	f804 5d02 	strb.w	r5, [r4, #-2]!
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2CdevwriteBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {
 8004a9c:	4616      	mov	r6, r2
 8004a9e:	461f      	mov	r7, r3
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2CdevreadByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout) {
    return I2CdevreadBytes(devAddr, regAddr, 1, data, timeout);
 8004aa0:	2201      	movs	r2, #1
 8004aa2:	4623      	mov	r3, r4
 * @param regAddr Register regAddr to write to
 * @param bitNum Bit position to write (0-7)
 * @param value New bit value to write
 * @return Status of operation (true = success)
 */
bool I2CdevwriteBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {
 8004aa4:	4605      	mov	r5, r0
 8004aa6:	460c      	mov	r4, r1
 * @param data Container for byte value read from device
 * @param timeout Optional read timeout in milliseconds (0 to disable, leave off to use default class value in I2Cdev::readTimeout)
 * @return Status of read operation (true = success)
 */
int8_t I2CdevreadByte(uint8_t devAddr, uint8_t regAddr, uint8_t *data, uint16_t timeout) {
    return I2CdevreadBytes(devAddr, regAddr, 1, data, timeout);
 8004aa8:	f7ff ff9a 	bl	80049e0 <I2CdevreadBytes.constprop.3>
 * @return Status of operation (true = success)
 */
bool I2CdevwriteBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {
      uint8_t b = 0;
    I2CdevreadByte(devAddr, regAddr, &b, I2CDEV_DEFAULT_READ_TIMEOUT);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 8004aac:	2301      	movs	r3, #1
 8004aae:	f89d 2006 	ldrb.w	r2, [sp, #6]
 8004ab2:	40b3      	lsls	r3, r6
 8004ab4:	b967      	cbnz	r7, 8004ad0 <I2CdevwriteBit+0x40>
 8004ab6:	ea22 0303 	bic.w	r3, r2, r3
 8004aba:	aa02      	add	r2, sp, #8
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2CdevwriteByte(uint8_t devAddr, uint8_t regAddr, uint8_t data) {
    return I2CdevwriteBytes(devAddr, regAddr, 1, &data);
 8004abc:	4628      	mov	r0, r5
 8004abe:	f802 3d01 	strb.w	r3, [r2, #-1]!
 8004ac2:	4621      	mov	r1, r4
 * @return Status of operation (true = success)
 */
bool I2CdevwriteBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {
      uint8_t b = 0;
    I2CdevreadByte(devAddr, regAddr, &b, I2CDEV_DEFAULT_READ_TIMEOUT);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 8004ac4:	f88d 3006 	strb.w	r3, [sp, #6]
 * @param regAddr Register address to write to
 * @param data New byte value to write
 * @return Status of operation (true = success)
 */
bool I2CdevwriteByte(uint8_t devAddr, uint8_t regAddr, uint8_t data) {
    return I2CdevwriteBytes(devAddr, regAddr, 1, &data);
 8004ac8:	f7ff ff62 	bl	8004990 <I2CdevwriteBytes.constprop.4>
bool I2CdevwriteBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {
      uint8_t b = 0;
    I2CdevreadByte(devAddr, regAddr, &b, I2CDEV_DEFAULT_READ_TIMEOUT);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
    return I2CdevwriteByte(devAddr, regAddr, b);
}
 8004acc:	b003      	add	sp, #12
 8004ace:	bdf0      	pop	{r4, r5, r6, r7, pc}
 * @return Status of operation (true = success)
 */
bool I2CdevwriteBit(uint8_t devAddr, uint8_t regAddr, uint8_t bitNum, uint8_t data) {
      uint8_t b = 0;
    I2CdevreadByte(devAddr, regAddr, &b, I2CDEV_DEFAULT_READ_TIMEOUT);
    b = (data != 0) ? (b | (1 << bitNum)) : (b & ~(1 << bitNum));
 8004ad0:	4313      	orrs	r3, r2
 8004ad2:	b2db      	uxtb	r3, r3
 8004ad4:	e7f1      	b.n	8004aba <I2CdevwriteBit+0x2a>
 8004ad6:	bf00      	nop

08004ad8 <memset>:
 8004ad8:	b470      	push	{r4, r5, r6}
 8004ada:	0784      	lsls	r4, r0, #30
 8004adc:	d046      	beq.n	8004b6c <memset+0x94>
 8004ade:	1e54      	subs	r4, r2, #1
 8004ae0:	2a00      	cmp	r2, #0
 8004ae2:	d041      	beq.n	8004b68 <memset+0x90>
 8004ae4:	b2cd      	uxtb	r5, r1
 8004ae6:	4603      	mov	r3, r0
 8004ae8:	e002      	b.n	8004af0 <memset+0x18>
 8004aea:	1e62      	subs	r2, r4, #1
 8004aec:	b3e4      	cbz	r4, 8004b68 <memset+0x90>
 8004aee:	4614      	mov	r4, r2
 8004af0:	f803 5b01 	strb.w	r5, [r3], #1
 8004af4:	079a      	lsls	r2, r3, #30
 8004af6:	d1f8      	bne.n	8004aea <memset+0x12>
 8004af8:	2c03      	cmp	r4, #3
 8004afa:	d92e      	bls.n	8004b5a <memset+0x82>
 8004afc:	b2cd      	uxtb	r5, r1
 8004afe:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8004b02:	2c0f      	cmp	r4, #15
 8004b04:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8004b08:	d919      	bls.n	8004b3e <memset+0x66>
 8004b0a:	f103 0210 	add.w	r2, r3, #16
 8004b0e:	4626      	mov	r6, r4
 8004b10:	3e10      	subs	r6, #16
 8004b12:	2e0f      	cmp	r6, #15
 8004b14:	f842 5c10 	str.w	r5, [r2, #-16]
 8004b18:	f842 5c0c 	str.w	r5, [r2, #-12]
 8004b1c:	f842 5c08 	str.w	r5, [r2, #-8]
 8004b20:	f842 5c04 	str.w	r5, [r2, #-4]
 8004b24:	f102 0210 	add.w	r2, r2, #16
 8004b28:	d8f2      	bhi.n	8004b10 <memset+0x38>
 8004b2a:	f1a4 0210 	sub.w	r2, r4, #16
 8004b2e:	f022 020f 	bic.w	r2, r2, #15
 8004b32:	f004 040f 	and.w	r4, r4, #15
 8004b36:	3210      	adds	r2, #16
 8004b38:	2c03      	cmp	r4, #3
 8004b3a:	4413      	add	r3, r2
 8004b3c:	d90d      	bls.n	8004b5a <memset+0x82>
 8004b3e:	461e      	mov	r6, r3
 8004b40:	4622      	mov	r2, r4
 8004b42:	3a04      	subs	r2, #4
 8004b44:	2a03      	cmp	r2, #3
 8004b46:	f846 5b04 	str.w	r5, [r6], #4
 8004b4a:	d8fa      	bhi.n	8004b42 <memset+0x6a>
 8004b4c:	1f22      	subs	r2, r4, #4
 8004b4e:	f022 0203 	bic.w	r2, r2, #3
 8004b52:	3204      	adds	r2, #4
 8004b54:	4413      	add	r3, r2
 8004b56:	f004 0403 	and.w	r4, r4, #3
 8004b5a:	b12c      	cbz	r4, 8004b68 <memset+0x90>
 8004b5c:	b2c9      	uxtb	r1, r1
 8004b5e:	441c      	add	r4, r3
 8004b60:	f803 1b01 	strb.w	r1, [r3], #1
 8004b64:	42a3      	cmp	r3, r4
 8004b66:	d1fb      	bne.n	8004b60 <memset+0x88>
 8004b68:	bc70      	pop	{r4, r5, r6}
 8004b6a:	4770      	bx	lr
 8004b6c:	4614      	mov	r4, r2
 8004b6e:	4603      	mov	r3, r0
 8004b70:	e7c2      	b.n	8004af8 <memset+0x20>
 8004b72:	bf00      	nop
